{"pages":[{"title":"About Me","text":"EducationI recieved my bachelor degree from Guilin University of Electronic Technoligy in 2019. InterestsGame development、Game Design Programming LanguageC++，C#, Lua ExperienceInternship: Front-end developmentGraduation project: Community Detection based on Graph Convolution NetworkNow: Unity engineering","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"C#入坑与VS的使用","text":"一、C#与.netC#: 一种编程语言，可以开发基于.net平台的应用 .net能干啥？ 桌面应用程序：C/S程序，比如QQ，办公软件等（Winform应用程序） Internet应用程序：B/S程序，即网站 二、入坑编程语言国际惯例——Hello World！开发IDE：Visual Studio 2019 创建项目步骤： 打开VS2019 &gt; 创建新项目 &gt; 平台选择Windows &gt; 语言选择C# &gt; 项目类型选择控制台 &gt; 自定义项目名、路径，选.Net框架4.7.2 &gt; 完成 此时模板生成： 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp1{ class Program { static void Main(string[] args) { } }} 于是我在Main函数下添加了两句 12Console.WriteLine(&quot;Long may the sun shine!&quot;); //控制台打印&quot;Long may the sun shine!&quot;Console.ReadKey(); //等待任意键继续 Ctrl + S 保存，点击功能栏的【启动】，运行程序 三、VS中常用快捷键 Ctrl + K + C : 注释选中代码 Ctrl + K + U : 取消对所选代码的注释 折叠冗余代码：#region 和 #endregion 四、VS界面各部分讲解 解决方案、项目、类之间的关系 解决方案包含项目，一个解决方案可以有多个项目。 项目包含类，一个项目可以包含多个类。 Properties: 属性 App.config: 配置文件 Program.cs: 类文件 引用命名空间（地址） namespace: 项目名称 Class Program: Program类 Main函数：程序主入口","link":"/2020/01/14/C%20Sharp%E5%85%A5%E5%9D%91%E4%B8%8EVS%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"C#文件管理","text":"目的和作用 通过File类对文件进行操作 通过FileStream类操作文件 通过StreamReader和StreamWriter读写文件 通过FileInfo类访问文件信息 通过DirectoryInfo类文件夹进行操作 目的和作用为了像word、excel等帮软件一样，可以将一些数据保存到计算机中，方便下次使用。在游戏开发中，比如： 商城的配置 关卡的配置 装备的配置 技能的配置 … 无外乎两个操作：读取、保存 通过File类对文件进行操作首先需要知道读取哪一个文件，即要知道文件所在路径。读取到的内容赋值到string类型变量。 File.Exists判断文件是否存在。 File.ReadAllText读取文件中所有的内容。 文本文件如果有中文，需要将编码设置为UTF-8。读取的时候，我们要传递第二个参数Encoding.UTF-8。 File.AppendAllText可以把文本追加到我们的目标对象上。 Environment.NewLine表示回车换行符。 “\\r\\n”表示回车换行符。 File.WriteAllText这个操作是将目标对象中的内容替换掉。 通过File.Create创建文件。创建的时候，如果文件已存在，则覆盖已存在文件。 通过File.Delete删除文件。 例1（文件读取、文件修改）准备文本文件如下： 123456英雄ID 名称 类型 价格 拥有法力 法力值 生命值 攻击力int string int int bool float float floatID Name Type Price HaveMP HP MP Attack1001 双持 2 4500 FALSE 2250 0 2751002 钳工 1 5000 FALSE 2250 0 2121003 毁法 2 6000 TRUE 2750 0 215 用VS 2017创建一个C#控制台应用（.NET Framework）项目，取名Project_File。 编辑Program.cs如下： 1234567891011121314151617181920212223242526272829303132333435using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_File{ class Program { static void Main(string[] args) { //转义符 \\r \\n @\\ string path = @&quot;E:\\Study with me\\TextFile\\Save.txt&quot;; //判断文件是否存在 if (File.Exists(path)) { Console.WriteLine(&quot;找到文件&quot;); //读取文件 string text = File.ReadAllText(path, Encoding.UTF8); Console.WriteLine(text); //写入数据到文件 string writeText = &quot;\\n&quot;+&quot;1004 影刺 2 9500 FALSE 4000 0 200&quot;; //File.WriteAllText(path, writeText);//新文本取代整个旧文本 File.AppendAllText(path, writeText);//在原来的文本末尾添加新文本 } else { Console.WriteLine(&quot;文件不存在&quot;); } } }} 运行程序后，在控制台界面打印原来的文本，打开查看Save.txt发现成功添加了一行新文本 例2（文件创建、文件删除）编辑Program.cs如下： 123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_File{ class Program { static void Main(string[] args) { string path = @&quot;E:\\Study with me\\TextFile\\Save2.txt&quot;; if (File.Exists(path)) { File.Delete(path); Console.WriteLine(&quot;文件Save2.txt已删除&quot;); } else { File.Create(path); Console.WriteLine(&quot;文件Save2.txt已创建&quot;); } } }} 运行程序后，创建文本文件Save2.txt，再次运行，Save2.txt被删除。 通过FileStream类操作文件构建FileStream对象 Encoding.UTF-8.GetBytes可以将一个字符串转换为byte[ ] Encoding.UTF-8.GetString可以将byte[ ]字节数组转换为string 写入stream.Write 读取stream.Read 关闭操作流 stream.Close 无论读取还是写入，最终都是需要byte[ ]操作 Win7系统注意：读取到的文本前边多出一个问号。解决办法： 使用Notepad++打开记事本，然后转化为UTF-8无BOM格式即可。 BOM（Byte Order Mark）是为UTF-16和UTF-32准备的，用于标记字节序（byte order）。微软在UTF-8中使用BOM是因为这样可以把UTF-8和ASCII等编码明确区分开，但这样的文件在Windows系统之外的操作系统里会带来问题。[UTF-8]和[带BOM的UTF-8]的区别是有无BOM，即文件开头有没有U+FEFF。 例子通过VS 2017创建C#控制台应用项目Project_FileStream，编辑Program.cs如下： 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_FileStream{ class Program { static void Main(string[] args) { string path = @&quot;E:\\Study with me\\TextFile\\Save.txt&quot;; FileStream fileStream = new FileStream(path, FileMode.OpenOrCreate); byte[] data = new byte[fileStream.Length]; while (true) { int length = fileStream.Read(data, 0, data.Length); if(length == 0) { Console.WriteLine(&quot;读取完毕&quot;); break; } } Console.WriteLine(Encoding.UTF8.GetString(data)); fileStream.Close(); FileStream writeStream = new FileStream(path, FileMode.Open); string text = &quot;\\n1005 幻刺 2 6000 TRUE 2350 5000 220&quot;; byte[] writeData = Encoding.UTF8.GetBytes(text); //写入到文本里 //要写入的位置进行赋值 //写入的位置决定了我们写入的数据是从哪里开始 writeStream.Position = writeStream.Length; writeStream.Write(writeData, 0, writeData.Length); writeStream.Close(); } }} 程序运行后，在控制台打印Save.txt里的旧信息，关闭控制台后打开Save.txt发现成功添加了新的一行信息。 通过StreamReader和StreamWriter读写文件ReadToEnd读取之后直接返回字符串。 Write/WriteLine也可以直接传递字符串来进行写入。 在构建StreamWriter实例时，如需追加数据需要传递第二个参数，否则覆盖。填true导致追加，默认false导致覆盖。 Close关闭流，释放占用的内存空间。 如果流没有关闭，然后已经写入了数据，那么再次写入，就是从上次的末尾来进行写入，读取从上次读取到的位置继续读取。 例1（StreamReader读文件）通过VS 2017创建控制台应用项目Project_StreamReaderWrite，编辑Program.cs如下： 1234567891011121314151617181920using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_StreamReaderWrite{ class Program { static void Main(string[] args) { string path = @&quot;E:\\Study with me\\TextFile\\Save.txt&quot;; StreamReader streamReader = new StreamReader(path); Console.WriteLine(streamReader.ReadToEnd()); streamReader.Close(); } }} 运行程序结果如下： 例2（StreamWriter写文件）修改Program.cs： 12345678910111213141516171819202122using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_StreamReaderWrite{ class Program { static void Main(string[] args) { string path = @&quot;E:\\Study with me\\TextFile\\Save.txt&quot;; string text = &quot;\\n1006 双手 1 7000 FALSE 3350 0 230&quot;; //追加数据需要传递第二个参数，否则覆盖。true表示追加，默认false表示覆盖。 StreamWriter streamWriter = new StreamWriter(path, true); streamWriter.WriteLine(text); streamWriter.Close(); } }} 运行程序后Save.txt成功添加了一行： 通过FileInfo类访问文件信息封装文件的一些属性： 完整路径 名称 创建日期 最近访问日期 大小（byte） 是否只读 是否存在 创建文件 删除文件 游戏开发中的应用： 验证文件是否合法 比较文件是否与服务器的版本一致（热更新） 例1（通过FileInfo创建和删除文件）用VS 2017新建一个控制台应用项目，取名Project_FileInfo，编辑Program.cs如下： 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_FileInfo{ class Program { static void Main(string[] args) { string path = @&quot;E:\\Study with me\\TextFile\\Save3.txt&quot;; FileInfo fileInfo = new FileInfo(path); if (fileInfo.Exists) { fileInfo.Delete(); } else { fileInfo.Create(); } } }} 运行后，成功在指定目录创建了Save3.txt，再次运行则Save3.txt被删除。 例2（通过FileInfo读取文件的属性）修改Program.cs如下： 12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_FileInfo{ class Program { static void Main(string[] args) { string path = @&quot;E:\\Study with me\\TextFile\\Save.txt&quot;; FileInfo fileInfo = new FileInfo(path); if (fileInfo.Exists) { Console.WriteLine(fileInfo.FullName); Console.WriteLine(fileInfo.CreationTime); Console.WriteLine(fileInfo.LastAccessTime); Console.WriteLine(fileInfo.IsReadOnly); Console.WriteLine(fileInfo.Length); Console.WriteLine(fileInfo.Name); } else { fileInfo.Create(); } } }} 运行后控制台打印了Save.txt的文件属性，如下图： 通过DirectoryInfo类文件夹进行操作 创建文件夹、子文件夹 删除空文件夹 获取文件夹的一些属性 文件夹是否存在 例1（通过DirectoryInfo创建与删除文件夹）通过VS 2017创建一个控制台应用项目Project_DirectoryInfo，编辑Program.cs如下： 1234567891011121314151617181920212223242526272829303132using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_DirectoryInfo{ class Program { static void Main(string[] args) { string path = @&quot;E:\\Study with me\\TextFile\\Skyrim&quot;; DirectoryInfo directoryInfo = new DirectoryInfo(path); if (!directoryInfo.Exists) { Console.WriteLine(&quot;Skyrim件夹不存在&quot;); Console.WriteLine(&quot;Skyrim文件夹创建中...&quot;); directoryInfo.Create(); Console.WriteLine(&quot;Skyrim文件夹已创建&quot;); } else { Console.WriteLine(&quot;Skyrim文件夹已存在&quot;); Console.WriteLine(&quot;Skyrim文件夹删除中...&quot;); directoryInfo.Delete();//文件夹为空文件夹时删除，否则出现异常 Console.WriteLine(&quot;Skyrim文件夹已删除&quot;); } } }} 运行程序后，在指定路径成功创建了Skyrim文件夹，再次运行删除Skyrim文件夹。 例2（通过DirectoryInfo访问文件夹属性）编辑Program.cs如下： 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_DirectoryInfo{ class Program { static void Main(string[] args) { string path = @&quot;E:\\Study with me\\TextFile\\Skyrim&quot;; DirectoryInfo directoryInfo = new DirectoryInfo(path); if (!directoryInfo.Exists) { Console.WriteLine(&quot;文件夹不存在&quot;); Console.WriteLine(&quot;文件夹创建中...&quot;); directoryInfo.Create(); Console.WriteLine(&quot;文件夹已创建&quot;); } else { Console.WriteLine(directoryInfo.FullName); Console.WriteLine(directoryInfo.Name); Console.WriteLine(directoryInfo.CreationTime); Console.WriteLine(directoryInfo.LastAccessTime); //访问所在盘符 Console.WriteLine(directoryInfo.Root); //创建子文件夹Data directoryInfo.CreateSubdirectory(&quot;Data&quot;); } } }} 运行程序后，成功在控制台打印Skyrim文件夹的属性信息，并成功创建了子文件Data。","link":"/2020/04/03/C%20Sharp%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"},{"title":"2.5D回合制游戏Demo实现","text":"Win32窗口的机制 GDI绘图原理：基本原理、三缓冲体系 C/C++变量、数据结构、算法、库函数","link":"/2020/01/27/2D%E5%9B%9E%E5%90%88%E5%88%B6%E6%B8%B8%E6%88%8FDemo%E5%AE%9E%E7%8E%B0/"},{"title":"C#序列化与反序列化","text":"游戏中的各种配置文件存有很多参数，比如商城的配置文件存各种道具的信息，每个道具又有各种属性如名称、说明、原价、活动、优惠价等。 但是我们直接从本地文件读取到的数据十一个很长的字符串，要将这些配置信息给我们的代码使用，还需要创建很多变量，然后逐一赋值，十分麻烦。 另一方面，如果我们要做游戏存档，需要思考要存储的各种变量，在配置文件中应该起什么名称，参数的值如何进行存储。 序列化和反序列化就是用来解决上述麻烦的。 读取数据之后，不用手动去创建变量，然后逐一赋值。 存储数据的时候不用关心倒地要怎么组织存储格式，变量名称要如何定义等 前提：按照“通用的”格式进行序列化和反序列化 XML JSON 实际应用游戏中所有英雄的数据 游戏中所有道具的数据 游戏中所有技能的数据 游戏中所有XXX的数据 以上数据在后期调整修改的变化频率较大，所以会通过配置文件来进行存储。 使用反序列化接口可以使这些数据字典转化为游戏中的一个个变量 游戏存档 适用于单机游戏 使用序列化接口，可以使代码中要存储的数据转化为通用格式的字符串 方便玩家下次登录时程序再取到这些数据，然后进行反序列化操作，拿到上一次存储的重要数据 比如上一个存档中人物的各种属性 比如上一个存档中背包里所有道具的信息 比如上一个存档中任务的进度 按XML格式读取和存储 XML指可拓展标记语言 XML被设计用于结构化存储以及传输信息 XML语法如何描述一个XML文件？ XML是由若干个标签对构成 标签可以有对应内容 标签可以加上属性说明 XML文档必须有根元素 12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;...&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; 所有XML元素都必须有关闭标签 1&lt;p&gt;This is a paragraph&lt;/p&gt; XML标签对大小写敏感 12&lt;Message&gt;这是错误的&lt;/message&gt;&lt;message&gt;这是正确的&lt;/message&gt; XML必须正确嵌套 1234错误例子：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;正确例子：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt; XML的属性值须加引号 12345678910错误例子：&lt;note date=08/08/2008&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt;&lt;/note&gt;正确例子：&lt;note date=&quot;08/08/2008&quot;&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt;&lt;/note&gt; 序列化与反序列化XML序列化：将实体类转化为XML文档 XML反序列化：将XML文档转化为实体类 例子（XML反序列化）通过VS2017创建一个C#控制台应用（.NET Framework）项目，取名Project_XML。 给项目添加两个类，分别取名为SkillConfig、Skill Program.cs内容如下： 12345678910111213141516171819202122232425262728293031323334using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML{ class Program { static void Main(string[] args) { XMLDeserialize(); } public static void XMLDeserialize() { string path = @&quot;E:\\Study with me\\XMLfile\\SkillConfig.xml&quot;; XmlSerializer xmlSerializer = new XmlSerializer(typeof(SkillConfig)); //先读取到文件 FileStream fileStream = new FileStream(path, FileMode.Open); SkillConfig skillConfig = (SkillConfig)xmlSerializer.Deserialize(fileStream); fileStream.Close(); for(int i=0; i &lt; skillConfig.SkillList.Count; i++) { Console.WriteLine(skillConfig.SkillList[i].id + &quot; &quot; + skillConfig.SkillList[i].name + &quot; &quot; + skillConfig.SkillList[i].damage); } } }} SkillConfig.cs内容如下： 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML{ [XmlRootAttribute(&quot;SkillConfig&quot;)] public class SkillConfig { public List&lt;Skill&gt; SkillList = new List&lt;Skill&gt;(); }} Skill.cs内容如下： 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_XML{ public class Skill { public int id; public string name; public int damage; }} SkillConfig.xml内容如下： 12345678910111213141516171819&lt;SkillConfig&gt; &lt;SkillList&gt; &lt;Skill&gt; &lt;id&gt;001&lt;/id&gt; &lt;name&gt;连牙杀&lt;/name&gt; &lt;damage&gt;50000&lt;/damage&gt; &lt;/Skill&gt; &lt;Skill&gt; &lt;id&gt;002&lt;/id&gt; &lt;name&gt;虚空斩&lt;/name&gt; &lt;damage&gt;60000&lt;/damage&gt; &lt;/Skill&gt; &lt;Skill&gt; &lt;id&gt;003&lt;/id&gt; &lt;name&gt;步月流星&lt;/name&gt; &lt;damage&gt;70000&lt;/damage&gt; &lt;/Skill&gt; &lt;/SkillList&gt;&lt;/SkillConfig&gt; 运行结果如下： 例子（XML序列化）Program.cs修改后如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML{ class Program { static void Main(string[] args) { XMLSerialize(); } public static void XMLSerialize() { SkillConfig skillConfig = new SkillConfig(); Skill skillOne = new Skill(); skillOne.id = 101; skillOne.name = &quot;破天&quot;; skillOne.damage = 10000; Skill skillTwo = new Skill(); skillTwo.id = 102; skillTwo.name = &quot;流星&quot;; skillTwo.damage = 20000; Skill skillThree = new Skill(); skillThree.id = 103; skillThree.name = &quot;残月&quot;; skillThree.damage = 30000; skillConfig.SkillList.Add(skillOne); skillConfig.SkillList.Add(skillTwo); skillConfig.SkillList.Add(skillThree); //将以上实体类进行序列化 //第一步：确定XML文档路径 string path = @&quot;E:\\Study with me\\XMLfile\\SkillConfig3.xml&quot;; //第二步：构建用于序列化的对象 XmlSerializer xmlSerializer = new XmlSerializer(typeof(SkillConfig)); //第三步：构建文件流，写入数据 StreamWriter streamWriter = new StreamWriter(path, false, Encoding.UTF8); //可选步骤：自定义命名空间 //不建议自定义命名空间，因为没太大必要 XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces(); namespaces.Add(&quot;&quot;, &quot;&quot;); //第四步：调用序列化对象的序列化的接口 //xmlSerializer.Serialize(streamWriter, skillConfig); xmlSerializer.Serialize(streamWriter, skillConfig, namespaces); streamWriter.Close(); Console.WriteLine(&quot;已经序列化完毕&quot;); } }} 程序运行后生成SkillConfig3.xml文档如下： XML序列化和反序列化例子（带标签属性）Program.cs经修改后： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML{ class Program { static void Main(string[] args) { XMLDeserialize(); //XMLSerialize(); } public static void XMLDeserialize() { //string path = @&quot;E:\\Study with me\\XMLfile\\SkillConfig.xml&quot;; string path = @&quot;E:\\Study with me\\XMLfile\\SkillConfig4.xml&quot;; XmlSerializer xmlSerializer = new XmlSerializer(typeof(SkillConfig)); //先读取到文件 FileStream fileStream = new FileStream(path, FileMode.Open); SkillConfig skillConfig = (SkillConfig)xmlSerializer.Deserialize(fileStream); fileStream.Close(); for(int i=0; i &lt; skillConfig.SkillList.Count; i++) { Console.WriteLine(skillConfig.SkillList[i].id + &quot; &quot; + skillConfig.SkillList[i].name.attackType + &quot; &quot; + skillConfig.SkillList[i].name.content + &quot; &quot; + skillConfig.SkillList[i].damage); } } public static void XMLSerialize() { SkillConfig skillConfig = new SkillConfig(); Skill skillOne = new Skill(); skillOne.id = 101; //skillOne.name = &quot;破天&quot;; skillOne.name = new Name(); skillOne.name.attackType = &quot;近战&quot;; skillOne.name.content = &quot;破天&quot;; skillOne.damage = 10000; Skill skillTwo = new Skill(); skillTwo.id = 102; //skillTwo.name = &quot;流星&quot;; skillTwo.name = new Name(); skillTwo.name.attackType = &quot;近战&quot;; skillTwo.name.content = &quot;流星&quot;; skillTwo.damage = 20000; Skill skillThree = new Skill(); skillThree.id = 103; //skillThree.name = &quot;残月&quot;; skillThree.name = new Name(); skillThree.name.attackType = &quot;近战&quot;; skillThree.name.content = &quot;残月&quot;; skillThree.damage = 30000; skillConfig.SkillList.Add(skillOne); skillConfig.SkillList.Add(skillTwo); skillConfig.SkillList.Add(skillThree); //将以上实体类进行序列化 //第一步：确定XML文档路径 string path = @&quot;E:\\Study with me\\XMLfile\\SkillConfig4.xml&quot;; //第二步：构建用于序列化的对象 XmlSerializer xmlSerializer = new XmlSerializer(typeof(SkillConfig)); //第三步：构建文件流，写入数据 StreamWriter streamWriter = new StreamWriter(path, false, Encoding.UTF8); //可选：命名空间 //不建议自定义命名空间，因为没太大必要 XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces(); namespaces.Add(&quot;&quot;, &quot;&quot;); //第四步：调用序列化对象的序列化的接口 //xmlSerializer.Serialize(streamWriter, skillConfig); xmlSerializer.Serialize(streamWriter, skillConfig, namespaces); streamWriter.Close(); Console.WriteLine(&quot;已经序列化完毕&quot;); } }} Skill.cs经修改后： 123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML{ public class Skill { public int id; //public string name; public Name name; public int damage; } public class Name { //因为要对name进行拓展，加上属性 [XmlAttribute(&quot;attackType&quot;)] public string attackType; [XmlText] public string content; }} 成员标记[XmlRootAttribute]：对根节点的描述，在类声明中使用 [XmlType]：对节点描述，在类声明中使用 [XmlElement]：节点下内部节点描述，如果对数组标识，是对数组单元描述 [XmlAttribute]：节点下内部属性描述 [XmlArrayItem]：数组单元项描述 [XmlArray]：数组描述 [XmlIgnore]：使该项不序列化 [XmlText]：做为节点的text文本输出 按Json的方式进行读取和存储Json是什么？格式： 键值对 数据由逗号分隔 大括号保存对象 键值对中的值可以是一个class 值如果是string，需要加上双引号，如果不是则不需要 如果值是数组，那么需要用中括号括起来 Json的体积相比XML更小，在客户端和服务端的传输的过程中消耗资源更低，传输速度就会更快 怎样使用它序列化：将实体类转化为Json文档 反序列化：将Json文档转化为实体类 如果用于网络传输 string -&gt; 转化byte[ ] 例子（反序列化）准备Skill.json文件如下： 12345{&quot;name&quot;: &quot;破天&quot;,&quot;id&quot;:1001,&quot;damage&quot;:800} 用VS 2017创建一个C#控制台应用（.NET Framework）项目，取名为Project_Json。 给项目添加一个类，取名Skill。 在VS2017的解决方案资源管理器窗口的【引用】右键，选择【添加引用】，在弹出的窗口左边选择【浏览】,点击下方浏览按钮，导入文件LitJson.dll。（LitJson.dll可以在网上搜索下载） 编辑Skill.cs如下： 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Json{ class Skill { public int id; public string name; public int damage; }} 编辑Program.cs如下： 12345678910111213141516171819202122232425262728293031323334353637using LitJson;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Json{ class Program { static void Main(string[] args) { ToObject(); } //反序列化 static void ToObject() { //1.确定读取的Json文档的路径 string path = @&quot;E:\\Study with me\\JsonFile\\Skill.json&quot;; //2.构建读取文件的流 StreamReader streamReader = new StreamReader(path); string text = streamReader.ReadToEnd(); //3.调用反序列化的API Skill skill = JsonMapper.ToObject&lt;Skill&gt;(text); Console.WriteLine(skill.id + &quot; &quot; + skill.name + &quot; &quot; + skill.damage); streamReader.Close(); } }} 运行程序结果如下： 例子（序列化）Program.cs修改后如下： 1234567891011121314151617181920212223242526272829303132333435363738using LitJson;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Json{ class Program { static void Main(string[] args) { ToJson(); } //序列化 static void ToJson() { //1.构建需要进行保存的数据 Skill skill = new Skill(); skill.id = 1001; skill.name = &quot;末日&quot;; skill.damage = 99999; //2.确定保存路径 string path = @&quot;E:\\Study with me\\JsonFile\\Skill2.json&quot;; //3.通过序列化的API获取到需要写入的文本 string text = JsonMapper.ToJson(skill); //4.通过文件流进行写入操作 StreamWriter streamWriter = new StreamWriter(path); streamWriter.Write(text); streamWriter.Close(); Console.WriteLine(&quot;Json文档保存成功&quot;); } }} 程序运行结果： 案例：开发一个角色的背包分三步开发 写一个辅助类JsonHelper： 提供序列化接口和反序列化接口，可以复用。 创建实体类和本地的Json文件 写管理类，提供增删改查功能。（内部维护的一个数据结构，通常为字典） 准备一个MyProp.json如下： 12345678{ &quot;props&quot;:[ {&quot;name&quot;:&quot;滴石&quot;,&quot;id&quot;:1001,&quot;use&quot;:false}, {&quot;name&quot;:&quot;辉滴石&quot;,&quot;id&quot;:1002,&quot;use&quot;:false}, {&quot;name&quot;:&quot;古老的辉滴石&quot;,&quot;id&quot;:1003,&quot;use&quot;:false}, {&quot;name&quot;:&quot;元素瓶&quot;,&quot;id&quot;:1004,&quot;use&quot;:false} ]} 用VS 2017创建个控制台应用项目，取名为Project_Warehouse。 添加引用LitJson.dll。（注意：如果是添加最近的引用，需要勾选后再点击确定） 添加三个类，分别取名为MyProp，MyPropManager，JsonHelper。 MyProp.cs内容如下： 1234567891011121314151617181920212223using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Warehouse{ class MyProp { //我的道具列表 public List&lt;Prop&gt; props = new List&lt;Prop&gt;(); } /// &lt;summary&gt; /// 道具的实体类 /// &lt;/summary&gt; class Prop { public int id;//道具ID public string name;//道具名称 public bool use;//是否使用过 }} MyPropManager.cs内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Warehouse{ class MyPropManager { public Dictionary&lt;int, Prop&gt; props = new Dictionary&lt;int, Prop&gt;(); public MyProp myProp = new MyProp(); string path = @&quot;E:\\Study with me\\JsonFile\\MyProp.json&quot;; public void Init() { myProp = JsonHelper.ToObject&lt;MyProp&gt;(path); //通过ID查找一个物体... for(int i = 0; i &lt; myProp.props.Count; i++) { if (!props.ContainsKey(myProp.props[i].id)) { props.Add(myProp.props[i].id, myProp.props[i]); } } Console.WriteLine(&quot;初始化结束&quot;); } public List&lt;Prop&gt; GetAll() { return myProp.props; } public Prop Get(int id) { if (!props.ContainsKey(id)) { return null; } else { return props[id]; } } public bool Add(Prop prop) { if (!props.ContainsKey(prop.id)) { props.Add(prop.id, prop); myProp.props = props.Values.ToList(); JsonHelper.ToJson&lt;MyProp&gt;(myProp, path); return true; } else { return false; } } public bool Remove(int id) { if (props.ContainsKey(id)) { props.Remove(id); myProp.props = props.Values.ToList(); JsonHelper.ToJson&lt;MyProp&gt;(myProp, path); return true; } else { return false; } } public bool Update(int id, bool use) { if (props.ContainsKey(id)) { props[id].use = use; myProp.props = props.Values.ToList(); JsonHelper.ToJson&lt;MyProp&gt;(myProp, path); return true; } else { return false; } } }} JsonHelper.cs内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142using LitJson;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Warehouse{ class JsonHelper { /// &lt;summary&gt; /// 序列化 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;类型&lt;/typeparam&gt; /// &lt;param name=&quot;o&quot;&gt;要序列化的对象&lt;/param&gt; /// &lt;param name=&quot;path&quot;&gt;路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ToJson&lt;T&gt;(T o, string path) { string text = JsonMapper.ToJson(o); StreamWriter streamWriter = new StreamWriter(path, false, Encoding.UTF8); streamWriter.Write(text); streamWriter.Close(); return text; } /// &lt;summary&gt; /// 反序列化 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;类型&lt;/typeparam&gt; /// &lt;param name=&quot;path&quot;&gt;路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static T ToObject&lt;T&gt;(string path) { StreamReader streamReader = new StreamReader(path); string text = streamReader.ReadToEnd(); streamReader.Close(); T o = JsonMapper.ToObject&lt;T&gt;(text); return o; } }} Program.cs内容： 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Warehouse{ class Program { static void Main(string[] args) { MyPropManager myPropManager = new MyPropManager(); myPropManager.Init();//初始化 //查找所有道具 //List&lt;Prop&gt; props = myPropManager.GetAll(); //for (int i = 0; i &lt; props.Count; i++) //{ // Console.WriteLine(props[i].id + &quot; &quot; // + props[i].name + &quot; &quot; // + props[i].use); //} //查找单个道具 //Prop prop = myPropManager.Get(1001); //Console.WriteLine(&quot;1001: &quot; + prop.name); //添加物品 //Prop prop = new Prop() { id = 1005, name = &quot;飞镖&quot;, use = false }; //myPropManager.Add(prop); //Console.WriteLine(&quot;添加【&quot; + prop.name +&quot;】成功&quot;); //删除物品 //myPropManager.Remove(1005); //更新物品属性 //myPropManager.Update(1002, true); //Console.WriteLine(&quot;更新属性成功&quot;); } }} 总结 所有业务模块基本均有增删查改构成 模块独立化，比如本例中JsonHelper类的出现，能少写很多条调用序列化和反序列化的代码。 所有的功能需求都是数学问题，即数学建模。 构建一个类，包含背包的信息无非是各种字段/属性。 背包的业务：增加物品、删除物品、修改物品、查找物品。 初始化一定要做，否则容易出问题。","link":"/2020/04/01/C%20Sharp%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"CodeBlocks的入门操作","text":"安装好CodeBlocks 16.0.1后打开软件，新建工程：File -&gt; New -&gt; Project… 选择“Console application”，一路“Next”来到如下界面： 手动选择工程的保存路径，注意第二行新建工程的路径和最后一行保存工程文件的路径要保持一致如下图，否则后续编译运行程序时容易报奇怪的错。 设置好以后点击“Next”，编译器设置默认，点击“Finish” 新建项目完成后，可以看到source文件夹下有一个自动建好的带主函数的源文件main.cpp。可以把它删掉后另建：单击选中main.cpp，右键调出菜单选择“R二move file from project” 新建一个.cpp(或.c)文件:File -&gt; New -&gt; File… 选择“C/C++ source”，一路“Next”，选择源文件保存路径（建好的工程文件夹）并添上文件名“test01.cpp”（看见刚才的“main.cpp”记得删掉）。 此时，新建的源文件还没有在工程里，需要手动添加进去。选中工程，右键调出菜单，选择“Add files…”。选择“test01.cpp”,点击“打开”源文件就添加好了。 在“test01.cpp”写好代码,编译无报错后运行即可。","link":"/2019/07/30/CodeBlocks%E7%9A%84%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/"},{"title":"C#脚本基础","text":"一、开发环境IDE：Visual Studio 2017 新建项目途径： ​ 其他语言 &gt; Visual C# &gt; Windows桌面 &gt; 空项目(.NET Framework)或者控制台应用。 二、脚本结构一个C#脚本文件包含以下部分： 命名空间声明（Namespace declaration） 一个类（Class） 类方法 类属性 一个Main方法 语句（Statements）、表达式（Expressions） 注释 在解决方案资源管理器窗口中右键项目名称”CSProject1“，点击“添加“ &gt; ”新建项“，选择“类” &gt; 修改默认类名为”HelloWorld“，点击”添加“按钮。至此，我们创建了一个名叫”HelloWorld“的类，即HelloWorld.cs文件。 在代码编辑器中编写代码如下： 12345678910111213using System;namespace CSProject1{ class HelloWorld { static void Main(string[] args) { /*My first C Sharp Script.*/ Console.WriteLine(&quot;Hello World !&quot;); Console.ReadKey(); } }} 运行后： Hello World ! 解释： using 关键字用于在程序中包含命名空间。 一个程序可以包含多个 using 语句。 下一行是 namespace 声明。一个 namespace 里包含了一系列的类。CSProject1命名空间包含了类 HelloWorld。 下一行是 class 声明。类 HelloWorld 包含程序使用的数据和方法声明。类一般包含多个方法。方法定义了类的行为。在这里，HelloWorld 类只有一个 Main 方法。 下一行定义了 Main 方法，是所有 C# 程序的 入口点。Main 方法说明当执行时，类将做什么动作。 下一行 /*…*/ 将会被编译器忽略，且它会在程序中添加额外的注释。 Main 方法通过语句*Console.WriteLine(“Hello World”); *指定它的行为。 WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法。该语句将消息 “Hello, World!”显示在命令提示符窗口上。 最后一行 Console.ReadKey(); 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。 以下几点值得注意： C# 对英文字母大小写敏感。 所有的语句和表达式必须以分号（;）结尾。 程序的执行从 Main 方法开始。 与 Java 不同的是，文件名可以不同于类的名称。 另一种编译执行C#程序的方式： 打开一个文本编辑器，添加上面提到的代码。 保存文件为 helloworld.cs。 打开命令提示符工具，定位到文件所保存的目录。 键入 csc helloworld.cs 并按下 enter 键来编译代码。 如果代码没有错误，命令提示符会进入下一行，并生成 helloworld.exe 可执行文件。 接下来，键入 helloworld 来执行程序。 若提示无法识别 csc 命令，需配置环境变量（Window10) 找到桌面上的“此电脑”图标，右键单击，并在弹出的菜单中点击 “属性” –”高级系统设置”–”环境变量”–”系统变量”，找到变量 Path， 添加一个路径 C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ 注意：多个路径使用分号(;)隔开，Windows其他版本追加在后面即可。 三、基本语法先上例子： 123456789101112131415161718192021222324252627282930313233343536using System;namespace RectangleApplication{ class Rectangle { double length;// 成员变量 double width;// 成员变量 public void Acceptdetails()//成员函数 { length = 4.5; width = 3.5; } public double GetArea()//成员函数 { return length * width; } public void Display()//成员函数 { Console.WriteLine(&quot;Length: {0}&quot;, length); Console.WriteLine(&quot;Width: {0}&quot;, width); Console.WriteLine(&quot;Area: {0}&quot;, GetArea()); } } class ExecuteRectangle//实例化Retangle类的类，它包含Main方法 { static void Main(string[] args) { Rectangle r = new Rectangle(); r.Acceptdetails(); r.Display(); Console.ReadLine(); } }} 编译并执行后，结果如下： Length: 4.5Width: 3.5Area: 15.75 using关键字：用于在程序中包含命名空间，一个程序可以包含多个using语句。 在任何C#程序中的第一条语句都是：using System; class关键字：用于声明一个类。 注释：用于解释代码，编译器会忽略被注释的条目。单行注释用 // ，多行注释用 /*开始，/*结束。 成员变量：变量的类的属性或数据成员，用于存储数据。 成员函数：在类内声明的函数。函数使一系列执行指定任务的语句。 实例化一个类：上边例子中的类ExecuteRectangle。 标识符：用于来识别类、变量、函数或任何其它用户定义的项目。 在 C# 中，类的命名必须遵循如下基本规则： 标识符必须以字母、下划线或 @ 开头，后面可以跟一系列的字母、数字、下划线、@。 标识符中的第一个字符不能是数字。 标识符必须不包含任何嵌入的空格或符号，比如 ? - +! # % ^ &amp; * ( ) [ ] { } . ; : “ ‘ / \\。 标识符不能是 C# 关键字。除非它们有一个 @ 前缀。 例如，@if 是有效的标识符，但 if 不是，因为 if 是关键字。 标识符必须区分大小写。大写字母和小写字母被认为是不同的字母。 不能与C#的类库名称相同。 C#关键字：C# 编译器预定义的保留字。 这些关键字不能用作标识符，但是，如果您想使用这些关键字作为标识符，可以在关键字前面加上 @ 字符作为前缀。 在 C# 中，有些关键字在代码的上下文中有特殊的意义，如 get 和 set，这些被称为上下文关键字（contextual keywords）。 下表列出了 C# 中的保留关键字（Reserved Keywords）和上下文关键字（Contextual Keywords）： 保留关键字 abstract as base bool break byte case catch char checked class const continue decimal default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in in (generic modifier) int interface internal is lock long namespace new null object operator ou out (generic modifier) override params private protected public readonly ref return sbyte sealed short sizeof stackalloc static string struct switch this throw true try typeof uint ulong unchecked unsafe ushort using virtual void volatile while 上下文关键字 add alias ascending descending dynamic from get global group into join let orderby partial (type) partial (method) remove select set 四、数据类型在 C# 中，变量分为以下几种类型： 值类型（Value types） 引用类型（Reference types） 指针类型（Pointer types） 值类型 值类型变量可以直接分配给一个值。它们是从类 System.ValueType 中派生的。 值类型直接包含数据。比如 int、char、float。 如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用 sizeof 方法。表达式 sizeof(type) 产生以字节为单位存储对象或类型的存储尺寸。 引用类型 引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。 换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。内置的引用类型有：object、dynamic 和 string。 对象（Object）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。 当一个值类型转换为对象类型时，称为 装箱；当一个对象类型转换为值类型时，称为 拆箱。 123456int num1 = 2019;object obj = num1;//整型数据转换为了对象类型（装箱）//拆箱：之前由值类型转换而来的对象类型再转回值类型。int num2 = 2018;object obj = num2;//先装箱,只有装过箱的数据才能拆箱int num3 = （int）obj;//再拆箱 动态（Dynamic）类型变量可以存储任何类型的值。这些变量的类型检查是在运行时发生的。 声明动态类型的语法： 1dynamic &lt;variable_name&gt; = value; 例如： 1dynamic d = 20; 动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。 字符串（String）类型 允许您给变量分配任何字符串值。字符串类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串类型的值可以通过两种形式进行分配：引号和 @引号。 例如： 1String str = &quot;baidu.com&quot;; 一个 @引号字符串： 1@&quot;baidu.com&quot;; C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\\）当作普通字符对待，比如： 1string str = @&quot;C:\\Windows&quot;; 等价于： 1string str = &quot;C:\\\\Windows&quot;; @ 字符串中可以任意换行，换行符以及缩进空格都计算在字符串长度之内。 1234string str = @&quot;&lt;script type=&quot;&quot;text/javascript&quot;&quot;&gt; &lt;!-- --&gt;&lt;/script&gt;&quot;; 用户自定义引用类型有：class、interface 或 delegate。 指针类型 C# 中的指针与 C 或 C++ 中的指针有相同的功能。 声明指针类型的语法例如： 12char* cptr;int* iptr; 五、C#类型转换显式类型转换：即强制类型转换，需要强制转换运算符，会导致数据丢失。 隐式类型转换：C#默认的以安全的方式进行的转换，不会导致数据丢失。 显示类型转换例子： 12345678910111213141516using System;namespace TypeConversionApplication{ class ExplicitConversion { static void Main(string[] args) { double d = 2345.6789; int i; i = (int)d; Console.WriteLine(d); Console.Readkey(); } }} 输出结果： 2345 C# 提供的内置类型转换方法： 方法名 转换类型后的类型 ToBoolean 布尔型 ToByte 字节类型 ToChar 单个 Unicode 字符类型 ToDateTime 把类型（整数或字符串类型）转换为 日期-时间 结构 ToDecimal 把浮点型或整数类型转换为十进制类型 ToDouble 双精度浮点型 ToInt16 16 位整数类型 ToInt32 32 位整数类型 ToInt64 64 位整数类型 ToSbyte 有符号字节类型 ToSingle 小浮点数类型 ToString 字符串类型 ToType 指定类型 ToUInt16 16 位无符号整数类型 ToUInt32 32 位无符号整数类型 ToUInt64 64 位无符号整数类型 不同类型转换为字符串类型的例子： 123456789101112131415161718192021using System;namespace TypeConversionApplication{ class StringConversion { static void Main(string[] args) { int i = 75; float f = 53.005f; double d = 2345.6789; bool b = true; Console.WriteLine(i.ToString()); Console.WriteLine(f.ToString()); Console.WriteLine(d.ToString()); Console.WriteLine(b.ToString()); Console.ReadKey(); } }} 六、C#基本变量类型一个变量只不过是一个供程序操作的存储区的名字，变量类型决定了变量的内存大小和布局。 C# 中提供的基本的值类型大致可以分为以下几类： 类型 举例 整数类型 sbyte、byte、short、ushort、int、uint、long、ulong 和 char 浮点型 float 和 double 十进制类型 decimal 布尔类型 true 或 false 值，指定的值 空类型 可为空值的数据类型 C# 允许定义其他值类型的变量，比如 enum，也允许定义引用类型变量，比如 class。 System 命名空间中的 Console 类提供了一个函数 ReadLine()，用于接收来自用户的输入，并把它存储到一个变量中。 例如： 12int num;num = Convert.ToInt32(Console.ReadLine()); 函数 Convert.ToInt32() 把用户输入的数据转换为 int 数据类型，因为 Console.ReadLine() 只接受字符串格式的数据。 七、C#常量整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，没有前缀则表示十进制。 整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写或者小写，多个后缀以任意顺序进行组合。 这里有一些整数常量的实例： 12345212 /* 合法 */215u /* 合法 */0xFeeL /* 合法 */078 /* 非法：8 不是一个八进制数字 */032UU /* 非法：不能重复后缀 */ 以下是各种类型的整数常量的实例：123456785 /* 十进制 */0213 /* 八进制 */0x4b /* 十六进制 */30 /* int */30u /* 无符号 int */30l /* long */30ul /* 无符号 long */ 浮点常量是由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 这里有一些浮点常量的实例： 123453.14159 /* 合法 */314159E-5L /* 合法 */510E /* 非法：不完全指数 */210f /* 非法：没有小数或指数 */.e55 /* 非法：缺少整数或小数 */ 使用小数形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。有符号的指数是用 e 或 E 表示的。 字符串常量是括在双引号 “” 里，或者是括在 @”” 里。字符串常量包含的字符与字符常量相似，可以是：普通字符、转义序列和通用字符 使用字符串常量时，可以把一个很长的行拆成多个行，可以使用空格分隔各个部分。 这里是一些字符串常量的实例。下面所列的各种形式表示相同的字符串。 123456789101112string a = &quot;hello, world&quot;; // hello, worldstring b = @&quot;hello, world&quot;; // hello, worldstring c = &quot;hello \\t world&quot;; // hello worldstring d = @&quot;hello \\t world&quot;; // hello \\t worldstring e = &quot;Joe said \\&quot;Hello\\&quot; to me&quot;; // Joe said &quot;Hello&quot; to mestring f = @&quot;Joe said &quot;&quot;Hello&quot;&quot; to me&quot;; // Joe said &quot;Hello&quot; to mestring g = &quot;\\\\\\\\server\\\\share\\\\file.txt&quot;; // \\\\server\\share\\file.txtstring h = @&quot;\\\\server\\share\\file.txt&quot;; // \\\\server\\share\\file.txtstring i = &quot;one\\r\\ntwo\\r\\nthree&quot;;string j = @&quot;onetwothree&quot;; 常量是使用 const 关键字来定义的 。定义一个常量的语法如下： 1const &lt;data_type&gt; &lt;constant_name&gt; = value; 下面的代码演示了如何在程序中定义和使用常量： 12345678910111213141516171819202122using System;public class ConstTest { class SampleClass { public int x;//属性变量 public int y;//属性变量 public const int c1 = 5;//属性常量 public const int c2 = c1 + 5;//属性常量 public SampleClass(int p1,int p2)//构造方法 { x = p1; y = p2; } } static void Main() { SampleClass mC = new SampleClass(11, 22); Console.WriteLine(&quot;x = {0}, y = {1}&quot;, mC.x, mC.y); Console.WriteLine(&quot;c1 = {0}, c2 = {1}&quot;, SampleClass.c1, SampleClass.c2); }}输出结果： x = 11, y = 22c1 = 5, c2 = 10 八、运算符 算术运算符：+、-、*、/、%、++、– 关系运算符：==、!=、&gt;、&lt;、&gt;=、&lt;= 逻辑运算符：&amp;&amp;、||、! 位运算符：&amp;、|、^(异或)、~(非) 赋值运算符：=、+=、-=、*=、/=、%=、&lt;&lt;=(左移且赋值)、&gt;&gt;=、&amp;=、^=、|= 其他一些重要的运算符。 运算符 描述 实例 sizeof() 返回数据类型的大小。 sizeof(int)，将返回 4. typeof() 返回 class 的类型。 typeof(StreamReader); &amp; 返回变量的地址。 &amp;a; 将得到变量的实际地址。 * 变量的指针。 *a; 将指向一个变量。 ? : 条件表达式 如果条件为真 ? 则为 X : 否则为 Y is 判断对象是否为某一类型。 If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。 as 强制转换，即使转换失败也不会抛出异常。 Object obj = new StringReader(“Hello”); StringReader r = obj as StringReader; 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 从右到左 逗号 , 从左到右 九、C# 判断、循环判断语句 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： 1Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。 ? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。 循环类型 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for或foreach 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 foreach循环例子： 12345678910111213141516171819202122232425262728293031using System;namespace ForeachTestApplication{ public class ForeachTest { static void Main(String[] args) { int[] array = new int[]{2080, 2070, 2060, 1660, 1650}; foreach ( int element in array) { Console.WriteLine(element); } Console.WriteLine(); //原理类似foreach的for循环 for(int i=0;i &lt; array.Length; i++) { Console.WriteLine(array[i]); } Console.WriteLine(); //加入计数器 int count = 0; foreach (int item in array) { count++; Console.WriteLine(count+&quot; : &quot;+item); } Console.WriteLine(&quot;The length of this array is &quot;+count); } }} 程序输出结果： 20802070206016601650 20802070206016601650 1 : 20802 : 20703 : 20604 : 16605 : 1650The length of this array is 5 十、封装封装 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。 抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。 C# 封装根据具体的需要，设置使用者的访问权限，并通过 访问修饰符 来实现。 一个 访问修饰符 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示： public：所有对象都可以访问； private：对象本身在对象内部可以访问； protected：只有该类对象及其子类对象可以访问 internal：同一个程序集的对象可以访问； protected internal：访问限于当前程序集或派生自包含类的类型。 十一、C#方法当定义一个方法时，从根本上说是在声明它的结构的元素。在 C# 中，定义方法的语法如下： 1234&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List){ Method Body} 下面是方法的各个元素： Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。 Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 void。 Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。 Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。 Method body：方法主体，包含了完成任务所需的指令集。 按引用传递参数 引用参数是一个对变量的内存位置的引用。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。 在 C# 中，使用 ref 关键字声明引用参数。下面的实例演示了这点： 1234567891011121314151617181920212223242526272829303132333435using System;namespace CalculatorApplication{ class NumberManipulator { public void swap(ref int x, ref int y) { int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 temp 赋值给 y */ } static void Main(string[] args) { NumberManipulator n = new NumberManipulator(); /* 局部变量定义 */ int a = 100; int b = 200; Console.WriteLine(&quot;在交换之前，a 的值： {0}&quot;, a); Console.WriteLine(&quot;在交换之前，b 的值： {0}&quot;, b); /* 调用函数来交换值 */ n.swap(ref a, ref b); Console.WriteLine(&quot;在交换之后，a 的值： {0}&quot;, a); Console.WriteLine(&quot;在交换之后，b 的值： {0}&quot;, b); Console.ReadLine(); } }} 当上面的代码被编译和执行时，它会产生下列结果： 在交换之前，a 的值：100在交换之前，b 的值：200在交换之后，a 的值：200在交换之后，b 的值：100 按输出传递参数 return 语句可用于只从函数中返回一个值。但是，可以使用 输出参数 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。 下面的实例演示了这点： 1234567891011121314151617181920212223242526272829using System;namespace CalculatorApplication{ class NumberManipulator { public void getValue(out int x ) { int temp = 5; x = temp; } static void Main(string[] args) { NumberManipulator n = new NumberManipulator(); /* 局部变量定义 */ int a = 100; Console.WriteLine(&quot;在方法调用之前，a 的值： {0}&quot;, a); /* 调用函数来获取值 */ n.getValue(out a); Console.WriteLine(&quot;在方法调用之后，a 的值： {0}&quot;, a); Console.ReadLine(); } }} 当上面的代码被编译和执行时，它会产生下列结果： 在方法调用之前，a 的值： 100在方法调用之后，a 的值： 5 提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点： 1234567891011121314151617181920212223242526272829using System;namespace CalculatorApplication{ class NumberManipulator { public void getValues(out int x, out int y ) { Console.WriteLine(&quot;请输入第一个值： &quot;); x = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(&quot;请输入第二个值： &quot;); y = Convert.ToInt32(Console.ReadLine()); } static void Main(string[] args) { NumberManipulator n = new NumberManipulator(); /* 局部变量定义 */ int a , b; /* 调用函数来获取值 */ n.getValues(out a, out b); Console.WriteLine(&quot;在方法调用之后，a 的值： {0}&quot;, a); Console.WriteLine(&quot;在方法调用之后，b 的值： {0}&quot;, b); Console.ReadLine(); } }} 当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）： 请输入第一个值：7请输入第二个值：8在方法调用之后，a 的值： 7在方法调用之后，b 的值： 8","link":"/2020/01/17/C%20Sharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"},{"title":"Hexo搭建个人博客注意事项记录","text":"如何插入图片？安装hexo-asset-image插件 1npm install hexo-asset-image --save 确保Hexo博客总目录下的_config.yml中的post_asset_folder的值为true（默认是false）。 然后在要插入图片的文章的目录下新建一个同名文件夹，并在其中放入要插入的图片，例子： MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 直接用语句![logo](logo.jpg)插入图片logo.jpg。 —2020-01-10 更新— 邮件链接格式1mailto:xxx@xxx.com —2020-01-14 更新— .md文件名如果包含特殊字符，需要转义例如，文件名“C#入坑与VS的使用.md”需要改成“C%23入坑与VS的使用.md”。否则点击文章标题进入页面时，发送一个get请求，参数包含“#”，结果无法成功进入文章页面。 原理：将特殊的字符转换成ASCII码，格式为：%加字符的ASCII码，即一个百分号%，后面跟对应字符的ASCII（16进制）码值。例如 空格的编码值是”%20”。 URL特殊符号及对应的十六进制值编码： 12345678+ URL中+号表示空格 %2B 空格 URL中的空格可以用+号或者编码 %20 / 分隔目录和子目录 %2F ? 分隔实际的 URL 和参数 %3F % 指定特殊字符 %25 # 表示书签 %23 &amp; URL中指定的参数间的分隔符 %26 = URL中指定参数的值 %3D参考链接：https://segmentfault.com/a/1190000010854567 尽管这样做可以解决跳转的问题，但文章中的所有图片依旧无法显示，因此给md文件和存图片的文件夹取名应尽力避免夹带特殊符号。 tags包含特殊字符“#”需要转义例如，以“C#”为一个标签名，则应写成1tags: C&amp;#35; 原理：对特殊符号进行转义，用对应的HTML字符实体进行替换 各种常用特殊字符对应的HTML字符实体： 123456789101112131415161718192021222324! &amp;#33; — 惊叹号 Exclamation mark&quot; &amp;#34; &quot; — 双引号 Quotation mark# &amp;#35; — 数字标志 Number sign$ &amp;#36; — 美元标志 Dollar sign% &amp;#37; — 百分号 Percent sign&amp; &amp;#38; &amp; — 与符号(&amp;) Ampersand&apos; &apos; — 单引号 Apostrophe( &amp;#40; — 小括号左边部分 Left parenthesis) &amp;#41; — 小括号右边部分 Right parenthesis* &amp;#42; — 星号 Asterisk+ &amp;#43; — 加号 Plus sign&lt; &amp;#60; &lt; 小于号 Less than= &amp;#61; — 等于符号 Equals sign- &amp;#45; &amp;minus; — 减号&gt; &amp;#62; &gt; — 大于号 Greater than? &amp;#63; — 问号 Question mark@ &amp;#64; — Commercial at[ &amp;#91; — 中括号左边部分 Left square bracket\\ &amp;#92; — 反斜杠 Reverse solidus (backslash)] &amp;#93; — 中括号右边部分 Right square bracket{ &amp;#123; — 大括号左边部分 Left curly brace| &amp;#124; — 竖线Vertical bar} &amp;#125; — 大括号右边部分 Right curly brace空格 &amp;nbsp; 参考链接：https://segmentfault.com/a/1190000020528571?utm_source=tag-newest","link":"/2019/03/20/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E8%AE%B0%E5%BD%95/"},{"title":"Lua入门","text":"一、环境搭建Windows上安装IDE：SciTE 下载地址：https://github.com/rjpcomputing/luaforwindows/releases 选好安装路径，一路Next，完成安装后即可在该环境下编写 Lua 程序并运行。 在哪运行？ 快捷键Ctrl+D，复制光标所在行并插入到光标的下一行。 二、交互式编程、脚本编程、注释写法 交互式编程方式 打开cmd控制命令窗口，使用命令： Lua -i 脚本式编程方式 将Lua代码保存成.lua文件然后运行。 123#!/usr/local/bin/lua print(&quot;Hello world!&quot;); 上边第一行表示指定解释器，解释器执行时会忽略井号开头的第一行。 注释格式 123456-- 单行注释--[[多行注释多行注释多行注释--]] 三、标识符、关键字 标识符组成 字母、数字、下划线； 必须以字母/下划线开头； 区分大小写； 关键字 保留关键字不能用作变量名或自定义标识符：and, break, do, else, elseif, end, false, for, function, if, in , local, nil, not, or, repeat, return, then, true, until, while 一般约定，用下划线开头连接一串大写字母的名字比如：_VERSION，被保留用于Lua内部全局变量。 四、全局变量 全局变量： 默认情况下，变量总被认为是全局的，全局变量不需要声明，给一个变量赋值即可创建该全局变量。 写在函数外部 作用范围从定义的那一行开始到文件末尾 1234b = 10;print(b);b = nil; -- 要删除一个变量，就给它赋值为nilprint(b); -- 当且仅当一个变量的值不为nil时，这个变量即存在 10nil 局部变量： 用关键字“local”定义 写在函数内，if语句内 作用范围从定义的那一行开始到函数结束或return 五、数据类型Lua的8种数据类型： nil(无效值), boolean, number(双精度实浮点数), string, userdata(任意存储在变量中的C数据结构), function, thread(独立线程), table(表，关联数组，通过构造表达式产生) 1234567print(type(&quot;Hello World!&quot;)); -- 建议用双引号讲字符串括起来，用单引号括单个字符print(type(10.4 * 3));print(type(print));print(type(type));print(type(true));print(type(nil));print(type(type(X))); -- type()返回结果是字符串 stringnumberfunctionfunctionbooleannilstring 1tab1 = {key1 = &quot;val1&quot;, key2 = &quot;val2&quot;,&quot;val3&quot;} for k,v in pairs(tab1) do print(k..” - “.. v) – “..”表示连接endprint(“——“)tab1.key1 = nil; – 可以用nil删除键值对for k,v in pairs(tab1) do print(k.. “ - “.. v)end 12345678910 &gt;1 - val3 &gt; key1 - val1 &gt; key2 - val2 &gt; &gt; 1 - val3 &gt; key2 - val2 ```luaprint(type(X) == nil);print(type(X) == &quot;nil&quot;); falsetrue","link":"/2020/01/23/Lua%E5%85%A5%E9%97%A8/"},{"title":"C#多线程与异步操作","text":"多线程处理的作用： 实现多任务； 解决延迟。 多线程应用： 计算量大的场景、计算时长久的业务，比如LOL中的战争迷雾，它需要算很多可视化和迷雾单位，需要独立的线程进行计算。 在LOL中，每个正在战斗的房间，底层也是要求相互独立，可并行的，所以也需要多线程的支持。 每次打开王者荣耀，要更新很多内容，如果不使用多线程下载更新，速度会更慢。 其他 有关线程的对象：Thread（.net 4.0）、Task （.net 4.0之后） 线程同步（保证数据的可靠性） 创建线程 构建Thread实例，参数需要指定一个方法 通过Start方法开始执行线程 如果需要给方法传递参数，则使用匿名函数( ) =&gt; { } 如果有返回值怎么办？定义变量进行接收 暂停线程 通过Thread实例调用Join，可以阻止其他线程的调用，直到由该实例表示的线程终止 线程实例.Join(); 可以传递一个参数，表示最长阻塞多长时间的（单位：毫秒） 计时等待 Thread.Sleep()让线程休眠一段时间 通过静态方法可以让当前的线程等待一定的时间，由参数决定等待的时间（单位：毫秒） 它只影响当前执行的线程，其他线程依旧会执行 终止线程 Thread.Abort(); 该方法终止方式是对线程进行销毁，它适用于当线程要关闭的时候进行调度，能够保证线程程序关闭，线程也被销毁 其他地方尽可能不要用，有其他方式，比如用在线程内部用了lock语句，那么强制关闭线程回导致lock失效从而可能影响计算结果 通过信号控制线程的暂停执行和继续执行 ManualResetEvent 检测线程状态 thread.ThreadState 前台线程和后台线程 后台线程程序停止后可能还会继续执行 前台线程程序停止都会停止掉左右前台线程，线程默认都是前台线程 访问当前线程 Thread.CurrentThread.ManagedThreadId 例1本例包含：线程的创建、启动、阻塞（等待）、休眠、终止 IDE：VS 2017 创建项目类型：控制台应用(.NET Framework) 项目名：Project_Thread Program.cs代码如下： 12345678910111213141516171819using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Thread{ class Program { static void Main(string[] args) { ThreadDemo threadDemo = new ThreadDemo();//实例化ThreadDemo threadDemo.Start();//启动三个任务：Thread01,Thread02,Thread03 } }} 在项目中新建一个类，取名为ThreadDemo ThreadDemo.cs代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace Project_Thread{ class ThreadDemo { public void Start() { //多个线程，可以同时执行不同的任务，减少 //通过线程调用方法 Thread t1 = new Thread(Thread01); t1.Start(); Thread t2 = new Thread(Thread02); t2.Start(); Thread t3 = new Thread(Thread03); t3.Start(); int count = 0;//局部变量 Thread t4 = new Thread(()=&gt; { count=Thread04(500); });//用匿名方法传递参数 t4.Start(); //等待线程执行完毕 t4.Join(); /*************以下代码块是有关进程的终止**********/ Console.WriteLine(t4.ThreadState);//访问进程t4的当前状态 try { t4.Abort();//终止线程，通过抛异常的形式销毁线程 Console.WriteLine(t4.ThreadState);//访问进程t4的当前状态 } catch (Exception e)//捕获异常 { Console.WriteLine(e);//打印异常信息 } /********************************************/ Console.WriteLine(&quot;count是多少：&quot; + count); } public void Thread01() { for(int i=0; i&lt;100; i++) { //Thread.Sleep(1000); //当前进程休眠1000ms（1s） Console.WriteLine(&quot;Thread01: &quot; + i); } } public void Thread02() { for (int i = 0; i &lt; 100; i++) { Console.WriteLine(&quot;Thread02: &quot; + i); } } public void Thread03() { for (int i = 0; i &lt; 100; i++) { Console.WriteLine(&quot;Thread03: &quot; + i); } } public int Thread04(int count) { int _count = 0; for (int i = 0; i &lt; count; i++) { _count++; Console.WriteLine(&quot;Thread04: &quot; + i); } return _count; } }} 例2本例包含暂停执行、继续执行 给项目新建一个类，取名为ManualResetEventDemo ManualResetEventDemo.cs内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace Project_Thread{ //通过信号的形式控制线程的暂停与继续 class ManualResetEventDemo { //停止信号 ManualResetEvent mr = new ManualResetEvent(true); public ManualResetEventDemo() { Thread t = new Thread(Thread01); t.IsBackground = false;//false前台线程， true后台线程 //基本不会用到这个属性 软件开发可能用到比较多 //前台线程会在应用程序关闭的时候全部停止掉，后台线程在程序执行完之前不会停止。 t.Start(); Start(); } public void Start() { //发送一个让线程继续执行的信号 mr.Set();//继续 } public void Stop() { mr.Reset(); } public void Thread01() { Thread.Sleep(3000); int i = 0; while (true) { mr.WaitOne(); //线程ID是系统自动分配的；每次都是不同的ID, 每个线程的ID唯一。 Console.WriteLine(&quot;线程的ID: &quot; + Thread.CurrentThread.ManagedThreadId); i++; Console.WriteLine(&quot;i的值：&quot; + i); Thread.Sleep(3000); } } }} 修改Program.cs如下： 12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Thread{ class Program { static void Main(string[] args) { //ThreadDemo threadDemo = new ThreadDemo();//实例化ThreadDemo //threadDemo.Start();//启动三个任务：Thread01,Thread02,Thread03 ManualResetEventDemo mre = new ManualResetEventDemo(); Console.WriteLine(&quot;输入 start:继续执行线程 stop:停止线程&quot;); while (true) { string s = Console.ReadLine(); if(s == &quot;start&quot;) { mre.Start(); } else if(s == &quot;stop&quot;) { mre.Stop(); } } } }}","link":"/2020/03/31/C%20Sharp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"},{"title":"Lua数据类型","text":"一、布尔类型Lua把false和nil看作是假，其他都看作是真 123print(type(true));print(type(false));print(type(nil)); booleanbooleannil 12345if false or nil then print(&quot;至少有一个是true&quot;);else print(&quot;false nil都为false&quot;);end false nil都为false 二、数字类型（number）1234567print(type(2));print(type(2.2));print(type(0.2));print(type(2e+1));print(2e+1);print(type(0.2e-1));print(type(1.25489e-6)); numbernumbernumbernumber20numbernumber 三、字符串（String）12345678910111213str1 = &quot;Hi,I&apos;m MJ.&quot;;str2 = &quot;Hello, MJ.Nice to meet you.&quot;;print(str1..&quot;\\n&quot;..str2)-- 一块字符串html = [[ &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;a href = &quot;www.baidu.com&quot;&gt;百度搜索&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;]]print(html); Hi,I’m MJ.Hello, MJ.Nice to meet you. &lt;head&gt;&lt;/head&gt;​ ​ 百度搜索​ ​ 在进行数字相加时，lua会自动把字符串转成数字 12345678print(&apos;2&apos; + 3);print(&apos;2&apos; + &apos;3&apos;);print(&apos;n&apos;..&apos;b&apos;); -- 字符串连接print(123 .. 456); -- 数字连接，数字与点号间要有空格website = &quot;www.baidu.com&quot;print(#website); -- 输出字符串长度print(#&quot;www.baidu.com&quot;) 55nb1234561313 四、表（table）1234567891011121314151617181920212223242526272829local tb1 = {}; -- 创建一个空表local tb2 = {&quot;Java&quot;,&quot;Python&quot;,&quot;Lua&quot;,&quot;C++&quot;}; -- 直接初始化表-- 关联数组a = {};a[&quot;key&quot;] = &quot;value&quot;;key = 10;a[key] = 22;a[key] = a[key] + 11;for k,v in pairs(a) do print(k.. &quot; : &quot; ..v);endlocal tb1 = {&quot;Java&quot;,&quot;Python&quot;,&quot;Lua&quot;,&quot;C++&quot;};for key, val in pairs(tb1) do print(&quot;key&quot;, key);enda3 = {};for i = 1, 10 do a3[i] = i;enda3[&quot;key&quot;] = &quot;val&quot;;print(a3[&quot;key&quot;]);print(a3[&quot;none&quot;]); key : value10 : 33key 1key 2key 3key 4valnil 五、函数1234567891011function factorial1(n) if n == 0 then return 1; else return n * factorial1(n-1); endendprint(factorial1(5));factorial2 = factorial1;print(factorial2(5)); 120120 123456789101112function testFun(tab, fun) for k, v in pairs(tab) do print(fun(k, v)) endendtab = {key1 = &quot;val1&quot;, key2 = &quot;val2&quot;};-- function可以以匿名函数的方式通过参数传递testFun(tab,function (key, val) -- 匿名函数 return key .. &quot; = &quot; .. val;end); key1 = val1key2 = val2 六、线程（Thread）七、自定义类型（Userdata）","link":"/2020/01/25/Lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Lua变量、赋值语句、索引、循环、流程控制","text":"一、变量 全局变量 局部变量 表中的域 1234567891011121314151617181920a = 5; -- 全局变量local b = 5; -- 局部变量function joke() c = 5; -- 全局变量 local d = 6; --局部变量endprint(&quot;a\\t&quot;..&quot;b\\t&quot;..&quot;c\\t&quot;..&quot;d&quot;)print(a, b, c, d);joke();print(a, b, c, d);do local a = 6; -- 局部变量 b = 6; -- 对局部变量重新赋值 print(a, b);endprint(a, b); a b c d5 5 nil nil5 5 5 nil6 65 6 二、赋值语句123456789a, b, c = 0, 1;print(&quot;a\\t&quot;..&quot;b\\t&quot;..&quot;c&quot;)print(a, b, c);a, b = a+1,b+1,b+2; -- 没有被赋值的变量会被忽略print(a, b, c);a, b, c = 0; -- 同时为多个变量赋相同的值print(a, b, c); a b c0 1 nil1 2 nil0 nil nil 三、索引t[i]或t.i，t.i是当索引为字符串类型时的一种简化写法。 gettable_event(t, i)采用索引访问本质上时一个类似这样的函数调用。 1234site = {};site[&quot;key&quot;] = &quot;www.baidu.com&quot;;print(site[&quot;key&quot;]); -- 建议写法print(site.key); -- 不建议写法 www.baidu.comwww.baidu.com 四、循环循环体：while, for, repeat…until 循环控制语句：break 五、流程控制if语句：if … then … else … end if嵌套","link":"/2020/01/26/Lua%E5%8F%98%E9%87%8F/"},{"title":"PluralSight课程：游戏机制设计基础","text":"","link":"/2020/02/24/PluralSight%E8%AF%BE%E7%A8%8B%EF%BC%9A%E6%B8%B8%E6%88%8F%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"},{"title":"Lua函数","text":"一、求最大值与函数作为参数传递1234567891011121314151617181920212223function max(num1, num2) if (num1 &gt; num2) then result = num1; else result = num2; end return result;endprint(&quot;两值比较最大值为&quot;,max(10,4));print(&quot;两值比较最大值为&quot;,max(5,6));myprint = function(param) print(&quot;这是一个打印函数-##&quot;, param,&quot;##&quot;)endfunction add(num1, num2, functionPrint) result = num1 + num2; functionPrint(result);endmyprint(10);add(2, 5, myprint); 两值比较最大值为 10两值比较最大值为 6这是一个打印函数-## 10 ##这是一个打印函数-## 7 ## 二、多返回值","link":"/2020/01/26/Lua%E5%87%BD%E6%95%B0/"},{"title":"Markdown小技巧（一）","text":"我在使用作业部落出品CmdMarkdown编辑器编写.md文件时遇到的问题： 我希望连续出现两个引用块，而两个引用块中间隔着一个空行，两个引用快还是连在一起的。查阅网上的帖子后发现解决方法： 两个引用块之间需要间隔两个空行，其中第二个空行行首必须打出一个全角空格。 例子：1234&gt; ＂I used to be an adventurer like you, then I took an arrow in the knee.＂（全角空格）&gt; ＂Never should you come here.＂ 效果： I used to be an adventurer like you, then I took an arrow in the knee. Never should you come here.","link":"/2019/02/13/Markdown%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Markdown小技巧（一）","text":"在Cmd Markdown编辑器中把一个引用块分成俩 我在使用作业部落出品CmdMarkdown编辑器编写.md文件时遇到的问题： 我希望连续出现两个引用块，而两个引用块中间隔着一个空行，两个引用快还是连在一起的。查阅网上的帖子后发现解决方法： 两个引用块之间需要间隔两个空行，其中第二个空行行首必须打出一个全角空格。 例子：1234&gt; ＂I used to be an adventurer like you, then I took an arrow in the knee.＂（全角空格）&gt; ＂Never should you come here.＂ 效果： I used to be an adventurer like you, then I took an arrow in the knee. Never should you come here.","link":"/2019/02/13/Markdown%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"PluralSight谈游戏设计基础","text":"1. From Idea to Game Visionwriting an idea down, extends the ideas lifespan. Vision — A vivid, imaginative concept to drive your direction. 2. Communicating Your IdeaCommunicating your game’s vision with confidence is key.","link":"/2020/02/16/PluralSight%E8%AF%BE%E7%A8%8B%EF%BC%9A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"},{"title":"PluralSight课程：游戏设计基础","text":"1. From Idea to Game Visionwriting an idea down, extends the ideas lifespan. Vision — A vivid, imaginative concept to drive your direction. 2. Communicating Your IdeaCommunicating your game’s vision with confidence is key. 3. Going to the Game PremiseYour game premise should be one Action-Packed sentence describing the user’s experience. for example, Swords and Shovels is a light-hearted, action-packed, 2D, top-down dungeon crawler. Alone dwarf and his trusty warthog explore an abandoned mine to seek our glory, riches and loot while avoiding the nightmarish creatures below. 4. Evolving Your Idea5. Thinking About the Game Core MechanicsThings to avoid Generalizations Words without meaning 6. Summary Ideas are small Turn your idea into an action-packed premise Get feedback from the RIGHT people Identify Core Mechanics 7. Managing the Scope of the Project8. Defining SMART Goals for Your Game9. Creating a Schedule for Your Game Project10. Creating Achievable Time Estimates11. Think of the Gameplay12. Creating the Pitch","link":"/2020/02/16/PluralSight%E8%B0%88%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"},{"title":"Python 3的byte和string","text":"Python 3最大的新特性是对文本和二进制数据作了更为清晰的区分。文本总是Unicode,由string类型表示，二进制数据则由byte类型表示。Python 3不会以任意隐式方式混用string和byte。 字符串可以通过编码(encode)转成一串字节，一串字节通过解码(decode)转成字符串 例子： 123456789msg=&quot;华南理工大学&quot;encodeResult = msg.encode(encoding=&apos;utf-8&apos;)#python 3.x 默认编码器按utf-8编码decodeResult = encodeResult.decode(encoding=&quot;utf-8&quot;)print(&quot;msg:&quot;,msg)print(&quot;encode:&quot;,encodeResult)print(&quot;type of encodeResult: &quot;,type(encodeResult))print(&quot;decode:&quot;,decodeResult)print(&quot;type of decodeResult: &quot;,type(decodeResult)) 运行后： msg: 华南理工大学encode: b’\\xe5\\x8d\\x8e\\xe5\\x8d\\x97\\xe7\\x90\\x86\\xe5\\xb7\\xa5\\xe5\\xa4\\xa7\\xe5\\xad\\xa6’type of encodeResult: &lt;class ‘bytes’&gt;decode: 华南理工大学type of decodeResult: &lt;class ‘str’&gt;","link":"/2019/03/20/Python-3%E7%9A%84byte%E5%92%8Cstring/"},{"title":"Python编写规范","text":"Python中变量的定义规则、定义规范以及其他注意事项。 一、变量定义规则： 变量名只能是字母、下划线、数字的任意组合； 变量名的第一个字符不能是数字； 变量名不能和关键字重名。 规范： 起变量名要见名知意； 驼峰形式命名； 变量名字母要小写，常量名子母要大写。 在shell中赋值变量，语句中不能加空格，如： 12name=&quot;Mingjun Wei&quot;（√）name = &quot;Mingjun Wei&quot;（×） 二、不是同级的语句要顶格写错误示范： 1234567891011121314_usrname = &apos;Mingjun Wei&apos;_pwd = 123456usrname = input(&quot;name:&quot;)pwd = int(input(&quot;password:&quot;))if _usrname == usrname and _pwd == pwd: print(&quot;Welcome {usrname} login ...&quot;.format(usrname=_usrname))else: print(&quot;invalid username or password!&quot;) print(&quot;sssss&quot;)#此句前边要么和if语句同级顶格，要么#和print(&quot;invalid username or password!&quot;)同级缩进(4个空格),#前边不能留一个空格，否则会报错。 编写前一定要画流程图。","link":"/2019/03/19/Python%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/"},{"title":"Python头部“#!/usr/bin/env python” 和“#!/usr/bin/python”的区别","text":"大部分Python文件的第一行写着#!/usr/bin/env python或者#!/usr/bin/python，这两条语句和运行模式有关。 如果我们用普通运行模式例如（在Linux下执行命令）：1python *.py 那么这两条头部语句没什么卵用。但如果打算让Python程序像普通程序一样运行，例如执行命令（注：文件要有可执行权限chmod a+x *.py）：1./*.py 这两条头部语句就起作用了，它们用来为脚本语言指定解释器，通常认为用#!/usr/bin/env python要比#!/usr/bin/python更好，因为Python解释器有时并不安装在默认路径，比如安装在虚拟环境中。 两条语句逐一解释如下：1#!/usr/bin/env python当机器上安装了多个版本的Python时这种写法才有意义。程序运行时机器会先去取环境变量的PATH中指定的第一个Python来执行您的脚本。如果您配置了虚拟环境，这条头部语句可以保证脚本由您的虚拟环境python中的Python来执行。 1#!/usr/bin/python表示写死了就是要用目录/usr/bin/python下的Python来执行您的脚本。这样写程序的可移植性比较差，如果此路径下的Python不存在就会报错。 因此一般情况下采用第一种写法。","link":"/2019/03/19/Python%E5%A4%B4%E9%83%A8-usr-bin-python-%E5%92%8C-usr-bin-env-%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"UE4蓝图 第1课","text":"主讲人：神经刀游戏工作室https://www.bilibili.com/video/av33932971 创建项目（蓝图、第三人称模板） 下方【内容浏览器】右键新建 “Player”文件夹（存放角色） “Map”文件夹（存放关卡） “Gameplay”文件夹（存放玩法） Map文件夹下右键新建一个【关卡】 左边【模式】下，从【光照】拖拽出： 一个【定向光源】 一个【天空光源】 从【视觉效果】拖拽出一个【大气雾】 从【基本】拖拽出一个【立方体】 右边【细节】里把立方体的位置归零（点击“回车符号按钮”） 键盘上按【W】切换到调整位置坐标系 按【E】切换到调整旋转角度坐标系 【R】切换到调整大小坐标系 把立方体调成一个供角色落脚的平台 从左边【基本】里拖拽出一个【玩家起始】 “GamePlay”文件夹下右键新建一个【蓝图类】，选择【Game Mode Base】 Player文件夹下右键新建： 一个【蓝图类】的【Character】，取名“APlayer”， 一个【蓝图类】的【Player Controller】，取名“APlayerController” 双击进入“APlayer”， 选中左边【组件】里的【Mesh】， 右边【细节】中【Mesh】下Skeletal Mesh选择”SK_Mannequin”, 【细节】中【变换】下的【旋转Z轴】改成“-90°“，【位置Z轴】改成”-92” 选中左边【组件】里的【CapsuleCoponent】，点击上方【添加组件】按钮，选择【SwingArm】 在新添加的SwingArm组件下新建一个【Camera】 把SwingArm垂直调节到与角色肩差不多同高度的位置 编译，保存 点击工具栏的【编辑】，进入【项目设置】，进到左边【引擎】下的【输入】 在”Axis Mapping“下自定义添加一个“Moveforward”, 添加一个按键，选择【键盘W】，”Scale“设置为“1.0” 添加一个按键，选择【键盘S】，“Scale”设置为“-1.0” 进入“APlayerController”，在【事件图表】下，右键添加一个操作【坐标轴事件】“Moveforward” 【坐标轴事件】“Moveforward”这个操作是玩家的一种输入 右键添加一个操作【Pawn】“Get Controlled Pawn” Charactor是一种特殊的Pawn，所以用“Get Controlled Pawn”即可 APlayerController蓝图： 进入APlayerMode，选中【工具栏】面板下的【类默认值】，在【细节】里【Classes】下 把Player Controller Class改成自己建的“APlayerController” 把Default Pawn Class改成自己建的“APlayer” 编译，保存 回到自己建的关卡，把【细节】旁边的【世界设置】里把GameMode Override默认的“None”改成自己建的“APlayerMode” 如果【细节】旁边没有【世界设置】，可以编辑器最上方第二栏的【窗口】里调出 编译、保存 此时在自建的关卡里可以点击播放后用W/S操控角色前后平移。","link":"/2020/01/08/UE4%E8%93%9D%E5%9B%BE%20%E7%AC%AC1%E8%AF%BE/"},{"title":"Unity 2018 UI基础","text":"Unity版本：Unity 2018.4.13c1 Personal Interface Type 交互界面类型 Diegetic(剧情的，故事内的)：存档点 Spatial(受空间条件限制的)：高亮任务NPC或其他玩家，或玩家自己 Meta：有写摄像机玩家察觉不到，但开发者知道 Non-Diegetic ：打分面板 Canvas Type画布类型 Screen Space Overlay：在场景顶层，HUD，用于标识角色状态等信息 Screen Space Camera： World Space： Interface Type Use Canvas Type Overlay用于做No-diegetic UI Camera用于做No-diegetic &amp; diegetic UI World用于做diegetic UI What is HUD ? HUD - Head-Up Display HUD或状态条是游戏UI中视觉传达玩家信息的一种交互方式。 导入资源包 新建好项目后，导入ui-fundamentals-2018.unitypackage，进入Scenes文件件，双击打开UIScene 一、三种画布的添加1. Overlay新建一个新场景，菜单栏GameObject &gt; UI &gt; Canvas，在其组件Canvas &gt; Render Mode选中Screen Space - Overlay。 在Canvas下新建一个Cube，但我们却无法在Game视窗看到Cube，无论Cube调整到多大。这就是Overlay型画布。我们可以看见在其上边放置的二维图片，文本，和一些可以互动的东西比如按钮，而三维模型无法看到。 接着我们在Cube下新建一个UI &gt; Button，通过Game视窗，我们看到一个显示在画布上的按钮。 想要看到那个Cube，需要将其放置在摄像机的视野中，我们将Cube位置重置，接着将Cube向Z轴正方向移动5个单位长度，使其正好在Main Camera正前方，此时我们得以在Game视窗中看到Cube，注意这个Cube不在画布上。 2. Camera我们将Carves的Render Mode改成Screen Space - Camera，此时Render Camera没有指定，我们将Main Camera拖拽过去添加上。这时候我们发现Game视窗下的按钮消失了，我们选中Main Camera，将其Camera &gt; Clipping Planes Far由原来的10改成100或1000此时我们又看到了button，或者不改变摄像机的可视范围，将Canves的Plane Distance(平面距离)改为5，即把画布移到摄像机的可视范围内，也同样在Game视窗中显示button。 3. World Space我们将Canves的Render Mode改为World Space。将Cube拖拽到Main Camera的子系。 接下来我们将按钮Y方向旋转一定角度。 再看Game视窗，可以看到倾斜的按钮 二、不同的分辨率的屏幕1. 高分辨率PC游戏2. HTML5网页大小3. 移动设备横屏与竖屏File &gt; Build Settings，默认是选择PC平台 三、文本组件打开UIStart场景，选中03-Responsive，在菜单栏GameObject下选择UI &gt; Text","link":"/2020/02/19/Unity%202018%20UI%E5%9F%BA%E7%A1%80/"},{"title":"UE4蓝图 第2课","text":"主讲人：神经刀游戏工作室https://www.bilibili.com/video/av33992806 接上一堂课 接下来给角色赋予其他行动功能 进入【项目设置】的【引擎】【输入】，在Axis Mappings下自定义添加一个“MoveRight” 添加按键【键盘A】,Scale设置为-1.0 添加按键【键盘D】,Scale设置为1.0 在Axis Mappings下自定义添加一个“Turn” 添加【鼠标X】,Scale设置为1.0 在Axis Mappings下自定义添加一个“LookUp” 添加【鼠标Y】,Scale设置为-1.0 进入“APlayerController”，在事件图表下，添加坐标轴事件“MoveRight” 复制粘贴一个“Add Movement Input“ 添加一个Pawn操作“Get Control Rotation”、一个”Get Right Vectot” 添加坐标轴事件”Turn“和”LookUp“ 添加”Add Yaw Input”、”Add Pitch Input”、”Add Roll Input” Pawn控制角色的行动，PlayerController控制控制器的旋转功能 连线如图 进入APlayer，选中【SwingArm】，在【细节】【Camera Settings】把【Use Pawn Control Rotation】打勾，编译，保存 此时点【播放】，角色可以左右平移，角色正面紧随摄像机视角改变朝向 进入APlayer，选中【组件】下的【CharacterMovement】,在【细节】【Character Movement(Rotation Settings)】 【Rotation Rate】【Z】改成1000。(修改角色转身速率) 【Orient Rotation to Movement】打勾 选中【组件】下的【APlayer(自身)】，在【细节】【Pawn】下把【Use Controller Rotation Yaw】取消打勾，编译，保存。 此时点【播放】，角色正面不紧随摄像机视角改变朝向，只有在行动时转身改变朝向 怎么给蓝图写注释？ 选中/框选要注释的操作，按【C】产生注释框，注释框可以嵌套 选中注释框，在右边【细节】【Comment Color】改注释区域的颜色、透明度 在APlayer里选中【组件】【Mesh】，在【细节】【Mesh】里可以点击放大镜按钮，可以定位并选中当前使用的模型 双击”SK_Mannequin“打开模型 模型五大部分：骨架、网格体、动画、蓝图、物理 骨架上填满了”肉“就成了网格体，骨骼是根本，一个骨骼对应多个网格体多个动画多个物理多个蓝图（动画蓝图），一个动画仅对应唯一一个骨骼，动画跟着骨骼走。 点击【浏览】按钮可以定位选中具体的文件","link":"/2020/01/08/UE4%E8%93%9D%E5%9B%BE%20%E7%AC%AC2%E8%AF%BE/"},{"title":"Python 3相比Python 2的变化","text":"主要是编码方面的变化 编码方面Python 3默认按UTF-8处理，支持中文字符；Python 2默认按ASCII处理，不支持中文字符。 在Python 2中如需使用中文字符，比须首行声明字符集如下： 1# -*- coding:utf-8 -*-","link":"/2019/03/19/Python3%E7%9B%B8%E6%AF%94Python2%E7%9A%84%E5%8F%98%E5%8C%96/"},{"title":"Unity动画基础","text":"Unity版本：Unity 2017.4.35f1 Personal 导入资源包unity_animation_fundamentals_module_2_begin.unitypackage 一、创建动画片段在Assets/Animations下新建Animation，命名为Chest_Open。 在菜单栏 &gt; Window &gt; Animation打开动画窗口。 找到选中场景中的Chest，在Animation窗口点击Create按钮在弹出的窗口中选中Open_Chest.anim点击保存。 在窗口中默认提供60帧，我们修改成30帧 展开Chest选中chest_top，在Animation窗口点击Add Property，展开chest_top &gt; Transform，点击Rotation右边的加号。 此时我们在动画起始和末尾各创建了一个关键帧，我们将白线拖动到最后一帧，然后点击记录按钮。 修改chest_top的Rotation的x为-130，再点击记录按钮关闭记录，这时我们点击Animation窗口的播放按钮，Scene窗口将循环播放Chest打开的动画。 如图操作，点击Clips列表，添加新的动画Clip，命名为Chest_Close 点击Clips列表，可改变当前要编辑的Clip. 点击Add Property，选中chest_top &gt; Transform &gt; Rotation。 二、使用动画曲线保持Chest被选中，点击Animation窗口下的Curves按钮，打开动画曲线界面， 三、重新定时动画四、使用动画事件将动画光标移动到箱子完全打开的关键帧位置，点击添加动画事件按钮。 此时Inpsector面板出现动画事件函数设置。我们在Hierarchy选中Chest，为其添加组件Treasure Chest(Script)。 为Chest添加空的子GameObject并重命名为Spawner。将其拖拽添加到Chest的Treasure Chest(Script)组件下Spawner属性。从Assets/Prefabs下拖拽Coin到Chest的Treasure Chest(Script)组件下Coin Prefab属性。我们双击该组件下的Script属性打开脚本文件，在其中我们发现有一个OpenChest方法。 回到Unity，在Animation窗口点击刚才添加的动画事件标记，在Inspector窗口的动画事件函数选项里我们有3种函数可以选择。选择OpenChest，这个函数就与动画事件关联上了。当我们播放游戏时，开箱动画播放到完全打开关键帧时将自动触发动画事件，调用OpenChest函数，弹出硬币。 五、创建多个剪辑首先为Chest_Close添加属性Rotation，通过Ctrl+C/V将Chest_Open的关键帧复制粘贴到Chest_Close里。 在Chest_Close里，将首尾两个关键帧交换位置，然后调整其动画曲线。 六、动画控制器基础知识如果我们有多个动画片段，需要管理它们，甚至在一个动画到下一个动画之间转换，需要使用动画控制器。这是一个可以与动画组件一起使用的游戏Assets。当我们创建动画片段时，Unity会自动创建一个动画控制器，该动画控制器需要设置动画的控制参数。 双击动画控制器，打开Animation窗口 在Animation窗口中，我们看到四个节点，按住鼠标中键可以移动观图视角 Any State：特殊节点，允许中断正在播放的当前状态或正在播放以退出并进入另一个状态的当前动画。例如，当玩家的生命值降低到零，玩家处于生命状态并不重要，它将转到死亡动画。 Entry：任何游戏开始或基础层上的特殊状态机的开始，将进入的第一个默认状态/默认动画。 Exit：特殊节点，表明状态机应该退出。 Chest_Open状态是橙色的，表示这个动画将在游戏开始后立即播放，因此我们需要创建一个空状态","link":"/2020/02/23/Unity%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"},{"title":"Unity基本操作","text":"新建场景 File&gt;New Scene（或快捷键Ctrl+N）, 默认名“Untitled”, Ctrl+S保存到Yourproject/Assets/Scenes下(没有Scenes就新建一个) 基于3D物体的创建 Hierachy面板：层级面板，用于显示当前场景中有哪些资源。在这些面板中可以往场景中添加资源。 在该面板右键创建物体 操作物体的快捷键： Q：切换到视角拖拽 W：切换到物体平移 E：切换到物体旋转 R：切换到物体缩放 Project/Console面板：Project选项卡可以管理Assets、Packages；Console选项卡可以查看控制台信息 Assets下导入素材 在Project&gt;Assets下右键，Import Packages&gt;Custom Packages，素材可以从官网（https://assetstore.unity.com ）搜索下载（官方免费素材例子：Free Rocks、Standard Assets） 导入后，选择需要的文件，拖拽到Hierachy面板即可加入场景 游戏导出 File&gt;Build Settings, 在弹出的窗口里点击【Add Open Scenes】添加场景 点击【Build】，选择导出路径并确认即可 项目目录结构 Assets：资源文件夹 Library：库文件夹 Logs Packages ProjectSettings：存放项目设置文件 Temp：存放临时文件 鼠标功能 鼠标左键：选中场景中的物体 鼠标中键：单击，视野聚焦到选中物体；拖拽，平移场景的观察角度；滚动，拉远拉近 鼠标右键：旋转场景的观察角度 Alt + 鼠标左键：旋转观察角度 Alt + 鼠标右键：拉远拉近 双击Hierachy面板中的物体：视野聚焦到双击选中的物体 Inspector面板 Transform组件(变换组件) Position：物体在直角坐标系中的位置，默认（0,0,0） Rotation：物体的旋转角度 Scale：物体的缩放，默认（1,1,1） 点击小齿轮&gt;Reset：归零 坐标系切换按钮： 自身坐标系：Local 世界坐标系：Global 摄像机两种模式切换： Persp：透视模式，近大远小 ISO：正交模式，远近一样大（多用于2D模型） Mesh Filter组件（网格过滤器）：指定mesh（物体的几何形状），物体的形状由网格决定 Mesh Renderer组件（网格渲染器）：从网格过滤器中获得几何体的形状然后进行渲染 Prefab预制体 父子关系：移动父物体，子物体会跟着移动 在Hierarchy面板中，任意两个物体都可以建立父子关系 预制体：Prefab，预先准备好的物体，可以重复使用和利用，例如手枪中的子弹 管理预制体：在Assets中建立“Prefabs”文件夹，用于管理预制体 创建预制体：直接将Hierarchy面板中的物体拖拽到Project面板的Assets中，即可创建一个预制体。预制体文件的后缀是”.prefab” 使用预制体：将预制体直接拖拽到Hierarchy面板或Scene面板，都可以在场景中创建一个相应的物体 预制体与非预制体的区别： 在Hierarchy面板中，非预制体颜色是白色，预制体颜色是蓝色 在Inspector面板中，预制体比非预制体多了一个“Prefab”选项 预制体的好处：编辑其中一个，在Inspector&gt;Prefab，“Apply”一下，所有的全部改变 Material(材质)：用来更改物体的颜色质地等属性 新建材质：在Assets文件夹下创建Materials文件夹，在Materials文件夹下右键&gt;Create&gt;Material 运用举例： 创建3个Cube预制体，在Materials文件夹下新建一个叫“Black”的材质，在Inspector&gt;Main Maps设置颜色成黑色 在Hierarchy面板选中其中一个Cube预制体，将”Black”材质拖拽到Inspector&gt;Mesh Renderer&gt;Materials&gt;Element 0，Cube的颜色变为黑色。 如果要把其他两个Cube预制体也变成黑色，则在Inspector&gt;Prefabs下点击Overrides旁的小三角，选择Apply All即可 如果此时在改变其中一个Cube预制体的材质，其他两个也会跟着一起改变","link":"/2020/01/16/Unity%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"Unity C#脚本基础","text":"Unity版本：Unity 2017.4.35f1 Personal 一、在Unity中创建C#脚本 Project&gt;Assets下新建一个叫“Scripts”的文件夹用于存放脚本 在Scripts文件夹下右键&gt;Create&gt;C# Script，取名“ExampleScript” 两种方法给物体添加脚本： 左键单击并将脚本从项目文件夹拖拽到物体上 在物体的Inspector窗口点击Add Component按钮，选择Scripts添加现有的脚本。 通过Add Component按钮，选择New Script添加新建脚本，但脚本是被添加到Assets文件夹，而非Scripts文件夹。 删除物体的脚本：在物体的Inspector面板找到例如ExampleScript(Script)，点击小齿轮，选择Remove Component 调试时打开和关闭脚本：勾选或取消勾选相应的脚本。脚本中可能有错误，如果禁用它，它可能仍会出现并在底部显示错误。因此需要使用代码注释来屏蔽代码块 注意：项目窗口的脚本删除后无法撤销删除。 二、脚本结构双击ExampleScript将自动加载到Visual Studio 2017，如果遇到”File Modification Detected“弹窗，选择“Reload All”重新加载脚本。在Visual Studio将看到ExampleScript.cs的代码： 12345678910111213141516using System.Collections;//命名空间using System.Collections.Generic;//命名空间只是引用类的名称的集合using UnityEngine;public class NewBehaviourScript : MonoBehaviour {//每一个通过Unity新建的脚本都继承自MonoBehavior // Use this for initialization void Start () { } // Update is called once per frame void Update () { }} MonoBehavior来自命名空间UnityEngine，每一个通过Unity新建的脚本都继承自MonoBehavior。 MonoBehavior允许你将脚本作为组件附加到游戏对象中。 类(Class)，只是变量和方法的容器 注意到，类名和.cs文件名相同。如果要修改类的名字，.cs文件名也要一起修改。 起始函数Start()：脚本一启动就执行的方法。 更新函数Update()：每一帧都在执行以保证更新的方法。 三、对游戏对象的基本操作1. 访问、操纵游戏对象组件 导入资源包：首先在Assets文件夹导入Unity_C_Sharp_Fundamentals_Assets.unitypackage。 创建一个Floor：在Assets/Standard Assets/Prototyping/Prefabs下找到FloorPrototype08x01x08，拖拽到场景中，重置其位置。 放入角色：在Assets/Prefabs下找到dwarf_hero，拖拽到场景中的Floor上。给角色添加Capsule Collider组件，并将Capsule Collider下的Center &gt; Y设为0.8，Radius设为0.4，Height设为1.6。 为角色添加脚本：在Assets/Scripts下创建脚本Player.cs，打开脚本，编辑代码如下并保存。 12345678910111213141516using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour { public CapsuleCollider playerConllider; // Use this for initialization void Start () { playerConllider = GetComponent&lt;CapsuleCollider&gt;(); } // Update is called once per frame void Update () { }} 回到Unity编辑器，将Player.cs拖拽到角色的Inspector窗口里。可以看到角色增加了一个叫Player(Script)的组件，里边的Player Collider的值为None(Collider)。当我们点击播放按钮，Player Collider会很容易地自动获取到Collider组件，因为Capsule Collider组件和脚本组件在同一个游戏物体里（角色）。 如果我们在上边的代码中public Collider playerCollider;下插入一行playerCollider.enabled = false;，保存脚本回到Unity点击播放，则可以看到Capsule Collider组件被取消勾选。 同理，如果我们在上边的代码中public Collider playerCollider;下插入一行playerConllider.isTrigger = true;，保存脚本回到Unity点击播放，则可以看到Capsule Collider组件下的Is Trigger被勾选。 如果我们要在游戏启动时修改Capsule Collider的长度、中心位置，我们可以编写代码如下： 1234567void Start () { playerCollider = GetComponent&lt;CapsuleCollider&gt;(); //playerCollider.enabled = false; //取消勾选Capsule Collider组件 //playerCollider.isTrigger = true; //勾选Capsule Collider组件下Is Trigger选项 playerCollider.height = 3f; //修改胶囊碰撞体的高（长度） playerCollider.center = new Vector3(0f, 2f, 0f); //修改胶囊碰撞体中心的位置坐标} 2. 用户输入在Unity编辑器菜单栏，点击Edit &gt; Project Settings &gt; Input在Inspector窗口打开InputManager。我们可以在InputManager中编辑用户输入控制。 我们回到Player.cs，编辑Update函数如下： 1234567void Update (){ float moveHorizontal = Input.GetAxis(&quot;Horizontal&quot;); float moveVertical = Input.GetAxis(&quot;Vertical&quot;); print(moveHorizontal);} 保存后回到Unity编辑器点击播放，当我们按住【A】键时，控制台将打印消息一系列大于-1且小于0的小数，打印的小数快速减小直到打印出-1，松开键盘后归0，按住【D】键，打印大于0且小于1的小数，并且打印的小数快速增大直至打印出1。 由此我们得知，按键A关联水平负方向，W关联水平正方向。 接下来将Player.cs编辑如下： 1234567891011121314151617using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour { public float moveSpeed = 5f; // Update is called once per frame void Update () { float moveHorizontal = Input.GetAxis(&quot;Horizontal&quot;);//获取左右移动分量 float moveVertical = Input.GetAxis(&quot;Vertical&quot;);//获取前后移动分量 //创建水平面移动矢量 Vector3 movement = new Vector3(moveHorizontal, 0f, moveVertical); //将移动矢量转译到Transform组件 transform.Translate(movement * Time.deltaTime * moveSpeed); }} 保存后，在Unity编辑器将镜头摆到合适观察角色的位置，点击播放。通过【W】【A】【S】【D】键，我们可以控制角色前后左右移动。 四、游戏对象之间的交互1. 脚本之间交互在Assets/Prefabs下找到Battle_Dummy，拖拽进场景到Floor上。在Scripts文件夹新建一个Enemy.cs。将Enemy.cs拖拽到Battle_Dummy的Inpsector窗口中形成Enemy(Script)组件。 给Enemy添加上一个Health属性，即编辑Enemy.cs如下： 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;public class Enemy : MonoBehaviour { //声明Enemy类 public int enemyHealth = 4; //声明enemyHealth并初始化 // Use this for initialization void Start (){ } // Update is called once per frame void Update (){ }} 编辑Player.cs如下 12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour { public float moveSpeed = 5f; private GameObject enemy; private Enemy enemyScript; // Use this for initialization void Start (){ enemy = GameObject.Find(&quot;Battle_Dummy&quot;); enemyScript = enemy.GetComponent&lt;Enemy&gt;(); } // Update is called once per frame void Update (){ float moveHorizontal = Input.GetAxis(&quot;Horizontal&quot;); float moveVertical = Input.GetAxis(&quot;Vertical&quot;); Vector3 movement = new Vector3(moveHorizontal, 0f, moveVertical); transform.Translate(movement * Time.deltaTime * moveSpeed); if (Input.GetKeyDown(KeyCode.Space)) //当键盘按下空格键时执行 { enemyScript.enemyHealth--; //Health自减1 } }} 保存脚本后，回到Unity点击播放，当我们每按一次【空格】键时，点击Battle_Dummy，通过Inspector窗口可以看到Enemy组件下的Enemy Health都会减1。 2. 碰撞交互给角色添加Rigidbody组件,并设置Constraints如图 给Battle_Dummy添加Capsule Collider组件，Center设置为（0，0.5，0），Radius设置为0.4，Height设置为2。通过快捷键Ctrl+D快速生成两个复制品，拖到旁边如图： 在Player.cs里为类Player添加方法OnCollisionEnter： 1234567void OnCollisionEnter(Collision collision){ if(collision.gameObject.tag == &quot;Enemy&quot;) { enemyScript.enemyHealth--; }} 回到Unity给3个Battle_Bummy添加Tag Enemy，角色添加Tag Player。 点击播放，选中Battle_Bummy，控制角色碰到Battle_Bummy一次，其Enemy组件下EnemyHealth减1一次。 但当我们控制角色碰撞Battle_Bummy(1)、Battle_Bummy(2)时，它们的EnemyHealth却没有减少。 修改Player.cs如下后即可解决问题： 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour { public float moveSpeed = 5f; //private GameObject enemy; private Enemy enemyScript; // Use this for initialization void Start () { //enemy = GameObject.Find(&quot;Battle_Dummy&quot;); //enemyScript = enemy.GetComponent&lt;Enemy&gt;(); } // Update is called once per frame void Update () { float moveHorizontal = Input.GetAxis(&quot;Horizontal&quot;); float moveVertical = Input.GetAxis(&quot;Vertical&quot;); Vector3 movement = new Vector3(moveHorizontal, 0f, moveVertical); //角色移动 transform.Translate(movement * Time.deltaTime * moveSpeed); } void OnCollisionEnter(Collision collision) { if(collision.gameObject.tag == &quot;Enemy&quot;) { enemyScript = collision.gameObject.GetComponent&lt;Enemy&gt;(); enemyScript.enemyHealth--; } }} 3. 触发器我们从Assets/Prefabs往场景里添加一个Chest 在Scripts文件夹里新建一个TreasureChest.cs，为类TreasureChest添加一个OnTriggerEnter方法。 1234567void OnTriggerEnter(Collider other){ if(other.gameObject.tag == &quot;Player&quot;) { print(&quot;Interacting!&quot;); }} 在Unity中，给Chest添加上TreasureChest(Script)组件。 点击播放，当我们控制角色碰到Chest一次，控制台打印消息“Interacting!”一次。 如果把OnTriggerEnter换成OnTriggerStay，当我们控制角色停留在Chest旁边时，控制台会持续打印消息“Interacting!”。 如果在OnTriggerEnter方法下方添加OnTriggerExit方法： 1234567void OnTriggerExit(Collider other){ if(other.gameObject.tag == &quot;Player&quot;) { print(&quot;Hey!&quot;); }} 当我们的角色靠近Chest在离开，控制台将打印一次消息“Hey!”。 我们给TreasureChest添加一个布尔类型的公共属性interactable，并初始化为false。修改OnTriggerEnter方法和OnTriggerExit方法的内容如下： 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;public class TreasureChest : MonoBehaviour { public bool interactable = false; void OnTriggerEnter(Collider other) { if(other.gameObject.tag == &quot;Player&quot;) { interactable = true; } } private void OnTriggerExit(Collider other) { if(other.gameObject.tag == &quot;Player&quot;) { interactable = false; } }} 当我们播放游戏时，Chest的TreasureChest(Script)组件下会生成一个interactable选项，当角色靠近Chest时，interactable被勾选（值为true），当角色离开时，interactable取消勾选（值为false）。 接下来加入动画， 点击Unity菜单栏的Window &gt; Animator打开Animator窗口，可以看到Parameters下有一个openChest，右边的转变图里，选中Idle_State，我们看到Transition下有一个转变情况：Idle_State -&gt; ChestOpen。点击，下方出现转变条件（Conditions）——openChest的值为true（默认）。因此我们在Update方法里可以写上，当开箱按键（这里设为空格）按下后，动画设置openChest为true。 编辑后的TreasureChest.cs如下： 1234567891011121314151617181920212223242526272829303132333435using System.Collections;using System.Collections.Generic;using UnityEngine;public class TreasureChest : MonoBehaviour { public bool interactable = false; private Animator anim; // Use this for initialization void Start () { anim = GetComponent&lt;Animator&gt;(); } // Update is called once per frame void Update () { if(interactable &amp;&amp; Input.GetKeyDown(KeyCode.Space)) { anim.SetBool(&quot;openChest&quot;, true); } } void OnTriggerEnter(Collider other) { if(other.gameObject.tag == &quot;Player&quot;) { interactable = true; } } private void OnTriggerExit(Collider other) { if(other.gameObject.tag == &quot;Player&quot;) { interactable = false; } }} 播放游戏，当角色靠近Chest按下空格键，播放箱子打开动画。 4. 射线侦测（Raycasting）射线的一个应用时侦测角色周围是否有敌人。 回到Player.cs，我们给类Player添加以下3个变量： 123private RaycastHit hit;private Ray ray;public float rayDistance = 4f; 在Update方法做如下应用： 12ray = new Ray(transform.position, transform.forward);Debug.DrawRay(ray.origin, ray.direction * rayDistance, Color.red); 回到Unity播放游戏，点击Scene窗口，我们发现角色脚下正前方（Z轴正方向）出现一条4格长度的红线。 要把红线上移到角色重新，我们可以对上边两行代码的第一行修改成如下： 1ray = new Ray(transform.position + new Vector3(0f,playerCollider.center.y,0f), transform.forward); 接下来实现射线反馈，在Update方法里继续编写如下代码： 1234567if(Physics.Raycast(ray, out hit)){ if(hit.distance &lt; rayDistance) { print(&quot;We hit something!&quot;); }} 播放游戏，移动角色，当红线触及Battle_Dummy或Chest时（其实时触及它们的碰撞体），控制台持续打印消息“We hit something!”。 接下来修改执行反馈的代码如下： 12345678910if(Physics.Raycast(ray, out hit)){ if(hit.distance &lt; rayDistance) { if(hit.collider.gameObject.tag == &quot;Enemy&quot;) { print(&quot;There is an enemy ahead!&quot;); } }} 播放游戏，当角色移动到Chest前边时，反馈但没有打印消息，当角色移动到Battle_Dummy前边时，控制台持续打印消息“There is an enemy ahead!” 至此，Player.cs完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour { public CapsuleCollider playerCollider; public float moveSpeed = 5f; private Enemy enemyScript; private RaycastHit hit; private Ray ray; public float rayDistance = 4f; // Use this for initialization void Start () { playerCollider = GetComponent&lt;CapsuleCollider&gt;(); } // Update is called once per frame void Update () { float moveHorizontal = Input.GetAxis(&quot;Horizontal&quot;); float moveVertical = Input.GetAxis(&quot;Vertical&quot;); Vector3 movement = new Vector3(moveHorizontal, 0f, moveVertical); //角色移动 transform.Translate(movement * Time.deltaTime * moveSpeed); ray = new Ray(transform.position + new Vector3(0f,playerCollider.center.y,0f), transform.forward); Debug.DrawRay(ray.origin, ray.direction * rayDistance, Color.red); if(Physics.Raycast(ray, out hit)) { if(hit.distance &lt; rayDistance) { if(hit.collider.gameObject.tag == &quot;Enemy&quot;) { print(&quot;There is an enemy ahead!&quot;); } } } } void OnCollisionEnter(Collision collision) { if(collision.gameObject.tag == &quot;Enemy&quot;) { enemyScript = collision.gameObject.GetComponent&lt;Enemy&gt;(); enemyScript.enemyHealth--; } }} 5. 实例化（Instantiate）和销毁打开TreasureChest.cs，为将要实例化的预制体创建供存储的变量。 12public Rigidbody coinPrefab;public Transform spawner;编辑Update函数如下： 123456789void Update () { if(interactable &amp;&amp; Input.GetKeyDown(KeyCode.Space)) { anim.SetBool(&quot;openChest&quot;, true); Rigidbody coinInstance; coinInstance = Instantiate(coinPrefab, spawner.position, spawner.rotation) as Rigidbody;//将实例化结果由Object类型强转成Rigidbody类型 coinInstance.AddForce(spawner.up * 100);//给coinInstance在Y轴正方向上添加受力 }} 回到Unity，我们看到Chest的Treasure Chest(Script)组件下多了两个属性Coin Prefabs和Spawner。从Assets/Prefabs拖拽Coin到Coin Prefabs，注意到我们的预制体Coin也具备Rigidbody组件，因此可以放入要求Rigidbody类型的Coin Prefabs。 选中Chest新建一个空的子Object，命名为spawner，将其拖拽到Chest的TreasureChest组件下Spawner属性。 选中spawner，将其往Y轴正方向移动到Chest上方（此处移动了0.86）。 播放游戏，当角色移动到Chest前，按一次空格键，Chest打开并弹起一个Coin然后垂直落回原位，Hierarchy窗口也会生成一个Coin(Clone)。 如果此时再按空格，则Coin继续弹出，并叠在之前的Coin上。 接下来我们实现Coin实例的销毁。 在Assets/Scripts下新建Coin.cs并在Visual Studio打开，在Start方法里添加语句： 1Destroy(gameObject, 2.0f); //两秒后销毁gameObject 给Assets/Prefabs下的预制体Coin添加组件Coin(Script) 再次播放游戏，当我们每按一次空格，箱子里弹出的硬币均仅仅存在2秒。 Coin.cs完整代码： 1234567891011121314using System.Collections;using System.Collections.Generic;using UnityEngine;public class Coin : MonoBehaviour { // Use this for initialization void Start () { Destroy(gameObject, 2.0f); //两秒后销毁gameObject } // Update is called once per frame void Update () { }} TreasureChest.cs最终代码： 1234567891011121314151617181920212223242526272829303132333435363738394041using System.Collections;using System.Collections.Generic;using UnityEngine;public class TreasureChest : MonoBehaviour { public bool interactable = false; private Animator anim; public Rigidbody coinPrefab; public Transform spawner; // Use this for initialization void Start () { anim = GetComponent&lt;Animator&gt;(); } // Update is called once per frame void Update () { if(interactable &amp;&amp; Input.GetKeyDown(KeyCode.Space)) { anim.SetBool(&quot;openChest&quot;, true); Rigidbody coinInstance; coinInstance = Instantiate(coinPrefab, spawner.position, spawner.rotation) as Rigidbody;//将实例化结果由Object类型强转成Rigidbody类型 coinInstance.AddForce(spawner.up * 100); } } void OnTriggerEnter(Collider other) { if(other.gameObject.tag == &quot;Player&quot;) { interactable = true; } } private void OnTriggerExit(Collider other) { if(other.gameObject.tag == &quot;Player&quot;) { interactable = false; } }}","link":"/2020/01/18/Unity%20C%20Sharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"},{"title":"Unity建立角色控制器","text":"Unity版本：Unity 2018.4.13c1 Personal 一、建立角色从Unity Assets\\Unity Fundamentals Source Assets\\Character导入Characters.unitypackage 再Assets/Models/Hero/Models/Hero/FBX下将Hero_Low拖拽到场景中，给Hero_Low添加Player Controller(Script)组件，Nav Mesh Agent组件并修改Radius为0.4，Height为1.6。设置Hero_Low的Tag为Player，Layer为Player。 再Hierarchy窗口添加空Game Object，命名为MouseManager，为其添加Mouse Manager(Script)组件，Clickable Layer设置为Clickable，并添加鼠标材质： 添加鼠标点击事件，添加上时间Object拖入Hero_Low，函数选择NavMeshAgent &gt; destination 创建一个空物体，命名为NavMeshSurface，并为其添加NavMeshSurface（Script）组件 Agent Type: Open Agent Settings &gt; Radius: 0.4, Height: 1.6。回到Inspector点击Bake。注意到中间木桥处有断开，我们可以在木桥处放一个Cube,并将其Layer设置为Clickable，角色可以走动的地面均选中并将Layer设置为Clickable，然后重新烘焙NavMeshSurface。 NavMeshSurface连成一块后，把Cube Disable掉即可。 这时我们可以播放游戏看看角色是否可以走过去了。 二、动画控制器在Assets下新建一个Animations文件夹，在Assets/Animations下新建一个Animation Controller，取名为Hero_Alt，即Hero_Alt.controller文件，双击进入其Animator窗口，界面可以通过按住鼠标中键拖拽，滚动鼠标中键缩放。 Animator窗口 &gt; Base Layer下有三个状态：Any State, Entry, Exit。 Entry：初识状态，如角色闲置动画。 Any State：任何时候都可以转换到的状态，如角色死亡动画。 Exit：结束状态。 常用的是Entry和Any State状态。 在空白处右键Create State &gt; From New Blend Tree，将建好的Blend Tree重命名为Motion Tree，双击进入Motion Tree，将里边的Blend Tree重命名为Speed，Inspector &gt; Parameter重命名为Speed。点击下方的加号 &gt; Add Motion Field，然后给我们的Motion Field选择Motion：anm_dwarfHero_idle。同样的方法，我们再添加一个Motion Field，选择anm_dwarfHero_run 添加完两个要混合的动画，点击下方动画播放小窗口的播放按钮，此时播放的是闲置动画，当我们把Speed由0播放到1时，角色动画过渡到奔跑动画。 打开Assets/Scripts下的PlayerController.cs。保存代码如下： 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour{ private Animator anim; private NavMeshAgent agent; // Use this for initializtion void Awake() { anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); } void Update() { anim.SetFloat(&quot;Speed&quot;, agent.velocity.magnitude); }} 给角色的Animator组件 &gt; Controller添加RuntimeAnimatorController：Hero_Alt。 回到Animator窗口，给Parameter添加Speed参数 回到Scene窗口，点击Play，播放游戏。鼠标点击控制角色，我们的角色行动不在像尸体一样平移，而是有闲置动画，奔跑动画的移动。 三、给角色添加附件将Assets/Models/Hero/Models/Weapons/FBX下的LowpolySword添加到场景中，调整到合适的大小。 LowpolySword的全身是灰色的，我们需要更新材质。再Assets/Models/Hero/Models/Weapons/Materials下选中Sword.mat，锁定Inspector窗口，找到Assets/Models/Hero/Models/Weapons/Textures，将Sword Base Color.png、Sword Metalic.png、Sword Normal.png分别拖拽到Inspector &gt; Main Maps &gt; Albedo、Metalic、Mormal Map。将Main &gt; Smoothness调整到0.4。 我们将LowpolySword拖拽到Hero_Low/R_Wrist_Jnt下，然后将LowpolySword的位置旋转角度都归零，调整LowpolySword的角度，使LowpolySword看上去被正确地握在Hero_Low手中。 播放游戏，可以看到LowpolySword跟随Hero_Low的右手动画运动。 四、使用Cinemachine制作跟随镜头打开Unity菜单栏 &gt; Window &gt; Package Manager，安装Cinemachine插件。 完成安装后通过Unity菜单栏 &gt; Cinemachine &gt; Create Virtual Camera新建一个虚拟摄像机CM vcam1。 虚拟摄像机可以覆盖主摄像机的设置。 在Scene窗口下选择合适的观察角色的视角，选中CM vcam1，按快捷键Ctrl+Shift+F。 将Hero_Low拖拽到CM vcam1的Inspector &gt; Cinemachine Virtual Camera(Script) &gt; Follow和Look At Aim设置为Do nothing，Body选择Framing Transposer。 转到Game视窗，选中CM vcam1，可以看到画面分为三种区域： 中间区域（原本的颜色）：叫做死亡区域，LookAt的这个目标在这个区域内，摄像机是不会跟随的。蓝色区域：代表缓冲区域，此时摄像机会开始跟随，使目标在中间的透明区域。红色区域：不可到达区域，跟随过程中目标是不可能到达这些区域的。 我们可以拖动画面上的直线改变这三种区域的大小。 播放游戏，控制角色行走，摄像机跟随角色移动。 我们还可以给虚拟摄像机添加其他设置，例如Noice设置为Basic Muti Channel Perlin，Noice Profile设置为Handheld_normal_mild，Amplitude Gain和Frequency Gain均设置为0.5，这样一来游戏中摄像机就有了轻微的晃动。 五、打包生成游戏将场景保存好后，Unity菜单栏File &gt; Build Settings，确认所有场景都在Scene In Build，选择平台，按需要勾选是否创建VS解决方案或开发build。 点击Player Settings，在其Inspector面板我们可以修改游戏名称，公司名称，版本号，游戏图标，游戏中的鼠标材质等信息。这里我们添加了一个游戏鼠标材质，其他设置均默认，然后点击Build按钮选好路径生成游戏。","link":"/2020/02/16/Unity%E5%BB%BA%E7%AB%8B%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"title":"Unity简易关卡原型开发","text":"Unity版本：Unity 2018.4.13c1 一、准备工作在一个新建的场景下新建一个Cube，调成Cube的大小，使之成为一个扁平面（Scale参考值：x=50，y=0.36，z=50），重命名为“Floor”，重置Floor的位置到（0，0，0）。 在Floor上方新建一个Capsule,调整大小致合适。 在Floor上方新建一个Cube,调整大小致门板的样子，重命名为“Door” 在场景里新建一个空Object，命名为“MouseManager”。 在项目面板的Assets文件夹下新建一个Materials文件夹，在其中新建一个材质，取名为Gray。将Gray的Inspector面板的MainMaps下把颜色设置成灰色。拖拽Gray致Floor上。 调整角度到可以同时看到Door、Capsule、Floor和环境的合适位置后，选中Main Camera，使用快捷键【Ctrl + Shift + F】将摄像机快速调整到满足当前观察视角的位置。 完成后如下图： 在Assets文件夹下新建一个名叫“Cursors”的文件夹，导入png图片素材如下图： 二、编写鼠标交互脚本在项目面板的Assets文件夹下新建一个名叫“Scripts”的文件夹，在其中新建一个C#脚本文件，取名为MouseManager 打开MouseManager.cs，编写代码并确定无错误后保存如下： 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public class MouseManager : MonoBehaviour{ //which objects are clickable public LayerMask clickableLayer; //Swap cursors per object public Texture2D pointer;//Normal Pointer public Texture2D target;//Cursors for clickable objects like world public Texture2D doorway;//Cursors for doorways public Texture2D combat;//Cursors for combat sections // Update is called once per frame void Update() { RaycastHit hit; if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 50, clickableLayer.value)) { bool door = false; if(hit.collider.gameObject.tag == &quot;Doorway&quot;) { Cursor.SetCursor(doorway, new Vector2(16, 16), CursorMode.Auto); door = true; } else { Cursor.SetCursor(target, new Vector2(16, 16), CursorMode.Auto); } } else { Cursor.SetCursor(pointer, Vector2.zero, CursorMode.Auto); } }} 回到Unity编辑器，选中MouseManager，在Inspector面板点击【Add Component】按钮，搜索到MouseManager后单击添加。 把Cursors文件夹下的png素材拖拽到Mouse Manager组件如下图： 点击Inspector面板上方的Layers下拉按钮，点击Edit Layers 点开Layers，在User Layers 9填写”Clickable“ 在Hierachy面板选中MouseManager，在Inspector面板的MouseManager组件下的Clickable Layer选项点击下拉，把默认的Nothing改选成Clickable 点击播放按钮验证效果。当鼠标移动到Floor上时，鼠标样式为target，当鼠标移动到Door上时，鼠标样式为doorway，当鼠标移动到周围环境时，鼠标样式为pointer。 三、使用MavMesh组件实现鼠标点击移动接上一篇鼠标交互 将路径Unity Fundamentals Source Assets\\NaMeshComponents-Master下的两个文件夹Gizmos和NavMeshComponents拖拽复制到Unity编辑器项目面板Assets文件夹下。 在Hierachy面板新建一个空Object命名为”NavMesh Surface”，点击NavMesh Surface，在Inspector面板点击Add Component，选择NavMeshSurface。 点击Inspector面板上方的Layers下拉按钮，选择Edit Layers，在User Layer 10填上Player。 点击Cupsule，在Inspector面板将Layer设置为Player。 回到NavMeshSurface的Inspector面板，在NavMeshSurface组件下方，Agent Type默认Humanoid，Include Layers取消勾选Player 点击Bake按钮创建一层附在Floor上的蓝色NavMesh表面 在Door的Inspector面板添加NavMeshObstacle组件，默认Carve勾选。产生的效果是Capsule无法通过Door，即视Door为一个障碍。 添加NavMeshModifier组件，取消勾选Ingnore From Build。 回到NavMesh Surface的Inspector面板，再次点击Bake。 如果此时向上平移Door，原本Door下方的黑色矩形将消失，视为“门开启”，Capsule可以通过。 选中Capsule，添加组件NavMeshAgent，Agent Type默认Humanoid。 在项目面板Scripts文件夹下新建一个C#脚本文件，取名“PlayerController”。 打开脚本文件，编写代码如下，确认无报错后保存。 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour{ //private Animator anim; private NavMeshAgent agent; // Use this for initializtion void Awake() { // anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); }} 打开之前写的MouseManager.cs，修改代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;public class MouseManager : MonoBehaviour{ //what objects are clickable public LayerMask clickableLayer; //Swap cursers per object public Texture2D pointer;//Normal Pointer public Texture2D target;//Cursers for clickable objects like world public Texture2D doorway;//Cursers for doorways public Texture2D combat;//Cursers for combat sections public EventVector3 OnclickEnviroment; // Update is called once per frame void Update() { RaycastHit hit; if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 50, clickableLayer.value)) { bool door = false; if(hit.collider.gameObject.tag == &quot;Doorway&quot;) { Cursor.SetCursor(doorway, new Vector2(16, 16), CursorMode.Auto); door = true; } else { Cursor.SetCursor(target, new Vector2(16, 16), CursorMode.Auto); } if(Input.GetMouseButton(0)) { OnclickEnviroment.Invoke(hit.point); } } else { Cursor.SetCursor(pointer, Vector2.zero, CursorMode.Auto); } }}[System.Serializable]public class EventVector3 : UnityEvent&lt;Vector3&gt;{ } 回到Unity编辑器，MouseManager的Inpspector面板的MouseManager组件多出了Onclick Enviroment(Vector3)。 从Hierarchy面板拖拽Capsule到None(Object)，点击No function下拉框，勾选NavMeshAgent下的destination。 点击播放后，鼠标单击Floor上任意位置，Capsule移动跟随。 在Capsule的Inspector面板的NavMeshAgent组件下的Steering部分可以修改移动速度(Speed)、角速度(Angular Speed)、加速度(Acceleration)、制动距离(Stopping Distance)、自动刹车(Auto Braking)。 四、玩家互动行为实现修改MouseManager.cs如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;public class MouseManager : MonoBehaviour{ //what objects are clickable public LayerMask clickableLayer; //Swap cursers per object public Texture2D pointer;//Normal Pointer public Texture2D target;//Cursers for clickable objects like world public Texture2D doorway;//Cursers for doorways public Texture2D combat;//Cursers for combat sections public EventVector3 OnclickEnviroment; // Update is called once per frame void Update() { RaycastHit hit; if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 50, clickableLayer.value)) { bool door = false; bool item = false; if(hit.collider.gameObject.tag == &quot;Doorway&quot;) { Cursor.SetCursor(doorway, new Vector2(16, 16), CursorMode.Auto); door = true; } else if(hit.collider.gameObject.tag == &quot;Item&quot;) { Cursor.SetCursor(combat, new Vector2(16, 16), CursorMode.Auto); item = true; } else { Cursor.SetCursor(target, new Vector2(16, 16), CursorMode.Auto); } if(Input.GetMouseButton(0)) { if(door) { Transform doorway = hit.collider.gameObject.transform; OnclickEnviroment.Invoke(doorway.position); Debug.Log(&quot;DOOR&quot;); } else if(item) { Transform itemPos = hit.collider.gameObject.transform; OnclickEnviroment.Invoke(itemPos.position); Debug.Log(&quot;ITEM&quot;); } else { OnclickEnviroment.Invoke(hit.point); } } } else { Cursor.SetCursor(pointer, Vector2.zero, CursorMode.Auto); } }}[System.Serializable]public class EventVector3 : UnityEvent&lt;Vector3&gt;{ } 回到Unity编辑器，在Floor上新建一个Cube。 将其Layer设置成Clickable，点击Untagged按钮，选择Add Tag，点击加号按钮，填写“Item”，保存。 点击播放，当鼠标点击Door后，Unity编辑器控制台打印消息“DOOR”，当鼠标点击Cube后，控制台打印消息消息“ITEM”。 五、NPC原型设计在Scripts文件夹下新建两个C#脚本文件，分别命名为“NPCController.cs”，“PlayerController.cs”。 NPCController.cs代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class NPCController : MonoBehaviour{ public float patrolTime = 10f; public float aggroRange = 10f; public Transform[] waypoints; private int index; private float speed, agentSpeed; private Transform player; private Animator anim; private NavMeshAgent agent; private void Awake() { anim= GetComponent&lt;Animator&gt;(); agent =GetComponent&lt;NavMeshAgent&gt;(); if(agent != null) { agentSpeed = agent.speed; } player = GameObject.FindGameObjectWithTag(&quot;Player&quot;).transform; index = Random.Range(0, waypoints.Length); InvokeRepeating(&quot;Tick&quot;, 0 , 0.5f); if(waypoints.Length &gt; 0) { InvokeRepeating(&quot;Patrol&quot;, 0, patrolTime); } } void Patrol() { index= index == waypoints.Length - 1 ? 0 : index + 1; } void Tick() { agent.destination = waypoints[index].position; }} PlayerController.cs代码如下： 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour{ //private Animator anim; private NavMeshAgent agent; // Use this for initializtion void Awake() { // anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); }} 复制Capsule一个，移到Door旁边，重命名为NPC，原来的Capsule命名为Player。 给NPC添加NPCController组件，PlayerController组件虽然暂时用不上，但可以先添加到Player上。 在Hierarchy面板新建一个空Object Waypoint (1)，在Inspector面板修改图标颜色，操作如下图。 复制Waypoint (1)，粘贴自动生成一个Waypoint (2)。把两个Waypoint平移到Floor上方便观察的位置。 选中NPC，点击Inspector面板的锁定面板按钮，同时选中Hierarchy面板的Waypoint (1)、Waypoint (2)拖拽到NPC的NPCController组件下的Waypoints 拖拽Waypoint过来后： 解除NPC的Inspector面板锁定，保存场景，点击Play播放。 我们发现NPC会先自己移动到Waypoint (1)，过了几秒后自己移动到Waypoint (2)，然后回到Waypoint (1)，循环往复。 六、NPC跟踪玩家角色修改NPCController.cs的Tick函数如下： 12345678910void Tick(){ agent.destination = waypoints[index].position; agent.speed = agentSpeed / 2; if(player != null &amp;&amp; Vector2.Distance(transform.position, player.position) &lt; aggroRange) { agent.destination = player.position; agent.speed = agentSpeed; }} 保存后回到Unity编辑器，把NPC的NavMeshAgent组件下的Steering&gt;StoppingDistance设为1.5。 保存场景后点击播放按钮，我们发现，当鼠标点击Floor后，Player移动，NPC跟随在后。","link":"/2020/02/07/Unity%E7%AE%80%E6%98%93%E5%85%B3%E5%8D%A1%E5%8E%9F%E5%9E%8B%E5%BC%80%E5%8F%91/"},{"title":"Unity简易关卡设计","text":"Unity版本：Unity 2018.4.13c1 一、安装ProBuilder和ProGrids开始之前，新建一个场景命名为“Main”，在Assets文件夹下新建一个Prefabs文件夹用于存放预制体。 可以回到之前的SampleScene，将之前创建的Player,NPC逐一拖拽到Prefabs文件夹中。 回到场景Main，开始安装ProBuilder,ProGrids。 首先通过Unity编辑器的菜单栏上的Window，找到并点击打开Package Manager。 切换到All packages，找到ProBuilder，选中点击右侧页面中的Install。 我在Unity 2018.4.13c1 Perconal版本中没有找到ProGrid，需要在进入项目文件夹，在Packages文件夹中找到manifest.json文件，用Notepad++或写字板打开，在dependencies的花括号内添加”com.unity.progrids”: “3.0.3-preview.4”，注意末尾添加英文逗号，保存修改后，回到Unity编辑器会立刻自动安装ProGrids。 以上工具安装完成后，All packages切换到In packages，会找到已安装的工具。 关闭Package Manager，在Unity编辑器菜单栏的Tools，点击ProGrids&gt;ProGrids Window打开ProGrids工具窗口，点击ProBuilder&gt;ProBuilder Window打开ProBuilder工具面板，将其拖拽到和Inspector窗口并列。 二、搭建关卡原型点击New Shape右边的加号，Shape Selector选择Cube点击Build，如果不点击加号，会直接创建Cube。 将Cube位置设置为（0，0，0）。通过ProBuilder我们有4种选中方式来选中Cube。 面选中模式下，我们选中Cube的一个侧面，拖拽与选中面垂直的坐标方向，将Cube拓长12个单位长度。 然后用相同的方法，将Cube拓宽到8个单位长度。 切换到边选中模式，如图选中最中间的线，然后点击ProBuilder面板的Connect Edges。用同样的方法，将Cube划分为四等份。 然后在面选中模式下，我们通过Ctrl快捷键连续选中划分成四等份的侧面中间两份，按住Shift键拖拽拓长10个单位长度。 再次按住Shift继续拓长2个单位长度，再拓长10个长度。可以看到，停顿的地方会有分界线。 然后同时选中尾段（10个单位长度）的两侧，（此时如果坐标轴不在两个面的正中间就点击图中圈起来的Center按钮使坐标系处于正中间，）然后按【R】键切换到比例调节坐标系，使两侧拓宽2个单位长度。 放置阶梯： 最终完成关卡原型如下： 三、配置环境资产 导入文件 在Assets文件夹下新建文件夹Materials、Models、Textures，Models下新建文件夹Environment。 将Unity Fundamentals Source Assets\\Level Assets\\FBX下的所有文件导入到Assets\\Models\\Environment中。 将Unity Fundamentals Source Assets\\Level Assets\\Materials下的所有文件导入到Assets\\Materials中。 将Unity Fundamentals Source Assets\\Level Assets\\Textures下的所有文件导入到Assets\\Textures中。 以上文件由美术工作人员制作好。 调整材质 进入Materials,选中Banner，Shader选择Standard(Specular setup)，要批量改变Shader，则同时选中，然后再再Inspector面板里改Shader。此处我们把剩下的材质球全部选中把Shader设置为Standard(Specular setup)。 接下来选中Barriers，锁定Inspector面板，进入Texture文件夹，把Barriers 01 Diff.tga拖拽到Inspector面板下的Main Maps&gt;Albedo，Albedo指反射率贴图，主要体现模型的纹理和颜色。通常适合放入含有单词Albedo或BaseColor（少数情况Diff或Diffuse）的tga文件。 把Barriers 01 Spec.tga拖拽到Albedo下方的Specular，把Barriers 01 Norm.tga拖拽到Specular下方的Normal Map，把Barriers 01 occlusion.tga拖拽到Occlusion，把detail normal.png拖拽到Secondary Maps&gt;Normal Map。 同理把，把剩下的Bridge、Broken_Bridge、Door、Floor_01、Floor_04、Lantern、Pillar、Stairs、Statue、Wall_01、Wall_02、Wall_03、WoodenPlank全都配置好。其中Door的Emission&gt;Color需要放入Door 01 emiss.tga。 配置Banner有些不同，即将Flag 01 Diffuse.tga放到Albedo，Flag 01 normals.tga放到Normal Map，Flag 01 occulsion.tga放到Occlusion。 配置材质到模型 进入Models/Environment,选中Barrier 01.FB。在Inspector面板中点击Materials，勾选Import Materials，在Remapped Materials&gt;Standard_20 点击最右侧的圆圈按钮打开材质选择窗口，选择Barriers，点击Apply。 同理，把Barrie_02、Barrier_03、Bridge_01、Broken_Bridge_01、Broken_Bridge_02、Broken_Bridge_03、Broken_Bridge_04、Broken_Floor_01、Door_01、Door_02、Door_03、Door_04、Flag_01（用Banner）、Floor_01（用Floor_01）、Floor_02（用Floor_01）、Floor_03（用Floor_01）、Floor_04（用Floor_04）、Floor_05（用Floor_04）、Floor_06（用Floor_04）、Lantern、Pillar_01、Pillar_02、Pillar_03、Pillar_04、Stairs_01、Statue_01、Wall_01、Wall_02、Wall_03、Wooden_Plank_01、Wooden_Plank_02都配置好。 五、创建环境预制体六、照明菜单栏的Window &gt; Rendering &gt; Lighting Settings，打开Lighting窗口，拖拽并dock到Inspector窗口旁边。 修改Lighting窗口下的Skybox Material，将默认改成BlackSky，使环境全黑。 选中Directional Light，在其Inspector窗口 &gt; Light &gt; Color，将颜色自定义成淡蓝偏灰的颜色色（冷色）。 在场景中创建四个Point Light并把它们放置到关卡中四个Lantern上，把它们的颜色都设置成浅橙色（暖色）,调高Intensity，这里设置成3。Range（光照范围）设置为6。根据需要设置Shadow Type，这里设置为No Shadows。 烘焙照明，选中Environment，勾选其Inspector面板的Static，（如果询问是否改变子项，选择确认）。 来到Lighting窗口，确保Realtime Global Illumi勾选，Baked Global Illumi勾选，然后点击下方Generate Lighting按钮或者勾选Auto Generate。 等待一段时间直到烘培完成（烘培时间取决于计算机硬件性能）。减小Lightmapping Settiing &gt; Lightmap Size的大小可以稍微加快烘培速度（此处我设置为256）。 烘焙好照明后，我们给关卡添加Reflection Probe（Hierarchy窗口 &gt; Create &gt; Light &gt; Reflection Probe）。 调节大小至包围（捕获）地形如图： 通过快捷键Ctrl+D快速复制粘贴一份，然后拖动包围旁边的桥（Reflection Probe之间重叠也没关系） 然后再Lighting窗口 &gt; Other Setting &gt; Generate Light下三角 &gt; Bake Reflection Probes。烘焙Reflection Probes完成后地形的部分阴影会稍微变淡。 七、粒子系统创建粒子系统：Hierarchy &gt; Create &gt; Effects &gt; Particle System 详细调节： Inspector &gt; Particle System &gt; Particle System Duration: 1.50 Looping: ✔ Prewarm: ✔ Start Lifetime 点击右边小三角 &gt; Random Between Two Constants Start Lifetime: 10, 15 Start Speed: 0.1, 0.5（Random Between Two Constants） Start Size: 20, 30（Random Between Two Constants） Start Rotation: 0, 360（Random Between Two Constants） Start Color: 深蓝色 Max Particles: 100 点击Particle System可最小化，这时可以看到Emission, Shape等其他可调节项目。 Emssion:✔ Rate over Time: 30 Rate over Distance: 0 Shape:✔ Shape: Box Emit from: Volume Scale: X=125, Y=75, Z=10 设置好后调整粒子系统再场景中的位置使其笼罩整个地形 Color over Lifetime:✔ Color: Alpha=0, Location 100.0% 如果没有显示Alpha则，拖动一下第一排标尺。 Size over Lifetime:✔ Size：先将起点拖动到0.800，然后起点旁边的白点稍微往上拉一点。 点击曲线的另一端（红点），这时旁边出现一个白点，向上拉动，使红色曲线接近直线。 Rotation over Lifetime: ✔ Angular Veclocity: -5, 5 (Random Between Two Constants) Render: ✔ Normal Direction: 0.7 Assets/Materials下新建一个材质，取名GlobalFag，其Shader改成Legacy/Shaders/Particle/Additive(Soft)。 再Assets/Texture下导入Unity Fundamentals Source Assets\\Level Assets\\VFX下的ParticleCloudWhite.png，然后给GlobalFag的Texture选择ParticleCloudWhite。 回到Particle System，Renderer &gt; Material选择GlobalFag。 然后回到Lighting窗口点击Generate Lighting 八、创造光条纹Hierarchy &gt; Create &gt; Effects &gt; Line Line &gt; Inspector &gt; Line Render &gt; Cast Shadows改为Off。 再Assets/Material下新建材质，命名为Streak。 Streak &gt; Inspector &gt; Shader改为Legacy Shaders/Particles/Additive Particle Texture选择Default-Particle Line &gt; Inspector &gt; Line Renderer &gt; Positions &gt; Index 1 Z=25, 拖拽Width到10 修改颜色成由黑过渡到蓝 Line Renderer &gt; Materials &gt; Element 0改成Streak 给Line添加Light组件，并且将Light &gt; Type改成Spot Light &gt; Range设置为20，Color设置为浅蓝色，Intensity设置为接近接近20（这里设置为18.23），Cookie选择ParticleCloudWhite，Shadow Type设置为Hard Shadows 点击Cookie旁边的ParticleCloudWhite，再Assets/Textures找到ParticleCloudWhite，将其Advanced &gt; Wrap Mode改为Clamp 调整角度，使光照射再门上： 给Line改名为Moonlight，保存到Assets/Prefabs/VFX下（拖拽过去）。我们还可以给场景其他地方添加Moonlight: 九、创建环境音乐在场景中新建一个空Game Object，取名AudioManager，为其添加组件Audio Source。 在Assets文件夹下新建一个Audio文件夹，向里边导入Unity Fundamentals Source Assets\\Audio下的两个音频文件：ForestNight Amb Lp.wav、Torch Lp.wav 选中AudioManager，将ForestNight Amb Lp.wav添加到Audio Source组件 &gt; AudioClip，勾选Loop，稍微降低Volume（音量）。 播放游戏，可以听到环境音乐。 十、后期处理打开Unity菜单栏Window &gt; Package Manager，安装Post Processing插件。 在Hierarchy窗口新建一个空Game Object，命名为PostProcessing，为其添加组件Post Process Volume(Script)，勾选其属性Is Global（这个属性可以影响游戏整个画面），点击Profile旁边的New创建新的Profile。 给Main Camera添加组件Post Processing Layer(Script)，属性Anti-aliasing &gt; Mode设置为Fast Approximate Anti-aliasing(FXAA)。Main Camera的Layer设置为PostProcessing。 选中PostProcessing，Layer设置为PostProcessing，在其Post Processing Volume(Script)组件下点击Add effect &gt; Unity &gt; Vignette。展开Vignette，点击All勾选下方全部属性。从Game窗口观察游戏场景，当我们调解Vignette &gt; Intensity时，可以产生让我们的目光聚集在画面中央的效果。 点击Add effect按钮添加Unity &gt; Bloom，勾选其下方所有属性，观察Game画面适当调解Intensity。 点击Add effect按钮添加Unity &gt; Chromatic Aberration，勾选其下方所有属性，观察Game画面适当调解Intensity。 点击Add effect按钮添加Unity &gt; Color Grading，勾选其下方所有属性，观察Game画面适当调解Trackball以改变画面色调。 我们还可以添加Unity &gt; Grain，继续调解画面，这些后期处理可以改善游戏画面，但也会消耗计算机性能，移动端或低配PC不建议过多调节。","link":"/2020/02/13/Unity%E7%AE%80%E6%98%93%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1/"},{"title":"Unity载入界面基础","text":"Unity 版本：Unity 2018.4.13c1 Personal 一、创建用户界面元素新建一个场景，命名为MainMenu。删掉Directioinal light，切换为2D视角。 再Lighting窗口，设置Scene &gt; Environment &gt; Environment Lighting &gt; Source为Color，Amibient Color为黑色，Skybox material设置为None(Material)。 再Hierarchy窗口创建 &gt; UI &gt; Canvas 再Game窗口下把分辨率由Free Aspect改为16：9 再Canvas下新建 &gt; UI &gt; Text - TextMeshPro，首次新建会弹出导入TMP必备窗口，点击Import TMP Essentials，导入完成后关闭窗口即可。 然后重命名TextMeshPro为TitleText，再其Text Mesh Pro UGUI(Script)组件 &gt; Text自定义文本写上游戏名“Sword and Shovels”，在该组件 &gt; Main Settings可以修改字体。我们勾选Font Size &gt; Auto Size，这时字体大小将随文本框大小改变而自动调节。通过Aligment右边的按钮可以调节文本对齐居中等。 再Canves下新建 &gt; UI &gt; Button，将Button下的Text删掉，再Button下新建Text - TextMeshPro，调整好之后如下图： 播放游戏，画面中Play按钮可以点击。 二、编写场景切换脚本再Hirarchy窗口新建空Game Object，重命名为SceneSwitcher。再Assest/Scripts下新建SceneSwitcher.cs，用VS2017打开，编写代码如下： 123456789101112using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class SceneSwitcher : MonoBehaviour{ public void SceneSwitch() { SceneManager.LoadScene(1); }} 回到Unity，给SceneSwitcher添加Scene Switcher(Script)组件。 选中Canvas/Button，在On Click()下添加点击事件，将SceneSwitcher拖拽进来，函数选择SceneSwitcher &gt; SceneSwitch()。 保存MainMenu场景，然后点击菜单栏File &gt; Build Settings，在Build Settings弹窗点击Add Open Scenes把MainMenu添加进去，然后将Assets/Scenes下建好的Main01场景拖拽添加进来。 播放游戏，开始进入MainMenu场景，当我们点击Play后，进入Main01场景。","link":"/2020/02/17/Unity%E8%BD%BD%E5%85%A5%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"},{"title":"Win32窗口","text":"一、创建项目 开发软件：VS2017 新建项目 &gt; Visual C++ &gt; Windows桌面 &gt; Windows桌面向导，填好项目名，项目路径后，下一步，选择“桌面应用程序(.exe)”，勾选“空项目”，点击确定。 PS：在VS2013、2015中，窗口程序叫”Win32项目“，在VS2017、2019中叫做“桌面应用程序”。 二、在线搜索API网址：https://docs.microsoft.com/zh-cn/ 头文件：windows.h文件是win32 API的主要头文件，首字母大小写都行。 主函数WinMain：是main函数的一个自定义函数，在底层由main函数调用它。 右键函数名，选择“转到定义”可以查看函数的具体定义。 返回值为int类型。 调用约定 WINAPI 作用：决定函数名字编译方式、参数入栈顺序、函数逻辑调用时间 参数：由系统传递供我们使用 HINSTANCE hInstance：实例句柄，当前软件运行时，系统分配给的唯一ID，int类型。 HINSTANCE hPreInstance：前一个实例句柄，即前一个打开的软件的句柄，值为NULL，功能名存实亡。 LPSTR lpCmdLine：命令行参数，main函数传递到WinMain函数的参数，类型为char*， PS：P或LP开头的转义变量类型均为指针类型 int nShowCmd：窗口显示方式，默认是窗口正常显示，值为1 SAL：微软源代码注释语言（8个） 功能：提醒编译器帮我们检查函数参数可能存在的问题，避免这些问题在运行时爆发。 SDL：安全开发生命周期 三、 WNDCLASS：窗口类（类是结构体的拓展） WNDCLASSEX：拓展版本的窗口类","link":"/2020/01/29/Win32%E7%AA%97%E5%8F%A3/"},{"title":"【GDC】Designing Unforgettable Titanfall Single Player Levels with Action Blocks","text":"How to Action BlocksAction Blocknoun A form of rapid prototyping used to encourage creative play ‘Game jam’ style design sprints used throughout development to explore gameplay Common slang for reaching the highest level in Tetris One Week (or less) - Mostly Single Designer - Mostly Must Have a Skill Test No Skits or Cool Moments No Context Necessary - But not discourage Make it Playable - Mostly Show &amp; Tell Freeform Exploration! Make a Roadmap Create a Library Set Boundaries Defining Moment Going Deep Into the Abyss Abstract Thematic Exploration Kill Your (metaphorical) Babies Quick Mash-ups The Grand Rebeal One-upmanship Production Bloat Contextualization Action Blocks are not Level Design","link":"/2020/01/08/%E3%80%90GDC%E3%80%91Designing%20Unforgettable%20Titanfall%20Single%20Player%20Levels%20with%20Action%20Blocks/"},{"title":"sys模块和os模块","text":"初识sys模块和os模块 sys模块12345678910111213import sys&quot;&quot;&quot;先到当前目录下找sys模块，因此py文件起名最好不要和标准库名相同sys.path返回sys模块的所有目录(以Python3.6为例)Python的第三方库一般保存在Python36/Lib/site-packages下，标准库一般存放在Python36/Lib下&quot;&quot;&quot;print(sys.path)#打印环境变量print(sys.argv)#在pycharm中运行打印sys_mod.py的绝对路径#在命令提示符窗口中运行打印sys_mod.py的相对路径print(sys.argv[2])#在命令提示符窗口中运行打印sys_mod.py的相对路径以及第2个参数 os模块1234import oscmd_res = os.system(&quot;dir&quot;) #执行命令，不保存结果print(&quot;---&gt;&quot;,cmd_res) 运行后 左下角的代表os.system(“dir”)执行成功返回的状态码，“0”表示成功，非“0”表示失败。 12345678910import oscmd_res = os.popen(&quot;dir&quot;).read()&apos;&apos;&apos;为什么加read()?因为执行完os.popen(&quot;dir&quot;)后，结果存在内存的一个临时区域，需要用read()方法把结果取出来。&apos;&apos;&apos;print(&quot;---&gt;&quot;,cmd_res) 运行后 12import osos.mkdir(&quot;new_dir&quot;)#在当前目录创建一个文件夹运行后","link":"/2019/03/20/sys%E6%A8%A1%E5%9D%97%E5%92%8Cos%E6%A8%A1%E5%9D%97/"},{"title":"【GDC】Level Design Workshop：Blockmesh and Lighting Tips","text":"Invisible Intuition：Blockmesh and Lighting Tips to Guide Players and Set the MoodWhat is “Blockmesh” ? Blockmesh = Greybox = Whitebox, etc. Greybox and Whitebox implt a single color - not ideal! 灰盒和白盒一般只有一种颜色，不够理想 Level Design Pipeline graph LR A(Level Requirements) --&gt; B(Build Blockmesh Layout 搭建Blockmesh布局) B --&gt; C(Playtest Layout 测试布局) C --&gt; D(Process Feedback 处理反馈) D --&gt; B Environment Type 环境需求 Time of Day 当日时间 Location in Story 故事地点 Available Character Abilities 允许玩家使用的能力 Enemy Type 敌人种类 etc. Gameplay and Narrative Beats 游戏性以及叙事性的节拍 Affordance 可见性 Form implies function 形式暗示着功能 Affordance … in Games A way to communicate to the player what to play with or where to go. 一种告诉玩家玩什么或到哪去的方法 Players learn the affordance rules via consistent color and shape and a trust contract is formed. 玩家通过相同的颜色和形状来学习可见性规则，同时信任该规则 Ensure affordances work consistently game-wide. 确保可见性规则在游戏内保持一致 Add to your blockmesh for playtests! 在游戏测试中添加到你的blockmesh中 Denying Affordance 拒绝式可见性 Communicates to the player where NOT to go. 告诉玩家不能去的地方 “Uninvites” the player from going there. 不允许玩家去哪 Contextualize why the player can’t use it/go there! 根据情境告诉玩家为什么不能使用某物或去某地 Add to your blockmesh for playtests! 在游戏测试中添加到你的blockmesh中 Visual Language - Shape 绿色圆形代表安全 黄色矩形代表稳定、实用 红色三角形代表危险 Landmarks (aka weenies) 地标 Orients Players. 引导玩家 Distant object seen from many vantage points in the level. 从关卡的许多视角都能看到 A goal to work toward. 一个努力前往的目标 Openings Attract 开放式吸引 Caves, doors, archways拱门, etc. Often leads to a REFUGE SPACE, which psychologically feels safe. 通常导向一个心理上感到安全的避难所 Mystery神秘感 - “What could be inside?!” Gates &amp; Valves Gates stop progress until conditions are met. 在满足条件以前，门不会打开 Valves prevent backtracking. Both reduce the possibility space and prevent aimless wandering瞎逛. Great for linear games, but can be sprinkled运用 into open worlds too! Leading Lines 引导线 Lines that draw your eye to the intended point of interest. Roads, pipes, cables, etc. Pinching 挤压视线 Angle shapes to funnel players to a specific spot.利用角度吸引玩家到特定地点 Good for redirection. 适合重新引导 Great for setting up a reveal. 非常适合设置展示 Depends on your mobility mechanics! 根据你的移动机制 Framing &amp; Composition 框架以及构成 Draws attention to point of interest by blocking other parts of the image, making it stand out. Google photography composition techniques - lots of good websites! Great when combined with Pinching! Breadcrumbs 面包屑 Attract/lead the player, a piece at a time, to a goal.一点点引导玩家到目的地，可以是任何能博眼球的东西 Can be almost anything that draws the eye: Stuff that breaks up the negative space of floor/walls. 打破地板的东西 Pickups 可以捡起的东西 Enemies 敌人 Lit areas 明亮的区域 Usually better to add after early playtests of blockmesh to see if they are even needed. 最好在早期的游戏测试之后，根据需要添加 Textures 材质 just point the way to go! Examples: Arrows pointing the way. Scrapes on the ground/walls. 地上或墙上的抓痕 Signs 标记 etc. Movement Use movement to grab the eye. Examples: Big scripted moments. 大型脚本 Birds Spark FX 火花特效 Enemies Something flapping in the breeze 微风中漂浮的东西 Directionality guides the eye to where you want players to go or what you want them to see. Light &amp; God Ray 光照以及光线 Players are attracted to the light. God rays draw attention and a line to the goal. Important in blockmesh phase阶段! Bonus Tips！——The Squint Test 眯眼测试 Step 1: Squint眯 your eyes and look at the game. Step 2: Everything wil be blurry模糊, but what stands out? Step 3: Adjust your layout布局 and lighting光源 to highlight强调 what you want players to focus on.","link":"/2020/01/08/%E3%80%90GDC%E3%80%91Level%20Design%20Workshop%EF%BC%9ABlockmesh%20and%20Lighting%20Tips/"},{"title":"【知乎Live】欧美3A游戏公司的游戏设计与制作","text":"主讲人：Clark 杨佳阳 https://www.zhihu.com/lives/787986309099560960 AAA项目的团队组成是什么样子？ 团队之间的职能细化如何？ AAA游戏的制作过程是什么样子？ 不同公司团队之间的开发流程，组别在哪里？ 行业前景如何？ 问答环节 一、关于设计的问题1. 立项前要进行很详细的市场调查什么样的游戏可以赚钱？什么样的游戏更容易打开市场？什么样新的IP可以立足于市场？总部、市场部、总部设计主管、团队设计主管进行大量的讨论、分析，然后做出一个详细的大框架（PPT一页纸概括）。比如说，我们要做一个游戏有40个小时的游戏时长，不希望这个游戏一个周末就可以打完。游戏的历史背景，我们要做第三人称，我们是否要做射击、格斗？必须要有RPG养成要素？ 2.做一个highlevel的宏观的设计方向（做target footage）用3DMax/Maya做一个假的游戏设想的视频，要透露出游戏的玩法、美术风格、整个游戏格调。视频要在5~10分钟把这个游戏讲得很明白。 回到总部，与市场部协调，看看这个假的游戏是否符合初衷。如果市场稳定，这个游戏有前景，基本可以协调通过且拿到后续的资金。如果这时候市场有变动就需要调整，即回炉重来。如果这一阶段有问题，说明初衷是错误的。 3. pre-production阶段进行大量的原型设计（prototype），占80%~90%的时间，最有趣，最困难的时期。每个人都有很多想法，比如说我想做成实时加载，每一个NPC都会有介绍等，完全天马行空，但由于时间问题技术问题，很多东西做不出来，因为需要大量的程序资源和大量的美术资源加进去。对于设计来说，这个阶段最自由，可以把很多想法比如5年前10年前的想法用最快的方法做出来。在这个阶段，每个项目的总监（创意总监、游戏性总监）需要承担很大的责任，因为不可能让所有人都去随便做自己想做的东西，这很浪费时间。因此，需要反复看原型，看是否会做成最终成品。原型阶段没有大量资源，这个雏形一定非常丑，达不到可以发售的质量。我们必须分析出哪些丑陋的“小孩”（原型）以后可以长成“大美女”（高质量成品）。这很关键，如果我们能选择出真正有潜力的feature（特征）、功能，这对后边的production有很大帮助。 花一年时间都不算长，因为很多尝试性的东西，不仅是设计上的尝试，还有技术上比如引擎需要完善，美术的一整套要完善，动画甚至最基本的面部表情技术也要达到很稳定阶段。否则后边production阶段会非常头疼。 在pre-production结束时把假的游戏做成真正可以玩的2示（demo），把演示拿给市场部、宣传部、给公司大佬们看，然后重新从方向上从底层设计上是否合格，最初的设计可能因为市场变化变成错误的，这个阶段需要决定什么需要改，什么可以继续往下做。如果演示大家都很认可，就可以进入Production。 这个演示可能只有20分钟到1个小时的gameplay。在进入Production阶段前，其他部门也要做好准备，比如：第一，在设计上在这一阶段最好的情况是所有的细节所有的功能至少在纸面上都已经设计好了；第二，引擎逐渐完善，如何动态加载，如何管理这些内存，一系列type上的东西都需要准备好。美术上，我们要做多大的地图，能够做多大的地图，团队应该如何分配，这一系列问题，都需要准备好。实际中很普遍地是，很多项目的准备都没来得及做好。很多东西在production开始之前没有答案，因此production时需要冒一些风险,在production中把一些东西完善掉。虽然这种情况经常出现，但因为我们知道游戏要往哪里走，知道要做些什么，风险可以控制。 4. Production（半年到一年之内全部完成）大军推进，美术设计、关卡设计、动画、人物等各部门全部开始大规模production，速度非常快，工作量非常大，非常无趣。游戏的feature（特征）、content（内容）全部做完以后进入alpha阶段。 5. alpha阶段（花3个月到半年）开始debug，QA（游戏测试、质量保证）大面积进入。很多时候还是要修改一些东西，发现当初设计的东西有些事不完善的，需要重新改。因为所有资源都已经存在，改起来更容易。游戏可能会在这个阶段发生翻天覆地的变化。 6. beta阶段大部分团队不再工作，他们可能去休假或者去新的项目。需要一个closing team，完完全全是在修bug，一个一个修。能够留下来去close这个项目的人都非常强 7. master阶段游戏做完，项目结束。 二、问答环节1. AAA团队有哪些人构成？市场部、运营部、创意总监、游戏总监、美术总监、技术总监 2. 团队协作方式，怎么管理创意？每个团队都有自己管理创意的方式，不能一概而论，大部分创意总监会倾向于独裁，只是看独裁到什么程度。 每一个人都有想法，AAA最头疼的问题是如何让很多人做同一款游戏。太民主永远达不到一个统一的风格，需要一个创意总监拿主意拍板。 设计上选择千万不要去猜！做决策，管理团队，必须需要有很强大的数据做背景来支持，知道什么样的游戏有前景什么样的游戏赚钱，不能靠拍脑袋决定。 美术细节需要多个工作组和总监协调出来。 做游戏，需要沟通，大部分时间都在说话，大部分坐着的都是美工。大方向以及细节需要总监决定。 3. 单机游戏中storytelling和gameplay如何结合？首先要根据游戏要做成什么样子，顽皮狗工作室的游戏gameplay为story服务，其他一些游戏gameplay比story更注重。在一个游戏在最开始确定方向以后，我们就会知道这个游戏是更注重故事还是游戏性，如果注重游戏性，故事会在开发中进驻很晚。一般在production进行到一半，游戏界面成型的时候，故事才进来把游戏串起来。如果完完全全是一个讲故事的游戏，在production之前没有一个完整的gameplay，但但故事流程从a到z全部都是完善的，然后根据故事需要去设计需要什么样的游戏性。 4. 策划需要的参考大部分来源？Google、YouTube。如果找不到参考，策划和设计、美术、动画在一个会议室里在一块黑板之前画简笔画，用简单的语句表达你想要的是什么。 原型快成型的时候撰写文档，把细节让其他部门去做。 5. 关卡设计细节问题关卡细节问题可大可小。关卡设计很大程度上需要去协调各个部门。把所有零件拼在一起的重要工作。 一定是先确定核心玩法，谜题机制，再确定关卡设计！ 原型设计阶段需要有一个惯性：每一个人有一个想法时，第一版一定是丑的，有没有动力有没有能力在很快的时间之内（一两天内）找到问题解决问题，把它做得更好，这个原型就有一个惯性，当惯性能够保持住时，这个原型到最后的结果就比其他原型好，要重复验证需要时间，第一版花一到两周，然后在一两天必须看到新的版本。如果在一个月之内看不到这个原型有很强的的生命力，或惯性的话，一般情况下这个原型是失败的。 6. 团队和周期：例子：育碧蒙特利尔随随便便一个项目上1000人，要在各个工作室的协调之中完成。 分工：从团队机构上：最上头：创意总监，游戏总监、美术总监、技术总监、关卡总监、动画总监 总监之下：游戏设计师、系统程序员（引擎）、gameplay程序员（gamplay逻辑）、音效程序员、网络程序员、关卡设计、任务设计、世界观设计、动画设计，动画美术、镜头师等 成本：很容易上5000W 国外制作人（producer）只管资金和工作进度，还有管理人员之间沟通问题，不管也不可以插手游戏设计。 所有的项目都会延期，游戏太庞大，火箭级别的项目。 周期：短的2年，长的4~5年（特别是新IP） 延期风险怎么解决？ 大的延期，制作人和总监能很早预测到，预测完不成就提前去和团队协调，砍掉一些内容。 每当遇到危机都需要方向上的调整，需要看制作人和总监的能力力挽狂澜。 其他： AAA项目非常难做，涉及大量资金大量人员，团队少则一两百人，多则上千人。 1亿美金的项目，需要卖到500万份才能回本，每份开发者只赚20美金，其他利润归物流，零售商、发行商。 没见过好的项目不加班的。 经常加班，每天工作14小时，项目完结有假期，一年三周。 进入production以后，文档的效率非常低，没有必要改文档，大家没有时间看，要改直接交流沟通。 设计者只是设计了规则，玩家在规则中达到自己想要的。","link":"/2020/01/08/%E3%80%90%E7%9F%A5%E4%B9%8ELive%E3%80%91%E6%AC%A7%E7%BE%8E3A%E6%B8%B8%E6%88%8F%E5%85%AC%E5%8F%B8%E7%9A%84%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%B6%E4%BD%9C/"},{"title":"代码注释 & 终端输入 & if_else","text":"Python代码注释及其应用 当前行注释：1# print(&quot;hahaha&quot;); 多行注释：123456789&quot;&quot;&quot;name = &quot;maxwell&quot;;print(&quot;maxwell&quot;);&quot;&quot;&quot;或&apos;&apos;&apos;name = &quot;maxwell&quot;;print(&quot;maxwell&quot;);&apos;&apos;&apos; 终端输入例子:12345name = input(&quot;username：&quot;)password = input(&quot;password:&quot;)age = int(input(&quot;age:&quot;))job = input(&quot;job:&quot;)salary = float(input(&quot;salary:&quot;)) input()函数返回结果属于字符串类型！ 补充： Python 3.x里的input()函数功能与Python 2.x里的raw_input()功能相同 Python 2.x里的input()需要传入的是变量 打印动态多行注释：12345678info=&apos;&apos;&apos;---------- info of %s -----------Name: %sAge: %dJob: %sSalary: %f&apos;&apos;&apos; % (name,name,age,job,salary) #记得加括号！#print(type(age),type(salary))print(info) 12345678910info2 = &apos;&apos;&apos;---------- info2 of {_name} -----------Name: {_name}Age: {_age}Job: {_job}Salary: {_salary}&apos;&apos;&apos;.format(_name=name, _age=age, _job=job, _salary=salary)print(info2) 1234567info3 = &apos;&apos;&apos;---------- info3 of {0} -----------Name: {0}Age: {1}Job: {2}Salary: {3}&apos;&apos;&apos;.format(name,age,job,salary)print(info3) 不到万不得已，不要用“+”拼接字符串，效率很低。 密码输入：12345678910111213141516171819202122232425262728import getpass#getpass模块可实现暗文输入密码功能name = input(&quot;usename:&quot;)password = getpass.getpass(&quot;password:&quot;)#pycharm下运行会卡在此句，建议在命令提示符窗口运行此脚本#getpass.getpass()返回的变量类型是字符串info = &apos;&apos;&apos;----- info -------username: %spassword: %s&apos;&apos;&apos;% (name,password)#记得加括号！print(info)info2 = &apos;&apos;&apos;----- info2 -------username: {_name}password: {_password}&apos;&apos;&apos;.format(_name=name,_password=password)print(info2)info3 = &apos;&apos;&apos;----- info3 -------username: {0}password: {1}&apos;&apos;&apos;.format(name,password)#注意在对应变量的位置大括号print(info3) if_else例子：12345678910_usrname = &apos;Mingjun Wei&apos;_pwd = 123456 #int型变量usrname = input(&quot;name:&quot;)pwd = int(input(&quot;password:&quot;))#注意转变量类型，input()返回字符串类型if _usrname == usrname and _pwd == pwd: print(&quot;Welcome {usrname} login ...&quot;.format(usrname=_usrname))else: print(&quot;invalid username or password!&quot;)","link":"/2019/03/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5/"},{"title":"【GDC】Platinum Games：Action Without Borders","text":"What is an Action Game? A set of actions responding to output 一系列针对输出的动作 Passive activity 被动行为 This sounds like the exact opposite of action Activity based on prior (active) input Adventure/Horror games This is opposite to the impression horror games give off What are “action skills”? The player’s ability to deal with a given situation Gameplay Systems What are gameplay systems? The selling point of a game The unique elements that define a game Expanding features Lateral expansion to prevent games from becoming too linear Depth If a game has selling points A/B/C, expanding features D/E, and depth elements F/G: Players complete the game having experienced A and B They’ve completed and enjoyed the game Players complete the game having experienced A,B, and C They’ve completed the game and feel like they got a lot of it Players complete the game having experienced A,B,C and D They’ve complete the game, and become good at it in a variety of ways Players complete the game having experienced A,B,C,D and E “Wow! I didn’t know you could do that! This game is awesome!!” Players complete the game having experienced A,B,C,D,E and F “I am a god among mortals!” How to approach the selling points of an action game It’s not about functional design The question “What abilities shall we give the player?” never comes first It’s about situational design The first thing to figure out is: “What kind of situations do we put the player in, and what are we going to make them do?” One more important things about the design of selling points: When creating a game in a series, you already have an existing ability set to work with ,so: It’s easy to fall into the trap of changing A to A’ or A+B, but this is a mistake Always give top priority to situational design Replay Value What is replay value? The point is not to force the player to keep playing Replay value has to be linked to fun activities It’s essential that the player get to imrove their skills This requires a structure that lets the player enjoy all of elements A,B,C,D,E, and F Make the game feel like it was tailor-made for the player 让游戏感觉像是为玩家量身定做的 Characters Action games let players enjoy a character’s superpowers Fulfilling the desire to transform This requires main characters with rich personalities Fight your way through any situation The order of designing unique characters with superpowers Imagine the situation Create an image board Design the game’s selling points Functional design Start designing the characters Character art design directly and strongly affects the user experience Story What purpose does story have in an action game? The most important purpose is “Motivation” Deep stories with lots of twists are not required 不需要有很多曲折的故事 The story should turn the designed situation into motivation in a natural way 故事应该以自然的方式将设计好的情境转化为动机 High-level Design Not the same as level design Considering the game flow in the largest possible unit 思考可能最大的游戏流程单位 Simply bombarding players with constant excitement become numbing after a while 仅仅持续性使玩家兴奋，会使玩家过一会儿就对兴奋点麻木 Create a tempo per stage 每个关卡制造一个节奏 Pacing is very important 节奏很重要 Stage “Strength” 关卡强度 关卡序号 设置强度（1-10） 玩家感受 St. 1: 6 7 St. 2: 4 4 St. 3: 6 5 St. 4: 7 8 制作成本：6+4+6+7=23 制作效果：7+4+5+8=24 Stage “Strength”(example of failed build-up) St. 1: 5 6 4 St. 2: 6 5 5 St. 3: 7 5 5 St. 4: 8 6 4 5+6+7+8=26 4+5+5+4=18 With Transformers we focused on density We didn’t want players to put down the controller Summary","link":"/2020/01/08/%E3%80%90GDC%E3%80%91Platinum%20Games%EF%BC%9AAction%20Without%20Borders/"},{"title":"刷《算法笔记》小结习题，写代码常犯的错误","text":"问题 E: 例题3-5 求一元二次方程的根题目描述求一元二次方程ax2+bx+c=0的根，三个系数a, b, c由键盘输入，且a不能为0，且保证b2-4ac&gt;0。 程序中所涉及的变量均为double类型。 输入以空格分隔的一元二次方程的三个系数，双精度double类型 输出分行输出两个根如下（注意末尾的换行）：123r1=第一个根r2=第二个根结果输出时，宽度占7位，其中小数部分2位。 样例输入11 3 2 样例输出12r1= -1.00r2= -2.00 自写答案：1234567891011121314#include&lt;cstdio&gt;#include&lt;cmath&gt;int main(){ double a, b, c, r1, r2; scanf(&quot;%lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c); if((a != 0) &amp;&amp; (pow(b,2.0)-4*a*c &gt; 0)){ r1 = ((-b)+sqrt(pow(b,2.0)-4*a*c))/(2*a); //注意sqrt()容易写错成sqrt() r2 = ((-b)-sqrt(pow(b,2.0)-4*a*c))/(2*a); printf(&quot;r1=%7.2f\\n&quot;, r1); //打印的结果占7位，其中小数部分占2位 printf(&quot;r2=%7.2f&quot;, r2); } return 0;}","link":"/2019/08/23/%E5%88%B7%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E5%B0%8F%E7%BB%93%E4%B9%A0%E9%A2%98%EF%BC%8C%E5%86%99%E4%BB%A3%E7%A0%81%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/"},{"title":"如何设置Win10右键打开CMD","text":"转载出自：https://blog.csdn.net/itas109/article/details/86618799 将如下代码保存为*.reg的注册表文件，双击运行 1234567Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\cmd_here]&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\cmd_here\\command]@=&quot;cmd.exe /s /k pushd \\&quot;%V\\&quot;&quot; 效果：","link":"/2020/01/23/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEWin10%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80CMD/"},{"title":"在Win 10中使用命令行界面编译、运行一个cpp文件","text":"源文件准备新建一个文件取名hello.cpp，代码如下：123int main(){ return 0;} 编译器准备Visual C++组件包含一个C++命令编译器，这个编译器还可用于创建基本的控制台程序、通用Windows平台程序、桌面程序、设备驱动和.NET组建。 从微软的Visaul Studio官网下载Visual Studio Community 2017。 安装过程中注意勾选“Desktop development with C++” 打开开发者命令提示符点击“开始”菜单，在程序列表找到并点击Visual Studio 2017文件夹下的“VS 2017的开发人员命令提示符” 输入如下命令以验证VC++的开发者命令提示符已设置妥当：1cl窗口会反馈如下： C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community&gt;clMicrosoft (R) C/C++ Optimizing Compiler Version 19.15.26732.1 for x86Copyright (C) Microsoft Corporation. All rights reserved. usage: cl [ option… ] filename… [ /link linkoption… ] 编译cpp源文件安装完编译所需的工具后，在开发者命令提示符界面中输入命令，将当前目录切换到源代码文件所在的目录。 12d:cd d:\\ProgrammingLearning\\cpp 输入以下代码编译源文件： 1cl /EHsc hello.cpp 窗口反馈如下，则表示编译成功： Microsoft (R) C/C++ Optimizing Compiler Version 19.15.26732.1 for x86Copyright (C) Microsoft Corporation. All rights reserved. hello.cppMicrosoft (R) Incremental Linker Version 14.15.26732.1Copyright (C) Microsoft Corporation. All rights reserved. /out:hello.exehello-world.obj 运行程序成功编译后在命令行界面执行命令：1hello 程序顺利执行，通过echo命令获取main函数的返回值(0)。 1echo %ERRORLEVEL%","link":"/2019/07/05/%E5%9C%A8Win%2010%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAcpp%E6%96%87%E4%BB%B6/"},{"title":"如何用Markdown画流程图","text":"用Markdown画流程图可以用mermaid，mermaid支持三种图形的绘制, 分别是流程图, 时序图和甘特图 一、如何在markdown中使用mermaid ‘’’mermaid graph 流程图方向 流程图的内容‘’’ 流程图方向有以下几个值： TB 从上到下 BT 从下到上 RL 从右到左 LR 从左到右 TD 同TB例子 123mermaidgraph TD A --&gt; B graph TD A --&gt; B 123mermaidgraph LR A --&gt; B graph LR A --&gt; B 框图的基本边框 id + [文字描述]矩形 id + (文字描述)圆角矩形 id + &gt;文字描述]不对称矩形 id + {文字描述}菱形 id + ((文字描述))圆形 例子1234567mermaidgraph TD id[矩形] id4(圆角矩形) id3&gt;不对称的矩形] id1{菱形} id2((圆形)) graph TD id[矩形] id4(圆角矩形) id3&gt;不对称的矩形] id1{菱形} id2((圆形))","link":"/2020/01/08/%E5%A6%82%E4%BD%95%E7%94%A8Markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/"},{"title":"配置Git的SSH Key","text":"生成SSH并添加到GitHub回到你的git bash中， git config –global user.name “yourname”git config –global user.email “youremail” 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下是否输对 git config user.namegit config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C “youremail” 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去 作者：程序员黄小斜链接：https://www.jianshu.com/p/5efd8c6eb3e9来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2020/01/08/%E9%85%8D%E7%BD%AEGit%E7%9A%84SSH%20Key/"},{"title":"模块调用","text":"模块调用例子 login.py：123456789101112131415161718192021import getpass_username = &quot;Mingjun Wei&quot;_password = 123456count = 3while(count): usrname = input(&quot;Please enter your username :&quot;) pwd = int(getpass.getpass(&quot;password:&quot;)) if _username == usrname and _password ==pwd : print(&quot;Welcome home, {0} !&quot;.format(usrname)) break; else: print(&quot;invalid username or password!&quot;) count -= 1if count == 0: msg=&apos;&apos;&apos;You have try 3 times.Please run the program again.&apos;&apos;&apos; print(msg) MyLoginDemo.py:1234import login&apos;&apos;&apos;调用login模块时，先在当前目录查找login模块，找不到再去第三方库目录查找。&apos;&apos;&apos;MyLoginDemo.py运行后和单独运行login.py效果相同。 调用login.py后当前目录出现_pycache_文件夹，文件夹里产生一个login.cpython-36.pyc文件","link":"/2019/03/20/%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"},{"title":"设置您的PyCharm","text":"使用PyCharm时常用的设置事项。 一、改变pycharm terminal的字体file-&gt;settings-&gt;Editor-&gt;General-&gt;Console里面的console commands history size 二、通过默认模板新建文件:File-&gt;settings-&gt;Editor-&gt;File and Code Templates-&gt;Python Script 三、修改pycharm默认编码器：File-&gt;Setting-&gt;Editor-&gt;File Encodeings 为减少出现乱码的可能性，最好把Global Encoding、Project Encoding、Default encoding for properties files全部改成UTF-8。 注意： 刚安装pycharm后，Project Encoding、Default encoding for properties files默认是GBK。","link":"/2019/03/19/%E8%AE%BE%E7%BD%AE%E6%82%A8%E7%9A%84PyCharm/"},{"title":"需要注意的基本运算&操作","text":"还记得幂运算怎么写吗？什么是三元运算符？ 幂运算：1234&gt;&gt;&gt;2**416&gt;&gt;&gt;2**101024 三元运算符格式： result = 值1 if 条件 else 值2如果条件为真 -&gt; result = 值1如果条件为假 -&gt; result = 值2 例子： 123456789&gt;&gt;&gt; a =5&gt;&gt;&gt; b =6&gt;&gt;&gt; c =7&gt;&gt;&gt; d = a if b&gt;c else 8&gt;&gt;&gt; d8&gt;&gt;&gt; d = a if b&lt;c else 8&gt;&gt;&gt; d5","link":"/2019/03/20/%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97-%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"C&#35","slug":"C-35","link":"/tags/C-35/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CodeBlocks","slug":"CodeBlocks","link":"/tags/CodeBlocks/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"Game Design","slug":"Game-Design","link":"/tags/Game-Design/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"UE4","slug":"UE4","link":"/tags/UE4/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"PyCharm","slug":"PyCharm","link":"/tags/PyCharm/"}],"categories":[{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"搭建博客","slug":"搭建博客","link":"/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"Game Develop","slug":"Game-Develop","link":"/categories/Game-Develop/"}]}