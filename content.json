{"meta":{"title":"MJ's Blog","subtitle":"Never say never. ","description":"This is a personal Blog.","author":"MJ","url":"https://weimingjuncn.github.io","root":"/"},"pages":[{"title":"About Me","date":"2020-01-23T13:57:15.254Z","updated":"2020-01-23T13:57:15.254Z","comments":true,"path":"about/index.html","permalink":"https://weimingjuncn.github.io/about/index.html","excerpt":"","text":"EducationI recieved my bachelor degree from Guilin University of Electronic Technoligy in 2019. InterestsGame development、Game Design Programming LanguageC++，C#, Lua ExperienceInternship: Front-end developmentGraduation project: Community Detection based on Graph Convolution NetworkNow: Unity engineering"},{"title":"tags","date":"2020-02-19T10:06:23.993Z","updated":"2020-02-19T10:06:23.993Z","comments":true,"path":"tags/index.html","permalink":"https://weimingjuncn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C#面向对象基础（七）接口与索引器","slug":"C Sharp面向对象基础（七）接口与索引器","date":"2020-06-30T02:04:00.000Z","updated":"2020-06-30T05:43:44.321Z","comments":true,"path":"2020/06/30/C Sharp面向对象基础（七）接口与索引器/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/30/C%20Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%99%A8/","excerpt":"关键词：接口的定义、实现接口、接口回调、抽象类和接口的区别、索引器","text":"关键词：接口的定义、实现接口、接口回调、抽象类和接口的区别、索引器 一、接口在构建类的过程中，经常遇到这样一种特殊情况： 在描述某个类的各个方法时，对每个方法我们只能给出其功能实现的要求（原形声明）但不能给出具体的功能实现（方法体）。因为我们要处理的问题只是一个泛泛的功能说明，并没有针对某一具体类型的问题来说明。 接口：一组只有成员方法声明，没有方法体的方法集。 接口中可写的内容：方法、属性、索引器、事件 接口的作用： 提供完全的抽象； 规定类应具有的形式； 接口中的方法在多个实现接口的类中表现为多态性； 便于设计、管理、协作项目。 接口的定义要点：类似于类的定义格式，只是以interface作为定义符。 1234[访问修饰符] interface 接口名&#123; 返回值类型 方法名([参数列表]);&#125; 多继承模式： 1234[访问修饰符] interface 派生的接口名 : 父接口名列表&#123; 返回值类型 方法名([参数列表]);&#125; 注意：接口中声明的方法都是默认public的，不能自定义访问级别。 实现接口一个类可以实现多个接口。 1234class 类名 : 接口1, 接口2, 接口3, ...&#123; &#x2F;&#x2F;所有接口定义方法的实现&#125; 一个接口可以被多个类实现。 123456789101112class 类1 : 接口1&#123; &#x2F;&#x2F;接口1定义方法的实现&#125;class 类2 : 接口1&#123; &#x2F;&#x2F;接口2定义方法的实现&#125;class 类3 : 接口1&#123; &#x2F;&#x2F;接口3定义方法的实现&#125; 实现原则： 实现的方法必须与接口的原型定义保持一致； 必须实现接口中的所有成员方法。 实现方式：隐式实现、显式实现 隐式实现： 12345678910111213141516171819interface Interface01&#123; void Method01();&#125;interface Interface02&#123; void Method02();&#125;class ClassName : Interface01, Interface02&#123; public void Method01()&#x2F;&#x2F;没有标识表明这个方法是哪一个接口的还是类内自己定义的 &#123; &#125; public void Method02() &#123; &#125;&#125; 显示实现： 12345678910111213141516171819interface Interface01&#123; void Method01();&#125;interface Interface02&#123; void Method02();&#125;class ClassName : Interface01, Interface02&#123; void Interface01.Method01()&#x2F;&#x2F;显示实现在类中明确方法是哪一个接口的 &#123; &#125; void Interface02.Method02()&#x2F;&#x2F;但是显示实现全部为私有化实现 &#123; &#125;&#125; 选哪个? 若实现的所有方法均无重名，使用隐式；若实现的所有方法中出现重名，使用显式。 接口回调接口引用=实现类对象 含义： 接口也是引用数据类型，可以指向任意实现了该接口的类实例 作用： 统一管理实现类对象； 访问显示实现的方法。 注意： 显示实现的方法只能用接口回调来调用，无法用实现类引用调用。 抽象类和接口的区别例1（接口实现）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectInterface&#123; interface Skills : Warrior, Mage, Ranger &#123; &#125; class Program &#123; static void Main(string[] args) &#123; &#125; &#125; class Player : Skills &#123; int warriorWeaponId; int mageWeaponId; int rangerWeaponId; //显示实现属性 int Warrior.WeaponId &#123; get =&gt; warriorWeaponId; set =&gt; warriorWeaponId = value; &#125; int Mage.WeaponId &#123; get =&gt; mageWeaponId; set =&gt; mageWeaponId = value; &#125; int Ranger.WeaponId &#123; get =&gt; rangerWeaponId; set =&gt; rangerWeaponId = value; &#125; //隐式实现方法 public void Arrow() &#123; &#125; public void Spell() &#123; &#125; public void Sword() &#123; &#125; &#125; interface Warrior &#123; int WeaponId &#123; get; set; &#125; void Sword(); &#125; interface Mage &#123; int WeaponId &#123; get; set; &#125; void Spell(); &#125; interface Ranger &#123; int WeaponId &#123; get; set; &#125; void Arrow(); &#125;&#125; 二、索引器","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#类内部内容全解","slug":"C Sharp类内部内容全解","date":"2020-06-29T10:51:54.000Z","updated":"2020-06-29T11:10:44.924Z","comments":true,"path":"2020/06/29/C Sharp类内部内容全解/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/29/C%20Sharp%E7%B1%BB%E5%86%85%E9%83%A8%E5%86%85%E5%AE%B9%E5%85%A8%E8%A7%A3/","excerpt":"类内部九个内容的建立和访问方式","text":"类内部九个内容的建立和访问方式 字段1234567class ClassName&#123; public type data;&#125;ClassName c &#x3D; new ClassName();c.data; 成员方法1234567class ClassName&#123; public type MethodName()&#123;&#125;&#125;ClassName c &#x3D; new ClassName();c.MethodName(); 成员属性123456789101112131415161718class ClassName&#123; type data; public type Data() &#123; set &#123; this.data &#x3D; value; &#125; get &#123; value &#x3D; data; &#125; &#125;&#125;ClassName c &#x3D; new ClassName();c.Data; 对象构造123456class ClassName&#123; public ClassName()&#123;&#125;&#125;new ClassName(); 析构123456class ClassName&#123; ~ClassName()&#123;&#125;&#125;垃圾回收前自动调起。 静态字段123456class ClassName&#123; public static type data;&#125;ClassName.data; 静态方法123456class ClassName&#123; public static type MethodName()&#123;&#125;&#125;ClassName.MethodName(); 静态构造123456class ClassName&#123; static ClassName()&#123;&#125;&#125;使用类就立即执行。 类属性1234567891011121314151617class ClassName&#123; static type data; public static type Data() &#123; set &#123; data &#x3D; value; &#125; get &#123; value &#x3D; data; &#125; &#125;&#125;ClassName.Data;","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#面向对象基础（六）附加修饰符","slug":"C Sharp面向对象基础（六）附加修饰符","date":"2020-06-29T06:42:07.000Z","updated":"2020-06-30T01:57:53.069Z","comments":true,"path":"2020/06/29/C Sharp面向对象基础（六）附加修饰符/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/29/C%20Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E9%99%84%E5%8A%A0%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"关键词：static、静态类、类的加载次序、单例模式、abstract、sealed、const、readonly","text":"关键词：static、静态类、类的加载次序、单例模式、abstract、sealed、const、readonly 一、static静态成员类成员：类中的所有东西只要由static关键字修饰，都叫类成员。（区别于对象成员，与对象没有关系，只属于类。）特点：可以在不创建类的对象前就用格式：” 类名.类成员 ”直接调用类成员。 类变量：由static关键字修饰的字段。特点：隶属于类模板（共用），可直接使用格式：” 类名. 类变量名“进行访问。注意：无法使用对象引用。 类方法：由static关键字修饰的方法。特点：隶属于类模板，直接使用格式：“ 类名.类方法名 ”访问。注意：无法使用对象引用，方法中不能使用this、base。 静态构造方法格式： 1static ClassName()&#123;&#125; 用处：初始化static变量 （对象构造函数初始化的是成员变量） 特点： 每个类中都由此方法（看不见可以自己写出来）； 不可以被直接调用； 在使用类时自动执行（使用类：使用类变量、访问类方法、new一个对象）； 运行期间只执行一次。 静态构造必须无参。 静态类由static修饰的类 特点： 不能实例化（没有对象）； 共享（访问格式：“ 类名.访问内容 ”） 原则：静态类中的所有成员必须是静态的。 类内部调用关系例1（同类对象共享类变量）12345678910111213141516171819202122232425262728using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectStatic&#123; class Program &#123; static void Main(string[] args) &#123; Player player01 = new Player(); Player player02 = new Player(); Player player03 = new Player(); Console.WriteLine(\"The number of players is &#123;0&#125;.\", Player.Count); &#125; &#125; class Player &#123; static int count; public Player() &#123; count++; &#125; public static int Count &#123; get =&gt; count;&#125; &#125;&#125; 例2（静态类使用）123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectStatic&#123; class Program &#123; static void Main(string[] args) &#123; string id = Tool.Input(\"ID\"); string name = Tool.Input(\"昵称\"); string level = Tool.Input(\"等级\"); Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\", id, name, level); &#125; &#125; static class Tool &#123; public static string Input(string msg) &#123; Console.WriteLine(\"请输入&#123;0&#125;：\", msg); return Console.ReadLine(); &#125; &#125;&#125; 二、类内部加载次序，调用关系多类的加载次序 优先加载Main方法所在的类； 执行Main方法； 执行过程中使用到哪个类，加载哪个类。 单个类的加载次序 加载类中的静态变量、静态方法； 执行静态构造为静态变量进行初期化； 当产生对象时（new对象时），分配成员变量和成员方法到对象中。 注意：非静态的可以调用静态和非静态的，静态的只能调用静态的。 例1（加载次序）123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectStatic&#123; class Program &#123; static void Main(string[] args) &#123; Class01 c1 = new Class01(); &#125; static Program() &#123; Console.WriteLine(\"static Program()\"); &#125; &#125; class Class01 &#123; public Class01() &#123; Class02 c2 = new Class02(); &#125; static Class01() &#123; Console.WriteLine(\"static Class01()\"); &#125; &#125; class Class02 &#123; public Class02() &#123; Console.WriteLine(\"Class02()\"); &#125; static Class02() &#123; Console.WriteLine(\"static Class02()\"); &#125; &#125;&#125; 三、单例模式例112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectStatic&#123; class Program &#123; static Program() &#123; Hero.GetHero().AddData(1, \"Mage\"); &#125; static void Main(string[] args) &#123; Hero.GetHero().AddData(0,\"Warrior\"); for(int i = 0; i &lt; Hero.GetHero().Data.Length; i++) &#123; if (Hero.GetHero().Data[i] != null) Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\", i, Hero.GetHero().Data[i]); &#125; &#125; &#125; class Hero &#123; String[] data; static Hero hero; //私有化构造 Hero() &#123; data = new String[10]; &#125; public String[] Data &#123; get =&gt; data; &#125; //向系统提供该单例 public static Hero GetHero() &#123; if(hero == null) //自己手动生成当前类对象 hero = new Hero(); return hero; &#125; public void AddData(int index, String data) &#123; this.data[index] = data; &#125; &#125;&#125; 四、abstract抽象的意义：描述抽象的概念，规定必须实现的方法的统一接口。 抽象类用abstract关键字来修饰的类 123abstract class AbstractClass&#123;&#125; 特点： 必须被继承才可以使用； 不能被直接实例化； 和密封类（sealed类）正好相反。 抽象方法用abstract类修饰的方法 1abstract returnType AbstractMethod([paramlist]); 特点： 必须被重写（override）； 只有方法头，没有方法体； 抽象方法必须在抽象类中。 规则 抽象类中不一定包含抽象方法； 有抽象方法的类必定是抽象类； 抽象方法只是声明，没有方法的实现； 构造方法、类方法不能声明为抽象方法；（因为构造方法、类方法无法override） 子类必须实现抽象方法，除非子类也是抽象类； 抽象类中不一定全是抽象方法，可以有一部分具体实现。 例1（抽象实现）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectAbstract&#123; class Program &#123; static void Main(string[] args) &#123; Warrior warrior = new Warrior(100,100,1); Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\", warrior.Health, warrior.Magic, warrior.Level); warrior.Damage(); &#125; &#125; abstract class Player &#123; //\"prop\"+Tab键，自动属性：字段+属性 //用属性规定子类必须具备的字段 public abstract float Health &#123; get; set; &#125; public abstract float Magic &#123; get; set; &#125; public abstract int Level &#123; get; set; &#125; public abstract void Damage(); &#125; class Warrior : Player &#123; float health; float magic; int level; public Warrior(float health, float magic, int level) &#123; this.health = health; this.magic = magic; this.level = level; &#125; public override float Health &#123; get =&gt; health; set =&gt; health = value; &#125; public override float Magic &#123; get =&gt; magic; set =&gt; magic = value; &#125; public override int Level &#123; get =&gt; level; set =&gt; level = value; &#125; public override void Damage() &#123; Console.WriteLine(\"Heavy Attack!\"); &#125; &#125;&#125; 五、sealed 不允许继承，不允许重写，继承到此为止。 密封类被sealed修饰的类被称为密封类 123sealed class SealedClass&#123;&#125; 特性：密封类不能被继承 密封方法被sealed修饰的方法被称为密封方法 123sealed override returnType SealedMethodName([paramLlist])&#123;&#125; 特性： 密封方法会重写基类中的方法； 密封方法无法被重写。 注意：必须始终与override一起使用。 密封属性被sealed修饰的属性被称为密封属性 123456789sealed override returnType Property&#123; set &#123; &#125; get &#123; &#125;&#125; 特性： 密封属性会覆盖基类中的属性； 密封属性无法被覆盖。 注意：必须始终与override一起使用。 sealed常用语类库中，一般实际项目里使用较少。 六、const 声明常量； 声明的同时赋值； 运行期间不能改变它的值； 属于编译时常量； 不能用new初始化。 const一般修饰值类型和String。 七、readonly 只读变量 属于运行时变量 可以在构造方法里改变它的值 不能作用于局部变量 初始化时机： 声明的同时赋值； 静态变量，在静态构造中初始化； 非静态变量，在非静态构造中初始化。 八、总结static修饰：类、变量、方法。 static修饰类，则这个类为整个工程提供公共的变量、公共的方法。 static修饰方法，可以直接通过类名.方法名调用，属于类模板方法。 static修饰变量，该变量属于类模板，所有此类对象均可通过类名.变量名访问。 abstract修饰：类、方法。 abstract修饰类，该类无法直接实例化，必须出具子类才可以使用该类的方法，鼓励继承。 abstract修饰方法，要求子类必须具备某种功能（方法），某种字段（抽象属性）。 sealed修饰：类、方法。 sealed修饰类，禁止有子类。 sealed修饰方法，重写基类方法并禁止子类重写。 const修饰：变量（通常修饰值类型和String）。 readonly修饰：变量（通常修饰引用类型）。","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#面向对象基础（五）多态","slug":"C Sharp面向对象基础（五）多态","date":"2020-06-29T04:57:50.000Z","updated":"2020-06-29T06:28:49.110Z","comments":true,"path":"2020/06/29/C Sharp面向对象基础（五）多态/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/29/C%20Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E5%A4%9A%E6%80%81/","excerpt":"关键词：编译时多态、运行时多态、重载和覆盖的区别","text":"关键词：编译时多态、运行时多态、重载和覆盖的区别 概念多态（polymorphism）：即一个名字具有多种语义。在面向对象中指一个方法可以有多种实现版本。 类的多态表现为方法的多态。方法的多态：重载（overload）和覆盖（override）。 重载：同一个“类”中，方法同名，参数列表不同：个数不同、类型不同、次序不同注意：返回值类型不同无法构成重载！ 覆盖（重写） 这种语法出现在父子类中。 父类的方法用virtual修饰一下形成虚方法或者用abstract修饰成为抽象方法。 子类的方法务必和父类的方法同名，且用override关键字修饰一下 其他部分保持一致（访问修饰符 修饰符 返回值类型 参数列表） 静态联编（静态多态性）重载的方法由于参数列表不同，编译时就可以确定到底执行哪种方法的代码，因此重载又称为编译时多态。 动态联编（动态多态性）重写/覆盖的方法由于参数列表相同，编译时无法确定到底执行哪个（父/子）方法，运行时依据内存的对象的实际类型去确定执行哪个（父/子）方法，因此重写/覆盖又称为运行时多态。 调用原则：“是谁的对象就调用谁的方法。” 重载和覆盖的区别 从方法声明角度（格式）： 重载的两个函数参数列表不同；覆盖的两个方法参数列表和返回值类型相同。 从所处位置角度（位置）： 重载的两个方法在同一个类中；覆盖的两个方法在有继承关系的两个类中。 从方法调用角度（调用）： 重载的方法被同一个对象通过不同的参数调用；覆盖的方法被不同对象使用相同参数调用。 从多态时机角度（特性）： 重载是编译时多态；覆盖是运行时多态。 例子重载例子一个类的多个构造方法 覆盖例子（virtual与override）1234567891011121314151617181920212223242526272829303132333435363738394041using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectPolymorphism&#123; class Program &#123; static void Main(string[] args) &#123; TestMage(); &#125; public static void TestMage() &#123; Attack(new Mage()); Attack(new DestructionMage()); Attack(new Mage()); &#125; public static void Attack(Mage m) &#123; m.CastSpell(); &#125; &#125; class Mage &#123; public virtual void CastSpell() &#123; Console.WriteLine(\"fire ball!\"); &#125; &#125; class DestructionMage : Mage &#123; public override void CastSpell() &#123; Console.WriteLine(\"FIRE STORM!!!\"); &#125; &#125;&#125; 总结 方法是代码复用的重要手段。 控制好代码被访问的程度，可以加强代码的安全性。 封装、继承、多态是面向对象的基本特征。 封装特性通过访问权限的设定将类的实现细节隐藏，提供接口供外部访问。 继承和组合是类的基本关系，是软件复用的重要方法。（一个类内部之间的关系——组合，多个类之间如果存在关系——继承） 多态是面向对象的重要标志。（没有多态就得一直写if，is，as）","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#面向对象基础（四）继承","slug":"C Sharp面向对象基础（四）继承","date":"2020-06-27T05:01:06.000Z","updated":"2020-06-29T04:55:06.803Z","comments":true,"path":"2020/06/27/C Sharp面向对象基础（四）继承/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/27/C%20Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%A7%E6%89%BF/","excerpt":"关键词：定义、原则、隐藏、base、向上转型、is和as","text":"关键词：定义、原则、隐藏、base、向上转型、is和as 一、什么是继承？继承是由已有的类创建新类的机制。 由继承得到的类，称为子类（派生类）。被继承的类成为父类（超类、基类）。 继承的作用： 实现代码可复用的重要方式； 增强代码的可扩充性； 提高代码的可维护性。 声明继承 1[&lt;修饰符&gt;] class &lt;子类名&gt; : (extends) &lt;基类名&gt; Object类 C#中多有的类都是Object的直接或间接子类。 二、继承的原则可继承内容： 子类继承父类私有以外的成员变量、方法；子类不继承父类的构造方法；子类继承父类的析构方法；子类不能删除父类的成员；子类可以重定义（隐藏/覆盖）父类成员；子类可以增加自己独有的成员。 子类对象对父类成员的访问权限： 子类可以访问父类私有以外的成员变量、方法；注意：受保护（protected）只能在子类内访问。 三、隐藏子类可以重定义与父类成员同名的成员，此时父类的成员被隐藏。 注意：程序中会出现警告，警告不影响执行。 消除警告的方法：在隐藏属性或方法中追加new关键字。 例1（重定义继承下来的父类成员）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectExtends&#123; class Program &#123; static void Main(string[] args) &#123; TestHuman(); &#125; public static void TestHuman() &#123; Human[] humen = new Human[3];//对象数组，humen指向humen[0],humen[1],humen[2] humen[0] = new Human(\"Jessie\", \"noodles\", 100); //humen[*]才指向对象 humen[1] = new Human(\"Max\", \"rice\", 100); humen[2] = new Human(\"David\", \"porridge\", 100); Animal animal = new Animal(); foreach(var item in humen) &#123; Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\",item.Name,item.Age,item.Food); &#125; Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\", animal.Name, animal.Age, animal.Food); &#125; &#125; class Animal &#123; string name = \"beast\"; int age = 20; string food = \"meat\"; public Animal() &#123; &#125; public Animal(string name, string food, int age) &#123; this.name = name; this.age = age; this.food = food; &#125; public string Name &#123; get =&gt; name; set =&gt; name = value; &#125; public int Age &#123; get =&gt; age; set =&gt; age = value; &#125; public string Food &#123; get =&gt; food; set =&gt; food = value; &#125; &#125; class Human : Animal &#123; string name; string food; int age; public Human(string name, string food, int age) &#123; this.name = name; this.food = food; this.age = age; &#125; public new string Name &#123; get =&gt; name; set =&gt; name = value; &#125;//添加new关键字，隐藏基类的成员 public new string Food &#123; get =&gt; food; set =&gt; food = value; &#125; public new int Age &#123; get =&gt; age; set =&gt; age = value; &#125; &#125;&#125; 四、basebase用于引用（指向）当前对象的父类对象 用法： 访问父类被隐藏的成员变量； 调用父类中被覆盖的方法； 调用父类的构造函数。 如： base.variable; base.Method([paramList]); :base([paramList]); 注意： 写类要带无参构造，因为这样可以生成base，避免继承时报错。 base只在类内部和子类内部可以访问。 例1（没有父类无参构造，怎么通过子类构造父类对象）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectExtends&#123; class Program &#123; static void Main(string[] args) &#123; TestHuman(); &#125; public static void TestHuman() &#123; Human[] humen = new Human[3];//对象数组，humen指向humen[0],humen[1],humen[2] humen[0] = new Human(\"Jessie\", \"homo sapiens\",\"noodles\", 100); //humen[*]才指向对象 humen[1] = new Human(\"Max\", \"homo sapiens\", \"rice\", 100); humen[2] = new Human(); foreach(var item in humen) &#123; Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\\t&#123;3&#125;\",item.Name,item.Type,item.Age,item.Food); &#125; Animal animal = humen[2].GetBase(); Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\\t&#123;3&#125;\", animal.Name, animal.Type, animal.Age, animal.Food); &#125; &#125; class Animal &#123; string name; string type; int age; string food; public Animal(string name, string type, string food, int age) &#123; this.name = name; this.type = type; this.age = age; this.food = food; &#125; public string Name &#123; get =&gt; name; set =&gt; name = value; &#125; public int Age &#123; get =&gt; age; set =&gt; age = value; &#125; public string Food &#123; get =&gt; food; set =&gt; food = value; &#125; public string Type &#123; get =&gt; type; set =&gt; type = value; &#125; &#125; class Human : Animal &#123; string name; string type; string food; int age; public Human() : base(\"Lucy\", \"Australopithecus afarensis\", \"fruit\", 30) //先有父类对象才有子类对象 //没有父类构造，但子类用无参构造，这时需要通过base构造父类对象 &#123; &#125; public Human(string name, string type, string food, int age):base(name,type,food,age) //没有父类无参构造时，子类自己向外部要实参构造父类对象 &#123; this.name = name; this.type = type; this.food = food; this.age = age; &#125; public Animal GetBase() &#123; return new Animal(base.Name, base.Type, base.Food, base.Age); &#125; public new string Name &#123; get =&gt; name; set =&gt; name = value; &#125; public new string Food &#123; get =&gt; food; set =&gt; food = value; &#125; public new int Age &#123; get =&gt; age; set =&gt; age = value; &#125; public string Type &#123; get =&gt; type; set =&gt; type = value; &#125; &#125;&#125; 例2（父与子到底是谁花的钱？）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectExtends&#123; class Program &#123; static void Main(string[] args) &#123; TestPay(); &#125; public static void TestPay() &#123; Child child01 = new Child(\"John\", 100,10000); Child child02 = new Child(\"Alice\", 100,10000); child01.Pay(1000); child01.ShowMoney(); child02.PayByDad(1000); child02.ShowMoney(); &#125; &#125; class Father &#123; string name; float money; public Father(string name, float money) &#123; this.name = name; this.money = money; &#125; public string Name &#123; get =&gt; name; set =&gt; name = value; &#125; public float Money &#123; get =&gt; money; set =&gt; money = value; &#125; public void Pay(float money) &#123; this.money -= money; &#125; &#125; class Child : Father &#123; float money; //child自己的money public Child(string name, float myMoney,float money) : base(name, money) &#123; this.money = myMoney; &#125; //child自己的封装 public new float Money &#123; get =&gt; money; set =&gt; money = value; &#125; public new void Pay(float money) //child自己的Pay方法，如果不写，直接用Pay,则减的是base.Money &#123; this.money -= money; &#125; public void PayByDad(float money) &#123; base.Money -= money; &#125; public void ShowMoney() &#123; Console.WriteLine(\"&#123;0&#125;：&#123;1&#125;\\nFather of &#123;2&#125;：&#123;3&#125;\", this.Name, this.money, this.Name, base.Money); //其实this.Name等于base.Name //Console.WriteLine(base.Name); &#125; &#125;&#125; 五、向上转型子类和父类具有“is xxx”的关系 例如： 父类“人”和子类“学生”：“学生”是“人”父类“动物”和子类“猫”：”猫“是“动物” 因此父类的引用可以指代子类的实例 动物 = 猫人 = 学生 以上称之为：Upcasting/向上转型 上转型引用访问范围受限： 可以访问子类继承或覆盖的成员；不能访问子类中新增（独有）成员。向上转型对象可以被重新赋值为子类引用 人 = 学生学生 = （学生）人 这时它又重新可以访问子类中新增（独有）成员。 作用：用一个引用处理各个子类对象，便于扩展和维护项目。 向上转型的使用范围： 方法参数：用一个方法处理家族对象； 数组或集合的类型上：用于存储家族对象。 例1（转为父类，转回子类）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectExtends&#123; class Program &#123; static void Main(string[] args) &#123; Tiger tiger = new Tiger(\"Tiger\",\"meat\"); Lion lion = new Lion(\"Lion\", \"meat\"); TestEat(tiger);//用Animal类接收tiger，向上转型为父类 TestEat(lion);//用Animal类接收lion，向上转型为父类 TestTigerSleep(tiger); &#125; public static void TestEat(Animal animal) &#123; animal.Eat();//调用父类方法 &#125; public static void TestTigerSleep(Animal animal) &#123; Tiger tiger = (Tiger)animal;//强转回Tiger类（子类） tiger.Sleep();//父类无法调用子类新增的方法，转回子类才可以。 &#125; &#125; class Animal &#123; string name; string food; public void Eat() &#123; Console.WriteLine(\"&#123;0&#125; is eating.\", name); &#125; public Animal() &#123; &#125; public Animal(string name, string food) &#123; this.name = name; this.food = food; &#125; public string Name &#123; get =&gt; name; set =&gt; name = value; &#125; public string Food &#123; get =&gt; food; set =&gt; food = value; &#125; &#125; class Tiger : Animal &#123; public void Sleep()//子类新增方法 &#123; Console.WriteLine(\"Tiger is Sleeping.\"); &#125; public Tiger(string name, string food) : base(name, food) &#123; &#125; &#125; class Lion : Animal &#123; public Lion(string name, string food) : base(name, food) &#123; &#125; &#125;&#125; 例2（一种父类接收多种子类）1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectExtends&#123; class Program &#123; static void Main(string[] args) &#123; PK(new Warrior(), new Mage());//一种参数类型方法接收整个家族 Player[] aoeHits = new Player[]//一种类型数组接收整个家族 &#123; new Warrior(), new Warrior(), new Warrior(), new Mage(), new Mage() &#125;; &#125; public static void PK(Player player01, Player player02) &#123; &#125; public static void AOE() &#123; &#125; &#125; class Player &#123; &#125; class Mage : Player &#123; &#125; class Warrior : Player &#123; &#125;&#125; 六、is和as父类转子类，往往会发生异常。 原因：无法确认父引用是否经过向上转型 is/as：父类转子类的安全保障。 is语法：对象引用 is 类型作用：检测对象引用是否属于某个类或其父类。返回值：true/false优势：适配所有类型（包括null）劣势：效率稍低 as语法：对象引用 as 类型作用：尝试转换对象引用为具体类型的引用返回值：对象引用/null优势：效率高劣势：仅适配引用类型 例1（is用法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectExtends&#123; class Program &#123; static void Main(string[] args) &#123; Warrior warrior = new Warrior(); Mage mage = new Mage(); Movement(warrior); Movement(mage); &#125; public static void Movement(Player player)//用父类Player接收 &#123; if(player is Warrior)//用is判断是否是Warrior类 &#123; Warrior w = (Warrior)player;//父类转回子类 w.Attack();//调用子类方法 &#125; else if (player is Mage)//用is判断是否是Mage类 &#123; Mage m = (Mage)player;//父类转回子类 m.CastSpell();//调用子类方法 &#125; &#125; &#125; class Player &#123; &#125; class Mage : Player &#123; public void CastSpell() &#123; Console.WriteLine(\"Mage is casting spell.\"); &#125; &#125; class Warrior : Player &#123; public void Attack() &#123; Console.WriteLine(\"Warrior is attacking the target.\"); &#125; &#125;&#125; 例2（as用法）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectExtends&#123; class Program &#123; static void Main(string[] args) &#123; Warrior warrior = new Warrior(); Mage mage = new Mage(); Movement(warrior); Movement(mage); &#125; public static void Movement(Player player)//用父类Player接收 &#123; Warrior w = player as Warrior;//尝试player是否可以转为Warrior类，失败返回null if(w != null)//做判断，如果是null，说明转型失败跳过调用Attack &#123; w.Attack(); &#125; Mage m = player as Mage;//尝试player是否可以转为Mage类，失败返回null if(m != null)//做判断 &#123; m.CastSpell(); &#125; &#125; &#125; class Player &#123; &#125; class Mage : Player &#123; public void CastSpell() &#123; Console.WriteLine(\"Mage is casting spell.\"); &#125; &#125; class Warrior : Player &#123; public void Attack() &#123; Console.WriteLine(\"Warrior is attacking the target.\"); &#125; &#125;&#125; 结果同本小节例1。","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#面向对象基础（三）封装","slug":"C Sharp面向对象基础（三）封装","date":"2020-06-27T04:01:26.000Z","updated":"2020-06-27T05:26:35.518Z","comments":true,"path":"2020/06/27/C Sharp面向对象基础（三）封装/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/27/C%20Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E5%B0%81%E8%A3%85/","excerpt":"关键词：封装目的、封装基本要求","text":"关键词：封装目的、封装基本要求 一、封装将数据成员和代码成员像组合的一种机制。 目的： 管控对象状态的范围； 加强对象自身的内联动性； 增强对象使用的安全性。 封装的基本要求： 设定特定边界：所有的内部变化都限制在此边界内（类定义的{ }）； 设定特定访问权限：在对象外部不能访问或修改受保护的内部实现细节（private成员） 提供外部接口（方法）：此对象利用它与其他对象发生关联（public成员）。 二、属性封装属性和字段结合实现封装 属性的定义：属性代表set和get方法 123456789101112[访问修饰符 一般为public] [new&#x2F;virtual&#x2F;override] 属性类型 属性名&#123; get &#123; 返回属性对应的字段的值 &#125; set &#123; 设定属性对应的字段的值，参数值由隐参value接收 自动执行：value &#x3D; 传入的参数值 &#125;&#125; 属性的作用：快速封装字段 属性分类：读写（set + get）、只读（get）、只写（set） 使用属性： 对象引用.属性 = 属性值 : 自动调用set方法 对象引用.属性 : 自动调用get方法","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#面向对象基础（二）访问修饰符","slug":"C Sharp面向对象基础（二）访问修饰符","date":"2020-06-27T03:24:10.000Z","updated":"2020-06-27T04:00:28.719Z","comments":true,"path":"2020/06/27/C Sharp面向对象基础（二）访问修饰符/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/27/C%20Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"关键词：访问修饰符、访问控制","text":"关键词：访问修饰符、访问控制 一、访问修饰符字段、方法都可以叫作类的成员，它们都需要定义访问级别。访问级别用于控制成员在哪些地方可以被访问。 访问修饰符： public：公共成员，完全公开，没有访问限制。 private：私有成员，在类的内部才可以访问。 internal：当前程序集内（exe, dll）可以访问。 protected：保护成员，该类内部和继承类中可以访问 internal protected：internal和protected的并集，同一个程序集中的所有类，以及所有程序集中的子类。 修饰符可以修饰的内容： 类（class）和结构（struct）只能用public, internal来修饰。 成员（变量、方法）能用以上5种来修饰。 如果不写访问修饰符，有以下默认规则： 类中字段和方法默认的访问修饰符是private； 类（class）和结构（struct）默认的访问修饰符是internal。 注意：程序集（Assembly）一般指一个.exe可执行文件或.dll类库文件。 总结： 本类中任意访问修饰符修饰的变量和方法均可访问。 同一项目不同类，无法访问受保护和私有的变量和方法。 访问不同项目（程序集），只能访问public类，其余全部失效。 二、访问控制","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#面向对象基础（一）抽象","slug":"C Sharp面向对象基础（一）抽象","date":"2020-06-26T08:00:26.000Z","updated":"2020-06-27T03:19:13.144Z","comments":true,"path":"2020/06/26/C Sharp面向对象基础（一）抽象/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/26/C%20Sharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E6%8A%BD%E8%B1%A1/","excerpt":"关键词：类、构造方法、析构方法、this用法","text":"关键词：类、构造方法、析构方法、this用法 一、什么是面向对象？面型对象的概念Object Oriented Programming，OOP用认识一个系统的方式来分析、设计、实现一个系统。面试答案：封装、继承、多态即为面向对象 面向对象的方法面向对象分析（OOA，Object-Oriented Analysis）面向对象设计（OOD，Object-Oriented Design）面向对象程序设计（OOP，Object-Oriented Programming） 主要围绕以下几个概念：对象、抽象数据类型、类、继承性、多态性 对比面向过程：相辅相成面向过程：先有算法，后有结构面向对象：先有结构，后又算法 优点：可复用（类）、可拓展（继承）、可管理（接口） 四个基本机制：抽象、封装、继承与派生、多态 二、抽象现实/虚幻的事物 =&gt; 计算机可处理的数据结构（类）用类（Class）描述复杂/复合的事物用数据抽象（变量）描述某类对象的状态（对象相互区别的物理量）代码抽象（方法）描述某类对象的共有功能 如何实现抽象： 分析事物，提取状态（变量）和行为（方法/函数）； 要有主次，关注重要的，忽略不重要的。 三、类的定义、使用、实例化类，一种复杂的数据类型，程序的基本单元。 定义语法123456789[访问修饰符] [修饰符] class 类名 [:&lt;基类名&gt;][,&lt;接口列表&gt;]&#123; 构造方法; 析构方法; [访问修饰符] [修饰符] 数据类型 &lt;变量名&gt;; [访问修饰符] [修饰符] 数据类型 &lt;属性名&gt;; ... [访问修饰符] [修饰符] &lt;返回值类型&gt; &lt;方法名&gt;([参数列表]);&#125; 使用方式（声明 -&gt; 赋值 -&gt; 使用）1. 声明类变量格式 1类名 变量名 类变量又叫对象的引用、等待指向对象。 2. 赋值：对象的实例化：对象的生成比较复杂，称为实例化 1new &lt;类名&gt;([&lt;参数1&gt;,&lt;参数2&gt;...]) 将引用指向实例： 1变量名 &#x3D; new &lt;类名&gt;([参数列表]) 3. 使用通过引用来寻找对象的变量和方法 12对象引用.成员变量对象引用.成员方法([参数列表]) 4. 对象的构造过程 为对象开辟空间； 调用构造方法初始化； 返回对象的引用。 5. 类和对象的关系 类是对象的模板； 一个类可以创建多个对象； 对象是类的一个具体个体； 对象有独立的内存空间，不会相互影响。 三、构造方法（构造函数，构造器）类的特殊的成员方法 声明：构造方法与类同名，且没有返回值类型；构造可以无参也可带参。 快捷生成构造方法：“ctor” + 两次Tab键 使用：必须使用new关键字调用 作用：创建类的实例并初始化对象。 初始化的缺省值都是确定的： 布尔类型变量初值：false整型变量初值：0浮点型变量初值：0.0字符变量初值：’\\0’引用（复合）变量的初值：null 注意： 系统为每一个类自动提供一个默认的无参的构造方法；若自定义构造方法，无参构造方法不在提供。 成员方法中的局部变量必须显式手动进行初始化。 快速构成： 选中参与构造的成员变量后右键或按”Ctrl + .”，选择“生成构造函数” 四、析构方法一个对象时如何出生的？ 在内存上根据类模板申请一片存储空间，再根据模板的内容填上相应的成员变量和成员方法； 构造默认初始值，如果有自定义初始值则直接通过构造参数填入； 将对象地址告知栈中的类变量要指向该对象进行引用。 对象的死亡？ 对象的存储空间被回收（程序被关闭，进程终结，垃圾回收）。 析构方法声明： 1~类名() 使用： 程序中的对象有垃圾回收器（garbage collector）负责释放，回收之前会自动调用对象对应类的析构函数，做释放前的准备工作（关闭占用资源等）。 注意： 一个类只有一个析构方法，没有返回值类型。 除非特殊需要，通常被省略。 五、this的用法this是成员方法中的隐参，是方法所在类的一个引用变量。 声明：每个成员方法自带，无需声明。 作用： 方法被调用时，立即指向调用该方法的对象； 区分同名的局部变量和成员变量； 调用本类的其他构造方法，拷贝构造中使用较多。 拷贝构造：批量无差异产生对象之后进行少量差异化赋值。 例1（拷贝构造）123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectCopyObject&#123; class Program &#123; static void Main(string[] args) &#123; Character c1 = new Character(\"Mage\", 100, 500); Character c2 = new Character(c1); c2.name = \"Ranger\"; c2.damage -= 200; Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\",c1.name,c1.health,c1.damage); Console.WriteLine(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\",c2.name,c2.health,c2.damage); &#125; &#125; class Character &#123; public string name; public float health; public float damage; //构造函数 public Character(string name, float health, float damage) &#123; this.name = name; this.health = health; this.damage = damage; &#125; //拷贝构造函数 public Character(Character c):this(c.name, c.health, c.damage) &#123; &#125; &#125;&#125; 例2（把类看成一种数据类型）1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectThis&#123; class Program &#123; static void Main(string[] args) &#123; Character c = new Character(\"Mage\", 1); c.LevelUp(); c.ShowLevel(); c.LevelUp().LevelUp().LevelUp().ShowLevel(); &#125; &#125; class Character &#123; public string name; public int level; public Character(string name, int level) &#123; this.name = name; this.level = level; &#125; //把类看成一种数据类型， //哪个Character类的对象调用LevelUp方法， //哪个对象的level就+1，并返回该对象。 public Character LevelUp() &#123; this.level++; return this; &#125; public void ShowLevel() &#123; Console.WriteLine(\"The level of &#123;0&#125; is &#123;1&#125;\", this.name, this.level); &#125; &#125;&#125;","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"OnEnable函数，OnDisable函数","slug":"OnEnable函数，OnDisable函数","date":"2020-06-25T04:23:00.000Z","updated":"2020-06-25T05:21:10.147Z","comments":true,"path":"2020/06/25/OnEnable函数，OnDisable函数/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/25/OnEnable%E5%87%BD%E6%95%B0%EF%BC%8COnDisable%E5%87%BD%E6%95%B0/","excerpt":"关键词：MonoBehaviour.OnEnable()、MonoBehaviour.OnDisable()","text":"关键词：MonoBehaviour.OnEnable()、MonoBehaviour.OnDisable() OnEnable函数用于在物体变为被激活（enable）和脚本有效时（active）被调用。 OnDisable函数在运行状况变为Disabled时。 OnDisable函数在物体被销毁时被调用，因此可以用于清理功能代码。 当脚本在编译完成时重载，这时OnDisable函数被调用，随后是载入完成的OnEnable函数。 下边是OnDisable和OnEnable函数的应用 12345678910111213141516171819202122using UnityEngine;[ExecuteInEditMode]public class PrintOnOff : MonoBehaviour&#123; void OnDisable() &#123; Debug.Log(\"PrintOnDisable: script was disabled\"); &#125; void OnEnable() &#123; Debug.Log(\"PrintOnEnable: script was enabled\"); &#125; void Update() &#123;#if UNITY_EDITOR Debug.Log(\"Editor causes this Update\");#endif &#125;&#125; 将PrintOnOff.cs拖到场景中某个物体上，播放游戏。 控制台首先打印 1PrintOnDisable: script was enabled 然后持续打印 1Editor causes this Update 当我们在Heirarchy里取消勾选该物体时，控制台先停止打印“ Editor causes this Update ”，再打印 1PrintOnDisable: script was disabled 当我们勾选该物体时，控制台打印 1234PrintOnDisable: script was enabledEditor causes this UpdateEditor causes this Update... 当我们在物体里仅取消勾选或勾选Print On Off (Script)组件时，效果同上。 注意：OnEnable、OnDisable均不可以作为协程","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（十）玩家血条与伤害","slug":"DarkSoulsDemo（十）玩家血条与伤害","date":"2020-06-23T07:41:04.000Z","updated":"2020-06-24T08:27:11.793Z","comments":true,"path":"2020/06/23/DarkSoulsDemo（十）玩家血条与伤害/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/23/DarkSoulsDemo%EF%BC%88%E5%8D%81%EF%BC%89%E7%8E%A9%E5%AE%B6%E8%A1%80%E6%9D%A1%E4%B8%8E%E4%BC%A4%E5%AE%B3/","excerpt":"关键词：UI","text":"关键词：UI 一、放置UI元素在Hierarchy新建UI|Canvas，在Canvas下新建一个空物体，取名Health Bar，调整Health Bar的锚点。 在Health Bar下新建两个Image，分别命名为Health Bar Fill和Health Bar Background，将它们的锚点都设置为stretch-stretch（按住Alt键）。 Health Bar Fill|Image|Color设置为红色，Health Bar Background|Image|Color设置为黑色。将Health Bar Fill拖拽到Health Bar Background下方（使Health Bar Fil遮挡住Health Bar Backgroundl）。 给Health Bar添加组件Slider，取消勾选IsInteractable，Transition和Navigation设置为None，将Health Bar Fill拖入Fill Rect。这时我们通过滑动Value滑条控制Health Bar Fill。 二、添加脚本给Health Bar添加组件，在Add Component下拉框输入Healthbar后回车，作为新脚本创建并添加到Health Bar中。 编辑Healthbar.cs如下： 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;namespace MJ&#123; public class HealthBar : MonoBehaviour &#123; public Slider slider; public void SetMaxHealth(int maxHealth) &#123; slider.maxValue = maxHealth; slider.value = maxHealth; &#125; public void SetCurrentHealth(int currentHealth) &#123; slider.value = currentHealth; &#125; &#125;&#125; 将Health Bar拖拽到Health Bar|Health Bar ( Script )|Slider 给Player新建并添加一个PlayerStats.cs，编写脚本如下： 12345678910111213141516171819202122232425262728293031323334using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerStats : MonoBehaviour &#123; public int healthLevel = 10; public int maxHealth; public int currentHealth; public HealthBar healthBar; void Start() &#123; maxHealth = SetMaxHealthFromHealthLevel(); currentHealth = maxHealth; healthBar.SetMaxHealth(maxHealth); &#125; private int SetMaxHealthFromHealthLevel() &#123; maxHealth = healthLevel * 10; return maxHealth; &#125; public void TakeDamage(int damage) &#123; currentHealth = currentHealth - damage; healthBar.SetCurrentHealth(currentHealth); &#125; &#125;&#125; 回到Unity编辑器，将Health Bar拖拽到Player|Player Stats (Script)|Health Bar。 选中EventSystem，在其Standalone Input Module组件里会有兼容性警告，点击下方的Replace with InputSystemUIInputModule按钮即可。 三、做一个扣血物体在场景中新建一个圆柱体，取名为Fire，将它的Capsule Collider组件|Is Trigger勾选。给Fire添加脚本DamagePlayer.cs： 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class DamagePlayer : MonoBehaviour &#123; public int damage = 25; private void OnTriggerEnter(Collider other) &#123; PlayerStats playerStats = other.GetComponent&lt;PlayerStats&gt;(); if(playerStats != null) &#123; playerStats.TakeDamage(damage); &#125; &#125; &#125;&#125; 播放游戏，控制角色碰到Fire，左上角血条将减去一块。 四、添加受伤动画、阵亡动画想Animotor窗口网格区域拖入动画片段R_Damage_Left_02、R_Dead_04，分别重命名为Damage_Left、Dead，然后仅仅将Damage_Left这一个状态转向Empty状态。 编辑PlayerStats.cs，t添加变量animatorHandler声明，用Awake方法获取，在TakeDamage方法里调用如下： 123456789101112131415161718AnimatorHandler animatorHandler;private void Awake()&#123; animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;();&#125;public void TakeDamage(int damage)&#123; ... animatorHandler.PlayerTargetAnimation(\"Damage_Left\", true); if(currentHealth &lt;= 0) &#123; currentHealth = 0; animatorHandler.PlayerTargetAnimation(\"Dead\", true); &#125;&#125; 保存脚本，播放游戏，当角色碰到Fire时，有受伤动画，当角色血条全黑时，有死亡动画。 五、脚本汇总Healthbar.cs1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;namespace MJ&#123; public class HealthBar : MonoBehaviour &#123; public Slider slider; public void SetMaxHealth(int maxHealth) &#123; slider.maxValue = maxHealth; slider.value = maxHealth; &#125; public void SetCurrentHealth(int currentHealth) &#123; slider.value = currentHealth; &#125; &#125;&#125; DamagePlayer.cs123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class DamagePlayer : MonoBehaviour &#123; public int damage = 25; private void OnTriggerEnter(Collider other) &#123; PlayerStats playerStats = other.GetComponent&lt;PlayerStats&gt;(); if(playerStats != null) &#123; playerStats.TakeDamage(damage); &#125; &#125; &#125;&#125; PlayerStats.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerStats : MonoBehaviour &#123; public int healthLevel = 10; public int maxHealth; public int currentHealth; public HealthBar healthBar; AnimatorHandler animatorHandler; CapsuleCollider collider; private void Awake() &#123; animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); collider = GetComponent&lt;CapsuleCollider&gt;(); &#125; void Start() &#123; maxHealth = SetMaxHealthFromHealthLevel(); currentHealth = maxHealth; healthBar.SetMaxHealth(maxHealth); &#125; private int SetMaxHealthFromHealthLevel() &#123; maxHealth = healthLevel * 10; return maxHealth; &#125; public void TakeDamage(int damage) &#123; currentHealth = currentHealth - damage; healthBar.SetCurrentHealth(currentHealth); animatorHandler.PlayerTargetAnimation(\"Damage_Left\", true); if(currentHealth &lt;= 0) &#123; currentHealth = 0; animatorHandler.PlayerTargetAnimation(\"Dead\", true); collider.enabled = false; &#125; &#125; &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"},{"name":"UGUI","slug":"UGUI","permalink":"https://weimingjuncn.github.io/tags/UGUI/"}]},{"title":"DarkSoulsDemo（九）轻攻击与重攻击","slug":"DarkSoulsDemo（九）轻攻击与重攻击","date":"2020-06-23T03:19:28.000Z","updated":"2020-06-23T07:46:44.372Z","comments":true,"path":"2020/06/23/DarkSoulsDemo（九）轻攻击与重攻击/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/23/DarkSoulsDemo%EF%BC%88%E4%B9%9D%EF%BC%89%E8%BD%BB%E6%94%BB%E5%87%BB%E4%B8%8E%E9%87%8D%E6%94%BB%E5%87%BB/","excerpt":"关键词：动画层、脚本控制","text":"关键词：动画层、脚本控制 本文出自：Create DARK SOULS in Unity ► EP. 9 LIGHT &amp; HEAVY ATTACKS 用到的动画资源：Dynamic Sword Animset 中的R_Attack_05、R_Attack_06。 一、添加动画层打开Hunmanoid动画控制器，新建一个动画层，取名Override，将其Weight设置为1。在Override层新建一个Empty状态，将Base Layer里的Step_Back、Rolling、Land、Falling状态复制到Override层里并将前三个状态都指向Empty。 二、重写重置IsInteracting方法打开ResetIsInteracting.cs，修改类名并修改文件名为ResetAnimatorBool.cs。 将Override层里的Step_Back、Rolling、Land状态的Behaviour删掉 修改ResetAnimatorBool.cs 1234567891011121314using System.Collections;using System.Collections.Generic;using UnityEngine;public class ResetAnimatorBool : StateMachineBehaviour&#123; public string targetBool; public bool status; public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; animator.SetBool(targetBool, status); &#125;&#125; 给Empty状态添加Behaviour，并在target Bool里填上IsInteracting，并保持Parameters标签页里的IsInteracting没有勾选 三、攻击脚本打开WeaponItem.cs，添加以下变量声明 123[Header(\"One Handed Attack Animations\")]public string OH_Light_Attack_1;public string OH_Heavy_Attack_1; 新建一个脚本PlayerAttacker.cs，将其挂到Player上 编写PlayerAttacker.cs如下： 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerAttacker : MonoBehaviour &#123; AnimatorHandler animatorHandler; private void Awake() &#123; animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); &#125; public void HandleLightAttack(WeaponItem weapon) &#123; animatorHandler.PlayerTargetAnimation(weapon.OH_Light_Attack_1, true); &#125; public void HandleHeavyAttack(WeaponItem weapon) &#123; animatorHandler.PlayerTargetAnimation(weapon.OH_Heavy_Attack_1, true); &#125; &#125;&#125; 打开PlayerControls，给Player Action新建Action，起名为RB，设置Action Type为Button。 添加键位绑定，给RB绑定键盘E键和Right Shoulder [Gamepad]。新建一个Action，取名RT，添加键位绑定键盘R键和Right Trigger [Gamepad]，关闭PlayerControls点击Save。 打开InputHandler.cs，在类的最底下添加方法HandleAttackInput，在TickInput方法里调用并在开头补上变量声明： 123456789101112131415161718192021222324252627282930313233public bool rb_Input;public bool rt_Input;PlayerAttacker playerAttacker;PlayerInventory playerInventory;private void Awake()&#123; playerAttacker = GetComponent&lt;PlayerAttacker&gt;(); playerInventory = GetComponent&lt;PlayerInventory&gt;();&#125;public void TickInput(float delta)&#123; ... HandleAttackInput(delta);&#125;private void HandleAttackInput(float delta)&#123; inputActions.PlayerAction.RB.performed += inputActions =&gt; rb_Input = true; inputActions.PlayerAction.RT.performed += inputActions =&gt; rt_Input = true; if (rb_Input) &#123; playerAttacker.HandleLightAttack(playerInventory.rightWeapon); &#125; if (rt_Input) &#123; playerAttacker.HandleHeavyAttack(playerInventory.rightWeapon); &#125;&#125; 在PlayerManager.cs里的LateUpdate方法调用输入 12345private void LateUpdate()&#123; ... inputHandler.rb_Input = false; inputHandler.rt_Input = false; 四、添加动画将动画片段R_Attack_05、R_Attack_06拖入Animator窗口网格区域，分别重命名为Light_Attack、Heavy_Attack，然后都添加转换关系转向Empty状态。 在项目窗口Assets/Data/Iitems/Weapons下选中Sword，在Inspector里给OH_light_Attack填上light_Attack，给OH_Heavy_Attack填上Heavy_Attack。 播放游戏，按键盘E/手柄RB触发角色轻攻击，按键盘R/手柄RT触发角色重攻击。 五、脚本汇总ResetAnimatorBool.cs1234567891011121314using System.Collections;using System.Collections.Generic;using UnityEngine;public class ResetAnimatorBool : StateMachineBehaviour&#123; public string targetBool; public bool status; public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; animator.SetBool(targetBool, status); &#125;&#125; WeaponItem.cs12345678910111213141516using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; [CreateAssetMenu(menuName = \"Item/Weapon Item\")] public class WeaponItem : Item &#123; public GameObject modelPrefabs; public bool isUnarmed; [Header(\"One Handed Attack Animations\")] public string OH_Light_Attack_1; public string OH_Heavy_Attack_1; &#125;&#125; PlayerAttacker.cs12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerAttacker : MonoBehaviour &#123; AnimatorHandler animatorHandler; private void Awake() &#123; animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); &#125; public void HandleLightAttack(WeaponItem weapon) &#123; animatorHandler.PlayerTargetAnimation(weapon.OH_Light_Attack_1, true); &#125; public void HandleHeavyAttack(WeaponItem weapon) &#123; animatorHandler.PlayerTargetAnimation(weapon.OH_Heavy_Attack_1, true); &#125; &#125;&#125; InputHandler.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class InputHandler : MonoBehaviour &#123; public float horizontal; public float vertical; public float moveAmount; public float mouseX; public float mouseY; public bool b_Input; public bool rb_Input; public bool rt_Input; public bool rollFlag; public bool sprintFlag; public float rollInputTimer; PlayerControls inputActions; PlayerAttacker playerAttacker; PlayerInventory playerInventory; Vector2 movementInput; Vector2 cameraInput; private void Awake() &#123; playerAttacker = GetComponent&lt;PlayerAttacker&gt;(); playerInventory = GetComponent&lt;PlayerInventory&gt;(); &#125; public void OnEnable() &#123; if(inputActions == null) &#123; inputActions = new PlayerControls(); inputActions.PlayerMovement.Movement.performed += inputActions =&gt; movementInput = inputActions.ReadValue&lt;Vector2&gt;(); inputActions.PlayerMovement.Camera.performed += i =&gt; cameraInput = i.ReadValue&lt;Vector2&gt;(); &#125; inputActions.Enable(); &#125; private void OnDisable() &#123; inputActions.Disable(); &#125; public void TickInput(float delta) &#123; MoveInput(delta); HandleRollInput(delta); HandleAttackInput(delta); &#125; private void MoveInput(float delta) &#123; horizontal = movementInput.x; vertical = movementInput.y; moveAmount = Mathf.Clamp01(Mathf.Abs(horizontal) + Mathf.Abs(vertical)); mouseX = cameraInput.x; mouseY = cameraInput.y; &#125; private void HandleRollInput(float delta) &#123; b_Input = inputActions.PlayerAction.Roll.phase == UnityEngine.InputSystem.InputActionPhase.Started; if (b_Input) &#123; rollInputTimer += delta; sprintFlag = true; &#125; else &#123; if(rollInputTimer &gt; 0 &amp;&amp; rollInputTimer &lt; 0.5f) &#123; sprintFlag = false; rollFlag = true; &#125; rollInputTimer = 0; &#125; &#125; private void HandleAttackInput(float delta) &#123; inputActions.PlayerAction.RB.performed += inputActions =&gt; rb_Input = true; inputActions.PlayerAction.RT.performed += inputActions =&gt; rt_Input = true; if (rb_Input) &#123; playerAttacker.HandleLightAttack(playerInventory.rightWeapon); &#125; if (rt_Input) &#123; playerAttacker.HandleHeavyAttack(playerInventory.rightWeapon); &#125; &#125; &#125;&#125; PlayerManager.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerManager : MonoBehaviour &#123; InputHandler inputHandler; Animator anim; CameraHandler cameraHandler; PlayerLocomotion playerLocomotion; public bool isInteracting; [Header(\"Player Flags\")] public bool isSprinting; public bool isInAir; public bool isGrounded; private void Awake() &#123; cameraHandler = CameraHandler.singleton; &#125; void Start() &#123; inputHandler = GetComponent&lt;InputHandler&gt;(); anim = GetComponentInChildren&lt;Animator&gt;(); playerLocomotion = GetComponent&lt;PlayerLocomotion&gt;(); &#125; void Update() &#123; float delta = Time.deltaTime; isInteracting = anim.GetBool(\"IsInteracting\"); inputHandler.TickInput(delta); playerLocomotion.HandleMovement(delta); playerLocomotion.HandleRollingAndSprinting(delta); playerLocomotion.HandleFalling(delta, playerLocomotion.moveDirection); &#125; private void FixedUpdate() &#123; float delta = Time.fixedDeltaTime; if (cameraHandler != null) &#123; cameraHandler.FollowTarget(delta); cameraHandler.HandleCameraRotation(delta, inputHandler.mouseX, inputHandler.mouseY); &#125; &#125; private void LateUpdate() &#123; inputHandler.rollFlag = false; inputHandler.sprintFlag = false; inputHandler.rb_Input = false; inputHandler.rt_Input = false; if (isInAir) &#123; playerLocomotion.inAirTimer = playerLocomotion.inAirTimer + Time.deltaTime; &#125; &#125; &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"为动画角色添加刚性道具","slug":"为动画角色添加刚性道具","date":"2020-06-22T07:44:16.000Z","updated":"2020-06-22T09:28:40.862Z","comments":true,"path":"2020/06/22/为动画角色添加刚性道具/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/22/%E4%B8%BA%E5%8A%A8%E7%94%BB%E8%A7%92%E8%89%B2%E6%B7%BB%E5%8A%A0%E5%88%9A%E6%80%A7%E9%81%93%E5%85%B7/","excerpt":"Unity 2018 Cookbook | Charpter 10 3D Animation | Adding rigid props to animated characters 如果在建模和制作动画时没有为角色提供足够数量的道具，你可能需要让角色在游戏中收集新的道具。在本文中，我们将学习如何实例化一个GameObject，并将其分配给动画层次结构中的角色。","text":"Unity 2018 Cookbook | Charpter 10 3D Animation | Adding rigid props to animated characters 如果在建模和制作动画时没有为角色提供足够数量的道具，你可能需要让角色在游戏中收集新的道具。在本文中，我们将学习如何实例化一个GameObject，并将其分配给动画层次结构中的角色。 使用的资源链接：https://github.com/PacktPublishing/Unity-2018-Cookbook-Third-Edition/tree/master/Chapter10_3DAnimation/10_06_rigid_props 完成后项目资源链接：https://github.com/dr-matt-smith/unity-cookbook-2018-ch10-06-adding-rigid-props 一、提前确定道具在角色身上的位置新建一个3D项目，导入Props.unitypackage和纹理texture_pickupBadge.png，打开场景mecanimPlayground。 将项目窗口中的badge拖拽到Hierarchy中。将badge拖拽到mixamorig:Spine2的子项（ MsLaser |mixamorig:Hips | mixamorig:Spine |mixamorig:Spine1 | mixamorig:Spine2 ）。 修改badge的Transform | Position为 ( -0.08, 0, 0.15 )，修改Rotation ( 0.29, 0.14, -13.29 )，使之别在角色胸前。 记下Position和Rotation的值，然后从场景中删掉badge。 二、地上待捡道具添加一个3D 正方体取名为Cube_pickup，将其Transform | Position设置为( 0, 0.5, 2 )，勾选其Box Collider组件的IsTrigger选项。 从项目窗口将纹理texture_pickupBadge.png拖拽到Cube_pickup上。 三、编写脚本新建脚本PropManager.cs，将PropManager.cs拖拽到Cube_pickup，编写以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class PropManager : MonoBehaviour&#123; public GameObject prop; public Transform targetBone; public Vector3 positionOffset; public Vector3 rotationOffset; public bool destroyTrigger = true; void OnTriggerEnter(Collider collision) &#123; bool addPropCondition = targetBone.IsChildOf(collision.transform) &amp; !AlreadyHasChilObject(); if (addPropCondition) addProp(); &#125; private void addProp() &#123; GameObject newprop; newprop = Instantiate(prop, targetBone.position, targetBone.rotation) as GameObject; newprop.name = prop.name; newprop.transform.parent = targetBone; newprop.transform.localPosition += positionOffset; newprop.transform.localEulerAngles += rotationOffset; if (destroyTrigger) Destroy(gameObject); &#125; private bool AlreadyHasChilObject() &#123; string propName = prop.name; foreach(Transform child in targetBone) &#123; if (child.name == propName) return true; &#125; return false; &#125;&#125; 四、设置道具管理组件保存脚本，回到Unity编辑器，给Cube_pickup|PropManager(Script)设置以下参数： Prop : 预制体badge（从项目窗口里拖进来） Target Bone : mixamorig:Spine2（Hierarchy下MsLaser的子项） Position Offset : ( -0.08, 0, 0.15 ) Rotation Offset : ( 0.29, 0.14, -13.29 ) Destroy Trigger : 勾选 ( true ) 播放游戏，控制角色走向Cube_pickup，当角色触碰Cube_pickup时，Cube_pickup消失，角色胸前出现badge。 五、工作原理当角色触发捡起道具时，脚本将配置的预制体实例化一个并附在配置好的角色骨骼上（Target Bone）以及骨骼相对位置上(Position Offset, Rotation Offset)。附上的道具将随着其父物体运动而运动。 AlreadyHasChildObject()方法用于检测是否已存在同名道具以避免角色身上多出一个。 六、拓展创建一个相似的脚本来移除道具，在OnTriggerEnter方法里调用RemoveProp( )如下： 12345678910private void RemoveProp()&#123; string propName = prop.name; foreach(Transform child in targetBone) &#123; if (child.name == propName) Destroy(child.gameObject); &#125;&#125; 修改PropManager.cs如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class PropManager : MonoBehaviour&#123; public GameObject prop; public Transform targetBone; public Vector3 positionOffset; public Vector3 rotationOffset; public bool destroyTrigger = false; public bool removePropCondition = false; void OnTriggerEnter(Collider collision) &#123; bool addPropCondition = targetBone.IsChildOf(collision.transform) &amp; !AlreadyHasChilObject(); if (addPropCondition) addProp(); if (removePropCondition) RemoveProp(); &#125; private void addProp() &#123; GameObject newprop; newprop = Instantiate(prop, targetBone.position, targetBone.rotation) as GameObject; newprop.name = prop.name; newprop.transform.parent = targetBone; newprop.transform.localPosition += positionOffset; newprop.transform.localEulerAngles += rotationOffset; if (destroyTrigger) Destroy(gameObject); &#125; private void RemoveProp() &#123; string propName = prop.name; foreach(Transform child in targetBone) &#123; if (child.name == propName) Destroy(child.gameObject); &#125; &#125; private bool AlreadyHasChilObject() &#123; string propName = prop.name; foreach(Transform child in targetBone) &#123; if (child.name == propName) return true; &#125; return false; &#125;&#125; 播放游戏控制角色碰撞Cube_pickup，角色胸前出现badge后，后退到原来位置，勾选Cube_pickup|PropManager（Script）|removePropCondition，再次碰撞Cube_pickup，角色胸前的badge消除。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（八）武器","slug":"DarkSoulsDemo（八）武器","date":"2020-06-21T15:35:20.000Z","updated":"2020-06-23T07:45:44.855Z","comments":true,"path":"2020/06/21/DarkSoulsDemo（八）武器/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/21/DarkSoulsDemo%EF%BC%88%E5%85%AB%EF%BC%89%E6%AD%A6%E5%99%A8/","excerpt":"关键词：脚本控制、预制体","text":"关键词：脚本控制、预制体 本文出自：Create DARK SOULS in Unity ► EP. 8 WEAPON ITEMS 文中用到的武器模型SM_Wep_Sword_01和角色模型Chr_FantasyHero_Preset_35出自：Polygon Fantasy Hero Characters 一、自制Item类、Weapon类的建立与使用新建一个脚本Item.cs，编写代码： 123456789101112using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class Item : ScriptableObject &#123; [Header(\"Item Information\")] public Sprite itemIcon; public string itemName; &#125;&#125; 新建一个脚本Weapon.cs，编写代码： 123456789101112using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; [CreateAssetMenu(menuName = \"Item/Weapon Item\")] public class WeaponItem : Item &#123; public GameObject modelPrefabs; public bool isUnarmed; &#125;&#125; 将武器模型SM_Wep_Sword_01转为预制体并命名为Sword_01，这个过程会弹出一个对话框，选则Original Prefabs，删掉场景中的SM_Wep_Sword_01或Sword_01。再Assets下新建一个Data文件夹，将Prefabs文件夹拖入其中，再Data文件夹下新建一个Items文件夹，再Item文件夹里再建一个Weapons文件夹，再Assets/Data/Items/Weapons下新建一个Weapon Item，取名为Sword。 选中Weapon Item Sword，填写物品名称，配置模型预制体 二、写脚本管理武器在Assets文件夹下新建一个脚本WeaponHolderSlot.cs，编写代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class WeaponHolderSlot : MonoBehaviour &#123; public Transform parentOverride; public bool isLeftHandSlot; public bool isRightHandSlot; public GameObject currentWeaponModel; public void UnLoadWeapon() &#123; if(currentWeaponModel != null) &#123; currentWeaponModel.SetActive(false); &#125; &#125; public void UnloadWeaponAndDestroy() &#123; if (currentWeaponModel != null) &#123; Destroy(currentWeaponModel); &#125; &#125; public void LoadWeaponModel(WeaponItem weaponItem) &#123; UnloadWeaponAndDestroy(); if(weaponItem== null) &#123; UnLoadWeapon(); return; &#125; GameObject model = Instantiate(weaponItem.modelPrefabs) as GameObject; if(model != null) &#123; if(parentOverride != null) &#123; model.transform.parent = parentOverride; &#125; else &#123; model.transform.parent = transform; &#125; model.transform.localPosition = Vector3.zero; model.transform.localRotation = Quaternion.identity; model.transform.localScale = Vector3.one; &#125; currentWeaponModel = model; &#125; &#125;&#125; 回到Unity编辑器，展开场景中角色预制体找到他的右手，挂上WeaponHolderSlot.cs，并做如下配置。 给Hand_L新建一个空物体，取名为Left Hand Override，给Hand_L添加组件Weapon Holder Slot (Script)，将Left Hand Override拖拽到Parent Override，勾选Is Left Hand Slot。 新建脚本WeaponSlotManager.cs，编写脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class WeaponSlotManager : MonoBehaviour &#123; WeaponHolderSlot leftHandSlot; WeaponHolderSlot rightHandSlot; private void Awake() &#123; WeaponHolderSlot[] weaponHolderSlots = GetComponentsInChildren&lt;WeaponHolderSlot&gt;(); foreach(WeaponHolderSlot weaponSlot in weaponHolderSlots) &#123; if (weaponSlot.isLeftHandSlot) &#123; leftHandSlot = weaponSlot; &#125;else if (weaponSlot.isRightHandSlot) &#123; rightHandSlot = weaponSlot; &#125; &#125; &#125; public void LoadWeaponOnSlot(WeaponItem weaponItem, bool isLeft) &#123; if (isLeft) &#123; leftHandSlot.LoadWeaponModel(weaponItem); &#125; else &#123; rightHandSlot.LoadWeaponModel(weaponItem); &#125; &#125; &#125;&#125; 将WeaponSlotManager.cs作为组件添加到Player预制体上 新建脚本PlayerInventory.cs，编写代码如下： 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerInventory : MonoBehaviour &#123; WeaponSlotManager weaponSlotManager; public WeaponItem rightWeapon; public WeaponItem leftWeapon; private void Awake() &#123; weaponSlotManager = GetComponentInChildren&lt;WeaponSlotManager&gt;(); &#125; private void Start() &#123; weaponSlotManager.LoadWeaponOnSlot(rightWeapon, false); weaponSlotManager.LoadWeaponOnSlot(leftWeapon, true); &#125; &#125;&#125; 将PlayerInventory.cs作为组件添加到Player，配置Right Weapon和Left Weapon 三、自制含Pivot的武器预制体右键Hierarchy中的预制体Sword创建一个空物体，然后右键预制体Sword，选择Unpack Prefabs Completely完全解包预制体，然后把GameObject从Sword子项中拖出，重命名为Sword_01，建立子项空物体，重命名为Weapon Pivot，再将Sword拖到Weapon Pivot子项。 将Sword_01转为预制体，删除场景中的Sword_01。在项目窗口里选中Sword_01，点击Open Prefabs按钮进入预制体编辑场景。展开Hierarchy里的Sword_01，选中Weapon Pivot，修改其Transform|Scale为（100，100，100）。 点击Scenes返回SampleScene。 播放游戏，可以看到Sword_01附在角色手上，但位置有点奇怪，我们可以暂停游戏来进行修正。 四、修正武器位置在场景中点击选中右手上的剑，在Hierarchy里将自动选中Sword_01|Weapon Pivot|Sword，选中Sword Pivot，调整位置至合理，然后右键Sword Pivot|Transform复制组件。 然后停止播放游戏，选中项目窗口里的预制体Sword_01，点击Open Prefabs，选中WeaponPivot，粘贴组件。 播放游戏，暂停游戏调整左手剑的位置，但这次我们调的是Left Hand Override的Transform，调整好后复制组件。 停止游戏，找到Left Hand Override，粘贴组件。 好现在播放游戏，角色手上剑的位置都基本正常了。 五、脚本汇总Item.cs123456789101112using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class Item : ScriptableObject &#123; [Header(\"Item Information\")] public Sprite itemIcon; public string itemName; &#125;&#125; Weapon.cs123456789101112using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; [CreateAssetMenu(menuName = \"Item/Weapon Item\")] public class WeaponItem : Item &#123; public GameObject modelPrefabs; public bool isUnarmed; &#125;&#125; WeaponHolderSlot.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class WeaponHolderSlot : MonoBehaviour &#123; public Transform parentOverride; public bool isLeftHandSlot; public bool isRightHandSlot; public GameObject currentWeaponModel; public void UnLoadWeapon() &#123; if(currentWeaponModel != null) &#123; currentWeaponModel.SetActive(false); &#125; &#125; public void UnloadWeaponAndDestroy() &#123; if (currentWeaponModel != null) &#123; Destroy(currentWeaponModel); &#125; &#125; public void LoadWeaponModel(WeaponItem weaponItem) &#123; UnloadWeaponAndDestroy(); if(weaponItem== null) &#123; UnLoadWeapon(); return; &#125; GameObject model = Instantiate(weaponItem.modelPrefabs) as GameObject; if(model != null) &#123; if(parentOverride != null) &#123; model.transform.parent = parentOverride; &#125; else &#123; model.transform.parent = transform; &#125; model.transform.localPosition = Vector3.zero; model.transform.localRotation = Quaternion.identity; model.transform.localScale = Vector3.one; &#125; currentWeaponModel = model; &#125; &#125;&#125; WeaponSlotManager.cs1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class WeaponSlotManager : MonoBehaviour &#123; WeaponHolderSlot leftHandSlot; WeaponHolderSlot rightHandSlot; private void Awake() &#123; WeaponHolderSlot[] weaponHolderSlots = GetComponentsInChildren&lt;WeaponHolderSlot&gt;(); foreach(WeaponHolderSlot weaponSlot in weaponHolderSlots) &#123; if (weaponSlot.isLeftHandSlot) &#123; leftHandSlot = weaponSlot; &#125;else if (weaponSlot.isRightHandSlot) &#123; rightHandSlot = weaponSlot; &#125; &#125; &#125; public void LoadWeaponOnSlot(WeaponItem weaponItem, bool isLeft) &#123; if (isLeft) &#123; leftHandSlot.LoadWeaponModel(weaponItem); &#125; else &#123; rightHandSlot.LoadWeaponModel(weaponItem); &#125; &#125; &#125;&#125; PlayerInventory.cs123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerInventory : MonoBehaviour &#123; WeaponSlotManager weaponSlotManager; public WeaponItem rightWeapon; public WeaponItem leftWeapon; private void Awake() &#123; weaponSlotManager = GetComponentInChildren&lt;WeaponSlotManager&gt;(); &#125; private void Start() &#123; weaponSlotManager.LoadWeaponOnSlot(rightWeapon, false); weaponSlotManager.LoadWeaponOnSlot(leftWeapon, true); &#125; &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（七）角色下落与着陆检测","slug":"DarkSoulsDemo（七）角色下落与着陆检测","date":"2020-06-21T11:38:47.000Z","updated":"2020-06-23T07:46:35.638Z","comments":true,"path":"2020/06/21/DarkSoulsDemo（七）角色下落与着陆检测/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/21/DarkSoulsDemo%EF%BC%88%E4%B8%83%EF%BC%89%E8%A7%92%E8%89%B2%E4%B8%8B%E8%90%BD%E4%B8%8E%E7%9D%80%E9%99%86%E6%A3%80%E6%B5%8B/","excerpt":"关键字：下落检测、着陆检测","text":"关键字：下落检测、着陆检测 本文出自：https://www.youtube.com/watch?v=dJdmUgqgZjU 使用到的动画片段Land_Base_Wait、Jump_Down_C_Loop，出自 Runner Action Animation Pack 一、修改碰撞体选中Player，修改其胶囊碰撞体组件参数Height为1.5。 二、编辑脚本打开PlayerManager.cs，声明变量isInAir、isGrounded 12public bool isInAir;public bool isGrounded; 打开PlayerLocomotion.cs，声明以下变量 1234567891011121314[Header(\"Ground &amp; Air Detection Stats\")][SerializeField]float groundDetectionRayStartPoint = 0.5f;[SerializeField]float minimumDistanceNeededToBeginFall = 1f;[SerializeField]float groundDirectionRayDistance = 0.2f;LayerMask ignoreForGroundCheck;public float inAirTimer;[Header(\"Movement Stats\")]...[SerializeField]float fallingSpeed = 45; 回到PlayerManager.cs，再LateUpdate方法里添加以下语句 12345678private void LateUpdate()&#123; ... if (isInAir) &#123; playerLocomotion.inAirTimer = playerLocomotion.inAirTimer + Time.deltaTime; &#125;&#125; 再PlayerLocomotion.cs编写HandleFalling方法，修改moveDirection声明前加上关键字public。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990...public Vector3 moveDirection...void Start()&#123; ... playerManager.isGrounded = true; ignoreForGroundCheck = ~(1 &lt;&lt; 8 | 1 &lt;&lt; 11);&#125;...public void HandleFalling(float delta, Vector3 moveDirection)&#123; playerManager.isGrounded = false; RaycastHit hit; Vector3 origin = myTransform.position; origin.y += groundDetectionRayStartPoint; if(Physics.Raycast(origin, myTransform.forward, out hit, 0.4f)) &#123; moveDirection = Vector3.zero; &#125; if (playerManager.isInAir) &#123; rigidbody.AddForce(-Vector3.up * fallingSpeed); //This Force kicks your ass from the edge. ↓ rigidbody.AddForce(moveDirection * fallingSpeed / 3f); &#125; Vector3 dir = moveDirection; dir.Normalize(); origin = origin + dir * groundDirectionRayDistance; targetPostion = myTransform.position; Debug.DrawRay(origin, = -Vector3.up * minimumDistanceNeededToBeginFall, Color.red, 0.1f, false); if(Physics.Raycast(origin, -Vector3.up, out hit, minimumDistanceNeededToBeginFall, ignoreForGroundCheck)) &#123; normalVector = hit.normal; Vector3 tp = hit.point; playerManager.isGrounded = true; targetPostion.y = tp.y; if (playerManager.isInAir) &#123; if(inAirTimer &gt; 0.5f) &#123; Debug.Log(\"You were in the air for\" + inAirTimer); animatorHandler.PlayerTargetAnimation(\"Land\", true); &#125; else &#123; animatorHandler.PlayerTargetAnimation(\"Empty\", false); inAirTimer = 0; &#125; playerManager.isInAir = false; &#125; &#125; else &#123; if (playerManager.isGrounded) &#123; playerManager.isGrounded = false; &#125; if(playerManager.isInAir == false) &#123; if(playerManager.isInteracting == false) &#123; animatorHandler.PlayerTargetAnimation(\"Falling\", true); &#125; Vector3 vel = rigidbody.velocity; vel.Normalize(); rigidbody.velocity = vel * (movementSpeed / 2); playerManager.isInAir = true; &#125; &#125; if (playerManager.isGrounded) &#123; if(playerManager.isInteracting || inputHandler.moveAmount &gt; 0) &#123; myTransform.position = Vector3.Lerp(myTransform.position, targetPostion, Time.deltaTime); &#125; else &#123; myTransform.position = targetPostion; &#125; &#125;&#125; 在PlayerManager.cs的Update方法里调用HandleFalling方法。 12345void Update()&#123;...playerLocomotion.HandleFalling(delta, playerLocomotion.moveDirection);&#125; 三、添加动画状态将着陆动画片段Land_Base_Wait拖入动画Base Layer中，重命名为Land，建立到Locomotion的转变关系，添加ResetIsInteracting Behaviour。 将下落动画片段Jump_Down_C_Loop拖入动画Base Layer中，重命名为Falling，不要建立任何转变关系，不添加Behaviour，勾选Foot IK。 打开PlayerLocomotion.cs，在HandleMovement方法开头添加上角色互动信号判断： 1234567public void HandleMovement(float delta)&#123; if (inputHandler.rollFlag) return; if (playerManager.isInteracting) return; ... 保存脚本，将角色放置在高处，播放游戏，让角色往下跳，角色检测下落做出下坠动作，检测着陆并播放着陆动画。 四、可能遇到的问题角色卡在边缘没有下落 可能原因：水平方向的受力太小，水平方向速度满，胶囊碰撞体正好卡在边缘。 可以增大HandleFalling方法中” rigidbody.AddForce(moveDirection * fallingSpeed / 3f); “的值大小。即将末尾的3f减小或去掉。但可能会造成下落时“滑翔”太远。 123456789public void HandleFalling(float delta, Vector3 moveDirection)&#123; ... if (playerManager.isInAir) &#123; rigidbody.AddForce(-Vector3.up * fallingSpeed); //This Force kicks your ass from the edge. ↓ rigidbody.AddForce(moveDirection * fallingSpeed / 3f); &#125; 五、脚本汇总PlayerManager.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerManager : MonoBehaviour &#123; InputHandler inputHandler; Animator anim; CameraHandler cameraHandler; PlayerLocomotion playerLocomotion; public bool isInteracting; [Header(\"Player Flags\")] public bool isSprinting; public bool isInAir; public bool isGrounded; private void Awake() &#123; cameraHandler = CameraHandler.singleton; &#125; void Start() &#123; inputHandler = GetComponent&lt;InputHandler&gt;(); anim = GetComponentInChildren&lt;Animator&gt;(); playerLocomotion = GetComponent&lt;PlayerLocomotion&gt;(); &#125; void Update() &#123; float delta = Time.deltaTime; isInteracting = anim.GetBool(\"IsInteracting\"); inputHandler.TickInput(delta); playerLocomotion.HandleMovement(delta); playerLocomotion.HandleRollingAndSprinting(delta); playerLocomotion.HandleFalling(delta, playerLocomotion.moveDirection); &#125; private void FixedUpdate() &#123; float delta = Time.fixedDeltaTime; if (cameraHandler != null) &#123; cameraHandler.FollowTarget(delta); cameraHandler.HandleCameraRotation(delta, inputHandler.mouseX, inputHandler.mouseY); &#125; &#125; private void LateUpdate() &#123; inputHandler.rollFlag = false; inputHandler.sprintFlag = false; if (isInAir) &#123; playerLocomotion.inAirTimer = playerLocomotion.inAirTimer + Time.deltaTime; &#125; &#125; &#125;&#125; PlayerLocomotion.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class PlayerLocomotion : MonoBehaviour &#123; PlayerManager playerManager; Transform cameraObject; InputHandler inputHandler; public Vector3 moveDirection; [HideInInspector] public Transform myTransform; [HideInInspector] public AnimatorHandler animatorHandler; public new Rigidbody rigidbody; public GameObject normalCamera; [Header(\"Ground &amp; Air Detection Stats\")] [SerializeField] float groundDetectionRayStartPoint = 0.5f; [SerializeField] float minimumDistanceNeededToBeginFall = 1f; [SerializeField] float groundDirectionRayDistance = 0.2f; LayerMask ignoreForGroundCheck; public float inAirTimer; [Header(\"Movement Stats\")] [SerializeField] float walkingSpeed = 3; [SerializeField] float movementSpeed = 5; [SerializeField] float sprintSpeed = 7; [SerializeField] float rotationSpeed = 10; [SerializeField] float fallingSpeed = 45; // Start is called before the first frame update void Start() &#123; playerManager = GetComponent&lt;PlayerManager&gt;(); rigidbody = GetComponent&lt;Rigidbody&gt;(); inputHandler = GetComponent&lt;InputHandler&gt;(); animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); cameraObject = Camera.main.transform; myTransform = transform; animatorHandler.Initialize(); playerManager.isGrounded = true; ignoreForGroundCheck = ~(1 &lt;&lt; 8 | 1 &lt;&lt; 11); &#125; #region Movement Vector3 normalVector; Vector3 targetPostion; private void HandleRotation(float delta) &#123; Vector3 targetDir = Vector3.zero; float moveOverride = inputHandler.moveAmount; targetDir = cameraObject.forward * inputHandler.vertical; targetDir += cameraObject.right * inputHandler.horizontal; targetDir.Normalize(); targetDir.y = 0; if(targetDir == Vector3.zero) &#123; targetDir = myTransform.forward; &#125; float rs = rotationSpeed; Quaternion tr = Quaternion.LookRotation(targetDir); Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta); myTransform.rotation = targetRotation; &#125; public void HandleMovement(float delta) &#123; if (inputHandler.rollFlag) return; if (playerManager.isInteracting) return; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; moveDirection.Normalize(); moveDirection.y = 0; float speed = movementSpeed; if (inputHandler.sprintFlag &amp;&amp; inputHandler.moveAmount &gt; 0.5) &#123; speed = sprintSpeed; playerManager.isSprinting = true; moveDirection *= speed; &#125; else &#123; if(inputHandler.moveAmount &lt; 0.5) &#123; moveDirection *= walkingSpeed; playerManager.isSprinting = false; &#125; else &#123; moveDirection *= speed; playerManager.isSprinting = false; &#125; &#125; Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector); rigidbody.velocity = projectedVelocity; animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0, playerManager.isSprinting); if (animatorHandler.canRotate) &#123; HandleRotation(delta); &#125; &#125; public void HandleRollingAndSprinting(float delta) &#123; if (animatorHandler.anim.GetBool(\"IsInteracting\")) return; if (inputHandler.rollFlag) &#123; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; if(inputHandler.moveAmount &gt; 0) &#123; animatorHandler.PlayerTargetAnimation(\"Rolling\", true); moveDirection.y = 0; Quaternion rollRotation = Quaternion.LookRotation(moveDirection); myTransform.rotation = rollRotation; &#125; else &#123; animatorHandler.PlayerTargetAnimation(\"Step_Back\", true); &#125; &#125; &#125; public void HandleFalling(float delta, Vector3 moveDirection) &#123; playerManager.isGrounded = false; RaycastHit hit; Vector3 origin = myTransform.position; origin.y += groundDetectionRayStartPoint; if(Physics.Raycast(origin, myTransform.forward, out hit, 0.4f)) &#123; moveDirection = Vector3.zero; &#125; if (playerManager.isInAir) &#123; rigidbody.AddForce(-Vector3.up * fallingSpeed); //This Force kicks your ass from the edge. ↓ rigidbody.AddForce(moveDirection * fallingSpeed / 3f); &#125; Vector3 dir = moveDirection; dir.Normalize(); origin = origin + dir * groundDirectionRayDistance; targetPostion = myTransform.position; Debug.DrawRay(origin, -Vector3.up * minimumDistanceNeededToBeginFall, Color.red, 0.1f, false); if(Physics.Raycast(origin, -Vector3.up, out hit, minimumDistanceNeededToBeginFall, ignoreForGroundCheck)) &#123; normalVector = hit.normal; Vector3 tp = hit.point; playerManager.isGrounded = true; targetPostion.y = tp.y; if (playerManager.isInAir) &#123; if(inAirTimer &gt; 0.5f) &#123; Debug.Log(\"You were in the air for \" + inAirTimer); animatorHandler.PlayerTargetAnimation(\"Land\", true); &#125; else &#123; animatorHandler.PlayerTargetAnimation(\"Empty\", false); inAirTimer = 0; &#125; playerManager.isInAir = false; &#125; &#125; else &#123; if (playerManager.isGrounded) &#123; playerManager.isGrounded = false; &#125; if(playerManager.isInAir == false) &#123; if(playerManager.isInteracting == false) &#123; animatorHandler.PlayerTargetAnimation(\"Falling\", true); &#125; Vector3 vel = rigidbody.velocity; vel.Normalize(); rigidbody.velocity = vel * (movementSpeed / 2); playerManager.isInAir = true; &#125; &#125; if (playerManager.isGrounded) &#123; if(playerManager.isInteracting || inputHandler.moveAmount &gt; 0) &#123; myTransform.position = Vector3.Lerp(myTransform.position, targetPostion, Time.deltaTime); &#125; else &#123; myTransform.position = targetPostion; &#125; &#125; &#125; #endregion &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"SoulsLikeDemo（一）自制结构","slug":"SoulsLikeDemo（一）自制结构","date":"2020-06-21T07:40:43.000Z","updated":"2020-06-21T10:31:42.131Z","comments":true,"path":"2020/06/21/SoulsLikeDemo（一）自制结构/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/21/SoulsLikeDemo%EF%BC%88%E4%B8%80%EF%BC%89%E8%87%AA%E5%88%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（六）重组脚本","slug":"DarkSoulsDemo（六）重组脚本","date":"2020-06-21T04:20:20.000Z","updated":"2020-06-23T07:46:21.711Z","comments":true,"path":"2020/06/21/DarkSoulsDemo（六）重组脚本/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/21/DarkSoulsDemo%EF%BC%88%E5%85%AD%EF%BC%89%E9%87%8D%E7%BB%84%E8%84%9A%E6%9C%AC/","excerpt":"关键词：脚本，功能结构","text":"关键词：脚本，功能结构 一、功能结构概况 PlayerManager.cs 管理Update方法 管理信号标示（Flag） 将其他功能模块（脚本）连接到Player上 InputHandler.cs 监测玩家输入 PlayerLocomotion.cs 管理Player所有的基础移动功能 AnimationHandler.cs 管理Player所有要执行的动画 … 二、脚本重组PlayerManager.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerManager : MonoBehaviour &#123; InputHandler inputHandler; Animator anim; CameraHandler cameraHandler; PlayerLocomotion playerLocomotion; public bool isInteracting; [Header(\"Player Flags\")] public bool isSprinting; private void Awake() &#123; cameraHandler = CameraHandler.singleton; &#125; void Start() &#123; inputHandler = GetComponent&lt;InputHandler&gt;(); anim = GetComponentInChildren&lt;Animator&gt;(); playerLocomotion = GetComponent&lt;PlayerLocomotion&gt;(); &#125; void Update() &#123; float delta = Time.deltaTime; isInteracting = anim.GetBool(\"IsInteracting\"); inputHandler.TickInput(delta); playerLocomotion.HandleMovement(delta); playerLocomotion.HandleRollingAndSprinting(delta); &#125; private void FixedUpdate() &#123; float delta = Time.fixedDeltaTime; if (cameraHandler != null) &#123; cameraHandler.FollowTarget(delta); cameraHandler.HandleCameraRotation(delta, inputHandler.mouseX, inputHandler.mouseY); &#125; &#125; private void LateUpdate() &#123; inputHandler.rollFlag = false; inputHandler.sprintFlag = false; &#125; &#125;&#125; InputHandler.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class InputHandler : MonoBehaviour &#123; public float horizontal; public float vertical; public float moveAmount; public float mouseX; public float mouseY; public bool b_Input; public bool rollFlag; public bool sprintFlag; public float rollInputTimer; PlayerControls inputActions; Vector2 movementInput; Vector2 cameraInput; public void OnEnable() &#123; if(inputActions == null) &#123; inputActions = new PlayerControls(); inputActions.PlayerMovement.Movement.performed += inputActions =&gt; movementInput = inputActions.ReadValue&lt;Vector2&gt;(); inputActions.PlayerMovement.Camera.performed += i =&gt; cameraInput = i.ReadValue&lt;Vector2&gt;(); &#125; inputActions.Enable(); &#125; private void OnDisable() &#123; inputActions.Disable(); &#125; public void TickInput(float delta) &#123; MoveInput(delta); HandleRollInput(delta); &#125; private void MoveInput(float delta) &#123; horizontal = movementInput.x; vertical = movementInput.y; moveAmount = Mathf.Clamp01(Mathf.Abs(horizontal) + Mathf.Abs(vertical)); mouseX = cameraInput.x; mouseY = cameraInput.y; &#125; private void HandleRollInput(float delta) &#123; b_Input = inputActions.PlayerAction.Roll.phase == UnityEngine.InputSystem.InputActionPhase.Started; if (b_Input) &#123; rollInputTimer += delta; sprintFlag = true; &#125; else &#123; if(rollInputTimer &gt; 0 &amp;&amp; rollInputTimer &lt; 0.5f) &#123; sprintFlag = false; rollFlag = true; &#125; rollInputTimer = 0; &#125; &#125; &#125;&#125; PlayerLocomotion.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class PlayerLocomotion : MonoBehaviour &#123; PlayerManager playerManager; Transform cameraObject; InputHandler inputHandler; Vector3 moveDirection; [HideInInspector] public Transform myTransform; [HideInInspector] public AnimatorHandler animatorHandler; public new Rigidbody rigidbody; public GameObject normalCamera; [Header(\"Movement Stats\")] [SerializeField] float walkingSpeed = 3; [SerializeField] float movementSpeed = 5; [SerializeField] float sprintSpeed = 7; [SerializeField] float rotationSpeed = 10; // Start is called before the first frame update void Start() &#123; playerManager = GetComponent&lt;PlayerManager&gt;(); rigidbody = GetComponent&lt;Rigidbody&gt;(); inputHandler = GetComponent&lt;InputHandler&gt;(); animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); cameraObject = Camera.main.transform; myTransform = transform; animatorHandler.Initialize(); &#125; #region Movement Vector3 normalVector; Vector3 targetPostion; private void HandleRotation(float delta) &#123; Vector3 targetDir = Vector3.zero; float moveOverride = inputHandler.moveAmount; targetDir = cameraObject.forward * inputHandler.vertical; targetDir += cameraObject.right * inputHandler.horizontal; targetDir.Normalize(); targetDir.y = 0; if(targetDir == Vector3.zero) &#123; targetDir = myTransform.forward; &#125; float rs = rotationSpeed; Quaternion tr = Quaternion.LookRotation(targetDir); Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta); myTransform.rotation = targetRotation; &#125; public void HandleMovement(float delta) &#123; if (inputHandler.rollFlag) return; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; moveDirection.Normalize(); moveDirection.y = 0; float speed = movementSpeed; if (inputHandler.sprintFlag &amp;&amp; inputHandler.moveAmount &gt; 0.5) &#123; speed = sprintSpeed; playerManager.isSprinting = true; moveDirection *= speed; &#125; else &#123; if(inputHandler.moveAmount &lt; 0.5) &#123; moveDirection *= walkingSpeed; playManager.isSprinting = false; &#125; else &#123; moveDirection *= speed; playManager.isSprinting = false; &#125; &#125; Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector); rigidbody.velocity = projectedVelocity; animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0, playerManager.isSprinting); if (animatorHandler.canRotate) &#123; HandleRotation(delta); &#125; &#125; public void HandleRollingAndSprinting(float delta) &#123; if (animatorHandler.anim.GetBool(\"IsInteracting\")) return; if (inputHandler.rollFlag) &#123; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; if(inputHandler.moveAmount &gt; 0) &#123; animatorHandler.PlayerTargetAnimation(\"Rolling\", true); moveDirection.y = 0; Quaternion rollRotation = Quaternion.LookRotation(moveDirection); myTransform.rotation = rollRotation; &#125; else &#123; animatorHandler.PlayerTargetAnimation(\"Step_Back\", true); &#125; &#125; &#125; #endregion &#125;&#125; AnimatorHandler.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class AnimatorHandler : MonoBehaviour &#123; PlayerManager playerManager; public Animator anim; InputHandler inputHandler; PlayerLocomotion playerLocomotion; int vertical; int horizontal; public bool canRotate; public void Initialize() &#123; playerManager = GetComponentInParent&lt;PlayerManager&gt;(); anim = GetComponent&lt;Animator&gt;(); inputHandler = GetComponentInParent&lt;InputHandler&gt;(); playerLocomotion = GetComponentInParent&lt;PlayerLocomotion&gt;(); vertical = Animator.StringToHash(\"Vertical\"); horizontal = Animator.StringToHash(\"Horizontal\"); &#125; public void UpdateAnimatorValues(float verticalMovement, float horizontalMovement, bool isSprinting) &#123; #region Vertical float v = 0; if(verticalMovement &gt; 0 &amp;&amp; verticalMovement &lt; 0.55f) &#123; v = 0.5f; &#125;else if(verticalMovement &gt; 0.55f) &#123; v = 1; &#125;else if(verticalMovement &lt; 0 &amp;&amp; verticalMovement &gt; -0.55f) &#123; v = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; v = -1; &#125; else &#123; v = 0; &#125; #endregion #region Horizontal float h = 0; if(horizontalMovement &gt; 0 &amp;&amp; horizontalMovement &lt; 0.55f) &#123; h = 0.5f; &#125;else if(horizontalMovement &gt; 0.55f) &#123; h = 1; &#125;else if(horizontalMovement &lt; 0 &amp;&amp; horizontalMovement &gt; -0.55f) &#123; h = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; h = -1; &#125; else &#123; h = 0; &#125; #endregion if (isSprinting) &#123; v = 2; h = horizontalMovement; &#125; anim.SetFloat(vertical, v, 0.1f, Time.deltaTime); anim.SetFloat(horizontal, h, 0.1f, Time.deltaTime); &#125; public void PlayerTargetAnimation(string targetAnim, bool isInteracting) &#123; anim.applyRootMotion = isInteracting; anim.SetBool(\"IsInteracting\", true); anim.CrossFade(targetAnim, 0.2f); &#125; public void CanRotate() &#123; canRotate = true; &#125; public void StopRotate() &#123; canRotate = false; &#125; private void OnAnimatorMove() &#123; if (playerManager.isInteracting == false) return; float delta = Time.deltaTime; playerLocomotion.rigidbody.drag = 0; Vector3 deltaPosition = anim.deltaPosition; deltaPosition.y = 0; Vector3 velocity = deltaPosition / delta; playerLocomotion.rigidbody.velocity = velocity; &#125; &#125;&#125; 三、可能出现的问题以上四个脚本修改完后，播放游戏，摄像机会出现不跟随的情况。 解决方法：把Hierarchy中Player原来的CameraHandler组件删除掉，再重新添加上，重新配置Target Transform、Camera Transform、Camera Pivot Transform即可，参考《DarkSoulsDemo（二）摄像机管理器》。","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（五）角色冲刺","slug":"DarkSoulsDemo（五）角色冲刺","date":"2020-06-20T10:50:42.000Z","updated":"2020-06-23T07:46:28.941Z","comments":true,"path":"2020/06/20/DarkSoulsDemo（五）角色冲刺/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/20/DarkSoulsDemo%EF%BC%88%E4%BA%94%EF%BC%89%E8%A7%92%E8%89%B2%E5%86%B2%E5%88%BA/","excerpt":"关键词：混合树，脚本控制","text":"关键词：混合树，脚本控制 本文出自：https://www.youtube.com/watch?v=gyqfmE_1aus&amp;t=315s 一、导入、添加冲刺动画片段打开动画控制器Humanoid，双击进入Locomotion，选中Blend Tree，在Inspector的Motion列表里点击加号新增动作域，将动画片段Sprint拖入。修改Pos X、Pos Y的值分别为0、2。 二、修改脚本用VS2017打开AnimatorHandler.cs，修改UpdateAnimatorValues方法如下： 123456789101112131415public void UpdateAnimatorValues(float verticalMovement, float horizontalMovement, bool isSprinting)&#123; #region Vertical ... #region Horizontal ... if (isSprinting) &#123; v = 2; h = horizontalMovement; &#125; anim.SetFloat(vertical, v, 0.1f, Time.deltaTime); anim.SetFloat(horizontal, h, 0.1f, Time.deltaTime);&#125; 在PlayerLocomotion.cs里添加声明bool类型变量isSprinting，并在HandleMovement()方法里传入animatorHandler.UpdateAnimatorValues()方法。 12345678public bool isSprinting;public void HandleMovement(float delta)&#123; ... animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0, isSprinting); ...&#125; 在InputHandler.cs里添加变量声明rollInputTimer、sprintFlag，修改HandleRollInput()方法。 12345678910111213141516171819202122public float rollInputTimer;public bool sprintFlag;private void HandleRollInput(float delta)&#123; b_Input = inputActions.PlayerAction.Roll.phase == UnityEngine.InputSystem.InputActionPhase.Started; if (b_Input) &#123; rollInputTimer += delta; sprintFlag = true; &#125; else &#123; if(rollInputTimer &gt; 0 &amp;&amp; rollInputTimer &lt; 0.5f) &#123; sprintFlag = false; rollFlag = true; &#125; rollInputTimer = 0; &#125;&#125; 打开PlayerLocomotion.cs，声明变量sprintSpeed，修改HandlerMovement方法 123456789101112131415161718192021222324252627282930313233343536[SerializeField]float sprintSpeed = 7;public void HandleMovement(float delta)&#123; if (inputHandler.rollFlag) return; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; moveDirection.Normalize(); moveDirection.y = 0; float speed = movementSpeed; if (inputHandler.sprintFlag) &#123; speed = sprintSpeed; isSprinting = true; moveDirection *= speed; &#125; else &#123; moveDirection *= speed; &#125; Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector); rigidbody.velocity = projectedVelocity; animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0, isSprinting); if (animatorHandler.canRotate) &#123; HandleRotation(delta); &#125;&#125; 在Update方法里添加对isSprinting的赋值； 12345678910public void Update()&#123; float delta = Time.deltaTime; isSprinting = inputHandler.b_Input; inputHandler.TickInput(delta); HandleMovement(delta); HandleRollingAndSprinting(delta);&#125; 打开PlayerManager,cs，修改Update方法 123456void Update()&#123; inputHandler.isInteracting = anim.GetBool(\"IsInteracting\"); inputHandler.rollFlag = false; inputHandler.sprintFlag = false;&#125; 保存所有脚本，播放游戏，控制角色移动并按住键盘左Shift键或手柄B键，角色冲刺。 三、脚本汇总AnimatorHandler.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class AnimatorHandler : MonoBehaviour &#123; public Animator anim; public InputHandler inputHandler; public PlayerLocomotion playerLocomotion; int vertical; int horizontal; public bool canRotate; public void Initialize() &#123; anim = GetComponent&lt;Animator&gt;(); inputHandler = GetComponentInParent&lt;InputHandler&gt;(); playerLocomotion = GetComponentInParent&lt;PlayerLocomotion&gt;(); vertical = Animator.StringToHash(\"Vertical\"); horizontal = Animator.StringToHash(\"Horizontal\"); &#125; public void UpdateAnimatorValues(float verticalMovement, float horizontalMovement, bool isSprinting) &#123; #region Vertical float v = 0; if(verticalMovement &gt; 0 &amp;&amp; verticalMovement &lt; 0.55f) &#123; v = 0.5f; &#125;else if(verticalMovement &gt; 0.55f) &#123; v = 1; &#125;else if(verticalMovement &lt; 0 &amp;&amp; verticalMovement &gt; -0.55f) &#123; v = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; v = -1; &#125; else &#123; v = 0; &#125; #endregion #region Horizontal float h = 0; if(horizontalMovement &gt; 0 &amp;&amp; horizontalMovement &lt; 0.55f) &#123; h = 0.5f; &#125;else if(horizontalMovement &gt; 0.55f) &#123; h = 1; &#125;else if(horizontalMovement &lt; 0 &amp;&amp; horizontalMovement &gt; -0.55f) &#123; h = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; h = -1; &#125; else &#123; h = 0; &#125; #endregion if (isSprinting) &#123; v = 2; h = horizontalMovement; &#125; anim.SetFloat(vertical, v, 0.1f, Time.deltaTime); anim.SetFloat(horizontal, h, 0.1f, Time.deltaTime); &#125; public void PlayerTargetAnimation(string targetAnim, bool isInteracting) &#123; anim.applyRootMotion = isInteracting; anim.SetBool(\"IsInteracting\", true); anim.CrossFade(targetAnim, 0.2f); &#125; public void CanRotate() &#123; canRotate = true; &#125; public void StopRotate() &#123; canRotate = false; &#125; private void OnAnimatorMove() &#123; if (inputHandler.isInteracting == false) return; float delta = Time.deltaTime; playerLocomotion.rigidbody.drag = 0; Vector3 deltaPosition = anim.deltaPosition; deltaPosition.y = 0; Vector3 velocity = deltaPosition / delta; playerLocomotion.rigidbody.velocity = velocity; &#125; &#125;&#125; InputHandler.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class InputHandler : MonoBehaviour &#123; public float horizontal; public float vertical; public float moveAmount; public float mouseX; public float mouseY; public bool b_Input; public bool rollFlag; public bool sprintFlag; public float rollInputTimer; public bool isInteracting; PlayerControls inputActions; CameraHandler cameraHandler; Vector2 movementInput; Vector2 cameraInput; private void Awake() &#123; cameraHandler = CameraHandler.singleton; &#125; private void FixedUpdate() &#123; float delta = Time.fixedDeltaTime; if(cameraHandler != null) &#123; cameraHandler.FollowTarget(delta); cameraHandler.HandleCameraRotation(delta, mouseX, mouseY); &#125; &#125; public void OnEnable() &#123; if(inputActions == null) &#123; inputActions = new PlayerControls(); inputActions.PlayerMovement.Movement.performed += inputActions =&gt; movementInput = inputActions.ReadValue&lt;Vector2&gt;(); inputActions.PlayerMovement.Camera.performed += i =&gt; cameraInput = i.ReadValue&lt;Vector2&gt;(); &#125; inputActions.Enable(); &#125; private void OnDisable() &#123; inputActions.Disable(); &#125; public void TickInput(float delta) &#123; MoveInput(delta); HandleRollInput(delta); &#125; private void MoveInput(float delta) &#123; horizontal = movementInput.x; vertical = movementInput.y; moveAmount = Mathf.Clamp01(Mathf.Abs(horizontal) + Mathf.Abs(vertical)); mouseX = cameraInput.x; mouseY = cameraInput.y; &#125; private void HandleRollInput(float delta) &#123; b_Input = inputActions.PlayerAction.Roll.phase == UnityEngine.InputSystem.InputActionPhase.Started; if (b_Input) &#123; rollInputTimer += delta; sprintFlag = true; &#125; else &#123; if(rollInputTimer &gt; 0 &amp;&amp; rollInputTimer &lt; 0.5f) &#123; sprintFlag = false; rollFlag = true; &#125; rollInputTimer = 0; &#125; &#125; &#125;&#125; PlayerLocomotion.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class PlayerLocomotion : MonoBehaviour &#123; Transform cameraObject; InputHandler inputHandler; Vector3 moveDirection; [HideInInspector] public Transform myTransform; [HideInInspector] public AnimatorHandler animatorHandler; public new Rigidbody rigidbody; public GameObject normalCamera; [Header(\"Stats\")] [SerializeField] float movementSpeed = 5; [SerializeField] float sprintSpeed = 7; [SerializeField] float rotationSpeed = 10; public bool isSprinting; // Start is called before the first frame update void Start() &#123; rigidbody = GetComponent&lt;Rigidbody&gt;(); inputHandler = GetComponent&lt;InputHandler&gt;(); animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); cameraObject = Camera.main.transform; myTransform = transform; animatorHandler.Initialize(); &#125; public void Update() &#123; float delta = Time.deltaTime; isSprinting = inputHandler.b_Input; inputHandler.TickInput(delta); HandleMovement(delta); HandleRollingAndSprinting(delta); &#125; #region Movement Vector3 normalVector; Vector3 targetPostion; private void HandleRotation(float delta) &#123; Vector3 targetDir = Vector3.zero; float moveOverride = inputHandler.moveAmount; targetDir = cameraObject.forward * inputHandler.vertical; targetDir += cameraObject.right * inputHandler.horizontal; targetDir.Normalize(); targetDir.y = 0; if(targetDir == Vector3.zero) &#123; targetDir = myTransform.forward; &#125; float rs = rotationSpeed; Quaternion tr = Quaternion.LookRotation(targetDir); Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta); myTransform.rotation = targetRotation; &#125; public void HandleMovement(float delta) &#123; if (inputHandler.rollFlag) return; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; moveDirection.Normalize(); moveDirection.y = 0; float speed = movementSpeed; if (inputHandler.sprintFlag) &#123; speed = sprintSpeed; isSprinting = true; moveDirection *= speed; &#125; else &#123; moveDirection *= speed; &#125; Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector); rigidbody.velocity = projectedVelocity; animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0, isSprinting); if (animatorHandler.canRotate) &#123; HandleRotation(delta); &#125; &#125; public void HandleRollingAndSprinting(float delta) &#123; if (animatorHandler.anim.GetBool(\"IsInteracting\")) return; if (inputHandler.rollFlag) &#123; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; if(inputHandler.moveAmount &gt; 0) &#123; animatorHandler.PlayerTargetAnimation(\"Rolling\", true); moveDirection.y = 0; Quaternion rollRotation = Quaternion.LookRotation(moveDirection); myTransform.rotation = rollRotation; &#125; else &#123; animatorHandler.PlayerTargetAnimation(\"Step_Back\", true); &#125; &#125; &#125; #endregion &#125;&#125; PlayerManager.cs123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerManager : MonoBehaviour &#123; InputHandler inputHandler; Animator anim; void Start() &#123; inputHandler = GetComponent&lt;InputHandler&gt;(); anim = GetComponentInChildren&lt;Animator&gt;(); &#125; void Update() &#123; inputHandler.isInteracting = anim.GetBool(\"IsInteracting\"); inputHandler.rollFlag = false; inputHandler.sprintFlag = false; &#125; &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（四）角色翻滚与后撤闪避","slug":"DarkSoulsDemo（四）角色翻滚与后撤闪避","date":"2020-06-20T06:48:38.000Z","updated":"2020-06-23T07:46:12.679Z","comments":true,"path":"2020/06/20/DarkSoulsDemo（四）角色翻滚与后撤闪避/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/20/DarkSoulsDemo%EF%BC%88%E5%9B%9B%EF%BC%89%E8%A7%92%E8%89%B2%E7%BF%BB%E6%BB%9A%E4%B8%8E%E5%90%8E%E6%92%A4%E9%97%AA%E9%81%BF/","excerpt":"关键词：脚本控制","text":"关键词：脚本控制 本篇出自：https://www.youtube.com/watch?v=RVWh-YAQElQ 资源链接：https://assetstore.unity.com/packages/3d/animations/runner-action-animation-pack-153906 本篇中只用到Runner Action Animation Pack中的两个动画片段： CLazy@Esc_StandRoll_JFront_Root、CLazy@Esc_BoostDash_Back_Root 一、添加动画状态导入动画资源后，打开Humanoid动画控制器，进到Base Layer层，直接从项目窗口拖拽动画片段CLazy@Esc_StandRoll_JFront和CLazy@Esc_BoostDash_Back到Animator窗口中直接生成两个动画状态，分别重命名为Rolling、Step_Back。 建立两个转变关系： Rolling =&gt; Locomotion Step_Back =&gt; Locomotion 添加Bool类型参数IsInteracting 二、编辑脚本打开PlayerLocomotion.cs，将下边的代码块封装成一个HandleMovement方法： 1234567891011121314151617moveDirection = cameraObject.forward * inputHandler.vertical;moveDirection += cameraObject.right * inputHandler.horizontal;moveDirection.Normalize();moveDirection.y = 0;float speed = movementSpeed;moveDirection *= speed;Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector);rigidbody.velocity = projectedVelocity;animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0);if (animatorHandler.canRotate)&#123; HandleRotation(delta);&#125; 改完以后： 1234567891011121314151617181920212223242526272829public void Update()&#123; float delta = Time.deltaTime; inputHandler.TickInput(delta); HandleMovement(delta);&#125;...private void HandleRotation(float delta)... public void HandleMovement(float delta)&#123; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; moveDirection.Normalize(); moveDirection.y = 0; float speed = movementSpeed; moveDirection *= speed; Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector); rigidbody.velocity = projectedVelocity; animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0); if (animatorHandler.canRotate) &#123; HandleRotation(delta); &#125;&#125; 打开AnimatorHandler.cs，添加方法PlayerTargetAnimation 123456public void PlayerTargetAnimation(string targetAnim, bool isInteracting)&#123; anim.applyRootMotion = isInteracting; anim.SetBool(\"IsInteracting\", true); anim.CrossFade(targetAnim, 0.2f);&#125; 三、绑定按键回到Unity编辑器，打开PlayerControls，添加Action Map，命名为Player Action。添加Action，取名Roll，Action Type为Button，添加绑定Button East [Gamepad]、Left Shift [Keyboard]。 打开InputHandler.cs，添加声明bool类型变量b_Input、rollFlag，编写方法HandleRollInput： 12345678910public bool b_Input;public bool rollFlag;...private void HandleRollInput(float delta)&#123; if (b_Input) &#123; rollFlag = true; &#125;&#125; 四、脚本管理翻滚和后撤步动画打开PlayerLocomotion.cs，添加方法HandleRollingAndSprinting 123456789101112131415161718192021public void HandleRollingAndSprinting(float delta)&#123; if (animatorHandler.anim.GetBool(\"IsInteracting\")) return; if (inputHandler.rollFlag) &#123; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; if(inputHandler.moveAmount &gt; 0) &#123; animatorHandler.PlayerTargetAnimation(\"Rolling\", true); moveDirection.y = 0; Quaternion rollRotation = Quaternion.LookRotation(moveDirection); myTransform.rotation = rollRotation; &#125; else &#123; animatorHandler.PlayerTargetAnimation(\"Step_Back\", true); &#125; &#125;&#125; 回到InputHandler.cs，调用HandleRollInput，在HandleRollInpu里t补充对b_Input赋值。 1234567891011121314public void TickInput(float delta)&#123; MoveInput(delta); HandleRollInput(delta);&#125;...private void HandleRollInput(float delta)&#123; b_Input = inputActions.PlayerAction.Roll.phase == UnityEngine.InputSystem.InputActionPhase.Started; if (b_Input) &#123; rollFlag = true; &#125;&#125; 切到PlayerLocomotion.cs，在Update方法里调用HandleRollingAndSprinting方法： 123456789public void Update()&#123; float delta = Time.deltaTime; inputHandler.TickInput(delta); HandleMovement(delta); HandleRollingAndSprinting(delta);&#125; 这时候播放游戏，角色随可以翻滚，但突然四处乱飘，接下来解决这个问题。 五、管理互动权限首先在InputHandler.cs里声明bool类型公共变量isInteracting。 新建脚本PlayerManager.cs，编写代码： 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerManager : MonoBehaviour &#123; InputHandler inputHandler; Animator anim; void Start() &#123; inputHandler = GetComponent&lt;InputHandler&gt;(); anim = GetComponentInChildren&lt;Animator&gt;(); &#125; void Update() &#123; inputHandler.isInteracting = anim.GetBool(\"IsInteracting\"); inputHandler.rollFlag = false; &#125; &#125;&#125; 回到Animator窗口，选中Rolling窗台，在Inspector点击Add Behaviour，命名ResetIsInteracting，创建并添加脚本。 ResetIsInteracting.cs编写如下： 12345678910111213using System.Collections;using System.Collections.Generic;using UnityEngine;public class ResetIsInteracting : StateMachineBehaviour&#123; // OnStateExit is called when a transition ends and the state machine finishes evaluating this state override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; animator.SetBool(\"IsInteracting\", false); &#125;&#125; 对Step_Back也应用上该脚本 在AnimatorHandler.cs里声明变量inputHandler和playerLocomotion，在Initialize方法里获取，添加OnAnimatorMove方法。 123456789101112131415161718192021222324public InputHandler inputHandler;public PlayerLocomotion playerLocomotion;...public void Initialize()&#123; anim = GetComponent&lt;Animator&gt;(); inputHandler = GetComponentInParent&lt;InputHandler&gt;(); playerLocomotion = GetComponentInParent&lt;PlayerLocomotion&gt;();...&#125;...private void OnAnimatorMove()&#123; if (inputHandler.isInteracting == false) return; float delta = Time.deltaTime; playerLocomotion.rigidbody.drag = 0; Vector3 deltaPosition = anim.deltaPosition; deltaPosition.y = 0; Vector3 velocity = deltaPosition / delta; playerLocomotion.rigidbody.velocity = velocity;&#125; 给Player添加PlayerLocomotion脚本 好，现在播放游戏，可以在按方向键的同时按键盘左Shift键实现角色翻滚，单按Shift键原地后撤步闪避了。翻滚姿势截图有点丑，将就看吧。 六、脚本汇总InputHandler.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class InputHandler : MonoBehaviour &#123; public float horizontal; public float vertical; public float moveAmount; public float mouseX; public float mouseY; public bool b_Input; public bool rollFlag; public bool isInteracting; PlayerControls inputActions; CameraHandler cameraHandler; Vector2 movementInput; Vector2 cameraInput; private void Awake() &#123; cameraHandler = CameraHandler.singleton; &#125; private void FixedUpdate() &#123; float delta = Time.fixedDeltaTime; if(cameraHandler != null) &#123; cameraHandler.FollowTarget(delta); cameraHandler.HandleCameraRotation(delta, mouseX, mouseY); &#125; &#125; public void OnEnable() &#123; if(inputActions == null) &#123; inputActions = new PlayerControls(); inputActions.PlayerMovement.Movement.performed += inputActions =&gt; movementInput = inputActions.ReadValue&lt;Vector2&gt;(); inputActions.PlayerMovement.Camera.performed += i =&gt; cameraInput = i.ReadValue&lt;Vector2&gt;(); &#125; inputActions.Enable(); &#125; private void OnDisable() &#123; inputActions.Disable(); &#125; public void TickInput(float delta) &#123; MoveInput(delta); HandleRollInput(delta); &#125; private void MoveInput(float delta) &#123; horizontal = movementInput.x; vertical = movementInput.y; moveAmount = Mathf.Clamp01(Mathf.Abs(horizontal) + Mathf.Abs(vertical)); mouseX = cameraInput.x; mouseY = cameraInput.y; &#125; private void HandleRollInput(float delta) &#123; b_Input = inputActions.PlayerAction.Roll.phase == UnityEngine.InputSystem.InputActionPhase.Started; if (b_Input) &#123; rollFlag = true; &#125; &#125; &#125;&#125; PlayerLocomotion.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class PlayerLocomotion : MonoBehaviour &#123; Transform cameraObject; InputHandler inputHandler; Vector3 moveDirection; [HideInInspector] public Transform myTransform; [HideInInspector] public AnimatorHandler animatorHandler; public new Rigidbody rigidbody; public GameObject normalCamera; [Header(\"Stats\")] [SerializeField] float movementSpeed = 5; [SerializeField] float rotationSpeed = 10; // Start is called before the first frame update void Start() &#123; rigidbody = GetComponent&lt;Rigidbody&gt;(); inputHandler = GetComponent&lt;InputHandler&gt;(); animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); cameraObject = Camera.main.transform; myTransform = transform; animatorHandler.Initialize(); &#125; public void Update() &#123; float delta = Time.deltaTime; inputHandler.TickInput(delta); HandleMovement(delta); HandleRollingAndSprinting(delta); &#125; #region Movement Vector3 normalVector; Vector3 targetPostion; private void HandleRotation(float delta) &#123; Vector3 targetDir = Vector3.zero; float moveOverride = inputHandler.moveAmount; targetDir = cameraObject.forward * inputHandler.vertical; targetDir += cameraObject.right * inputHandler.horizontal; targetDir.Normalize(); targetDir.y = 0; if(targetDir == Vector3.zero) &#123; targetDir = myTransform.forward; &#125; float rs = rotationSpeed; Quaternion tr = Quaternion.LookRotation(targetDir); Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta); myTransform.rotation = targetRotation; &#125; public void HandleMovement(float delta) &#123; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; moveDirection.Normalize(); moveDirection.y = 0; float speed = movementSpeed; moveDirection *= speed; Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector); rigidbody.velocity = projectedVelocity; animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0); if (animatorHandler.canRotate) &#123; HandleRotation(delta); &#125; &#125; public void HandleRollingAndSprinting(float delta) &#123; if (animatorHandler.anim.GetBool(\"IsInteracting\")) return; if (inputHandler.rollFlag) &#123; moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; if(inputHandler.moveAmount &gt; 0) &#123; animatorHandler.PlayerTargetAnimation(\"Rolling\", true); moveDirection.y = 0; Quaternion rollRotation = Quaternion.LookRotation(moveDirection); myTransform.rotation = rollRotation; &#125; else &#123; animatorHandler.PlayerTargetAnimation(\"Step_Back\", true); &#125; &#125; &#125; #endregion &#125;&#125; AnimatorHandler.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class AnimatorHandler : MonoBehaviour &#123; public Animator anim; public InputHandler inputHandler; public PlayerLocomotion playerLocomotion; int vertical; int horizontal; public bool canRotate; public void Initialize() &#123; anim = GetComponent&lt;Animator&gt;(); inputHandler = GetComponentInParent&lt;InputHandler&gt;(); playerLocomotion = GetComponentInParent&lt;PlayerLocomotion&gt;(); vertical = Animator.StringToHash(\"Vertical\"); horizontal = Animator.StringToHash(\"Horizontal\"); &#125; public void UpdateAnimatorValues(float verticalMovement, float horizontalMovement) &#123; #region Vertical float v = 0; if(verticalMovement &gt; 0 &amp;&amp; verticalMovement &lt; 0.55f) &#123; v = 0.5f; &#125;else if(verticalMovement &gt; 0.55f) &#123; v = 1; &#125;else if(verticalMovement &lt; 0 &amp;&amp; verticalMovement &gt; -0.55f) &#123; v = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; v = -1; &#125; else &#123; v = 0; &#125; #endregion #region Horizontal float h = 0; if(horizontalMovement &gt; 0 &amp;&amp; horizontalMovement &lt; 0.55f) &#123; h = 0.5f; &#125;else if(horizontalMovement &gt; 0.55f) &#123; h = 1; &#125;else if(horizontalMovement &lt; 0 &amp;&amp; horizontalMovement &gt; -0.55f) &#123; h = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; h = -1; &#125; else &#123; h = 0; &#125; #endregion anim.SetFloat(vertical, v, 0.1f, Time.deltaTime); anim.SetFloat(horizontal, h, 0.1f, Time.deltaTime); &#125; public void PlayerTargetAnimation(string targetAnim, bool isInteracting) &#123; anim.applyRootMotion = isInteracting; anim.SetBool(\"IsInteracting\", true); anim.CrossFade(targetAnim, 0.2f); &#125; public void CanRotate() &#123; canRotate = true; &#125; public void StopRotate() &#123; canRotate = false; &#125; private void OnAnimatorMove() &#123; if (inputHandler.isInteracting == false) return; float delta = Time.deltaTime; playerLocomotion.rigidbody.drag = 0; Vector3 deltaPosition = anim.deltaPosition; deltaPosition.y = 0; Vector3 velocity = deltaPosition / delta; playerLocomotion.rigidbody.velocity = velocity; &#125; &#125;&#125; PlayerManager.cs1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class PlayerManager : MonoBehaviour &#123; InputHandler inputHandler; Animator anim; void Start() &#123; inputHandler = GetComponent&lt;InputHandler&gt;(); anim = GetComponentInChildren&lt;Animator&gt;(); &#125; void Update() &#123; inputHandler.isInteracting = anim.GetBool(\"IsInteracting\"); inputHandler.rollFlag = false; &#125; &#125;&#125; ResetIsInteracting.cs12345678910111213using System.Collections;using System.Collections.Generic;using UnityEngine;public class ResetIsInteracting : StateMachineBehaviour&#123; // OnStateExit is called when a transition ends and the state machine finishes evaluating this state override public void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex) &#123; animator.SetBool(\"IsInteracting\", false); &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（三）摄像机碰撞","slug":"DarkSoulsDemo（三）摄像机碰撞","date":"2020-06-20T04:26:24.000Z","updated":"2020-06-23T07:46:04.715Z","comments":true,"path":"2020/06/20/DarkSoulsDemo（三）摄像机碰撞/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/20/DarkSoulsDemo%EF%BC%88%E4%B8%89%EF%BC%89%E6%91%84%E5%83%8F%E6%9C%BA%E7%A2%B0%E6%92%9E/","excerpt":"关键词：摄像机","text":"关键词：摄像机 本片出自：https://www.youtube.com/watch?v=Don3lGSAF2A 给Plane围上围墙，播放游戏，角色走到墙边，如果移动鼠标使摄像机到墙里，角色会被墙挡住。接下来我们将解决这个问题 一、修改CameraHandler脚本打开CameraHandler.cs，声明Vector3类型变量cameraFollowVelocity并初始化，修改FollowTarget方法。 1234567891011...private Vector3 cameraFollowVelocity = Vector3.zero;...public void FollowTarget(float delta)&#123; Vector3 targetPosition = Vector3.SmoothDamp(myTransform.position, targetTransform.position, ref cameraFollowVelocity, delta / followSpeed); myTransform.position = targetPosition;&#125; 声明如下变量并初始化，编写方法HandleCameraCollision 123456789101112131415161718192021222324252627282930313233...public float cameraSphereRadius = 0.2f;public float cameraCollisionOffSet = 0.2f;public float minimumCollisionOffSet = 0.2f;...private void HandleCameraCollision(float delta)&#123; targetPosition = defaultPosition; RaycastHit hit; Vector3 direction = cameraTransform.position - cameraPivotTransform.position; direction.Normalize(); if(Physics.SphereCast(cameraPivotTransform.position, cameraSphereRadius, direction, out hit, Mathf.Abs(targetPosition), ignoreLayers)) &#123; float dis = Vector3.Distance(cameraPivotTransform.position, hit.point); targetPosition = -(dis - cameraCollisionOffSet); &#125; if(Mathf.Abs(targetPosition) &lt; minimumCollisionOffSet) &#123; targetPosition = -minimumCollisionOffSet; &#125; cameraTransformPosition.z = Mathf.Lerp(cameraTransform.localPosition.z, targetPosition, delta / 0.2f); cameraTransform.localPosition = cameraTransformPosition;&#125; 再次修改FollowTarget方法，调用HandleCameraCollision方法。 1234567public void FollowTarget(float delta)&#123; Vector3 targetPosition = Vector3.SmoothDamp(myTransform.position, targetTransform.position, ref cameraFollowVelocity, delta / followSpeed); myTransform.position = targetPosition; HandleCameraCollision(delta);&#125; 二、修改层级，调整Camera Pivot回到Unity编辑器，修改Camera Holder、Camera Pivot的层级为Controller。 调整Camera Pivot|Transform|Y到与角色的头部差不多高。 播放游戏，控制角色走到墙边，此时摄像机再身后保持正常距离。 移动鼠标使摄像机处在角色面前，摄像机与墙有碰撞而不会穿过墙。 三、脚本汇总CameraHandler.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class CameraHandler : MonoBehaviour &#123; public Transform targetTransform; public Transform cameraTransform; public Transform cameraPivotTransform; private Transform myTransform; private Vector3 cameraTransformPosition; private LayerMask ignoreLayers; private Vector3 cameraFollowVelocity = Vector3.zero; public static CameraHandler singleton; public float lookSpeed = 0.1f; public float followSpeed = 0.1f; public float pivotSpeed = 0.03f; private float targetPosition; private float defaultPosition; private float lookAngle; private float pivotAngle; public float minimumPivot = -35; public float maximumPivot = 35; public float cameraSphereRadius = 0.2f; public float cameraCollisionOffSet = 0.2f; public float minimumCollisionOffSet = 0.2f; private void Awake() &#123; singleton = this; myTransform = transform; defaultPosition = cameraTransform.localPosition.z; ignoreLayers = ~(1 &lt;&lt; 8 | 1 &lt;&lt; 9 | 1 &lt;&lt; 10); &#125; public void FollowTarget(float delta) &#123; Vector3 targetPosition = Vector3.SmoothDamp(myTransform.position, targetTransform.position, ref cameraFollowVelocity, delta / followSpeed); myTransform.position = targetPosition; HandleCameraCollision(delta); &#125; public void HandleCameraRotation(float delta, float mouseXInput, float mouseYInput) &#123; lookAngle += (mouseXInput * lookSpeed) / delta; pivotAngle -= (mouseYInput * pivotSpeed) / delta; pivotAngle = Mathf.Clamp(pivotAngle, minimumPivot, maximumPivot); Vector3 rotation = Vector3.zero; rotation.y = lookAngle; Quaternion targetRotation = Quaternion.Euler(rotation); myTransform.rotation = targetRotation; rotation = Vector3.zero; rotation.x = pivotAngle; targetRotation = Quaternion.Euler(rotation); cameraPivotTransform.localRotation = targetRotation; &#125; private void HandleCameraCollision(float delta) &#123; targetPosition = defaultPosition; RaycastHit hit; Vector3 direction = cameraTransform.position - cameraPivotTransform.position; direction.Normalize(); if(Physics.SphereCast(cameraPivotTransform.position, cameraSphereRadius, direction, out hit, Mathf.Abs(targetPosition), ignoreLayers)) &#123; float dis = Vector3.Distance(cameraPivotTransform.position, hit.point); targetPosition = -(dis - cameraCollisionOffSet); &#125; if(Mathf.Abs(targetPosition) &lt; minimumCollisionOffSet) &#123; targetPosition = -minimumCollisionOffSet; &#125; cameraTransformPosition.z = Mathf.Lerp(cameraTransform.localPosition.z, targetPosition, delta / 0.2f); cameraTransform.localPosition = cameraTransformPosition; &#125; &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（二）摄像机管理器","slug":"DarkSoulsDemo（二）摄像机管理器","date":"2020-06-19T05:44:52.000Z","updated":"2020-06-23T07:45:55.476Z","comments":true,"path":"2020/06/19/DarkSoulsDemo（二）摄像机管理器/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/19/DarkSoulsDemo%EF%BC%88%E4%BA%8C%EF%BC%89%E6%91%84%E5%83%8F%E6%9C%BA%E7%AE%A1%E7%90%86%E5%99%A8/","excerpt":"关键词：摄像机管理脚本","text":"关键词：摄像机管理脚本 本篇出自：https://www.youtube.com/watch?v=c1FYp1oOFIs 一、布置摄像机在Hierarchy新建一个空物体，命名为Camera Holder，右键Camera Holder，新建一个空物体，命名为Camera Pivot，将Main Camera拖拽到Camera Pivot。 二、写脚本新建一个脚本，取名CameraHandler.cs，用VS2017打开，编写代码如下： 123456789101112131415161718192021222324252627282930313233343536using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class CameraHandler : MonoBehaviour &#123; public Transform targetTransform; public Transform cameraTransform; public Transform cameraPivotTransform; private Transform myTransform; private Vector3 cameraTransformPosition; private LayerMask ignoreLayers; public static CameraHandler singleton; public float lookSpeed = 0.1f; public float followSpeed = 0.1f; public float pivotSpeed = 0.03f; private float defaultPosition; private float lookAngle; private float pivotAngle; public float minimumPivot = -35; public float maximumPivot = 35; private void Awake() &#123; singleton = this; myTransform = transform; defaultPosition = cameraTransform.localPosition.z; ignoreLayers = ~(1 &lt;&lt; 8 | 1 &lt;&lt; 9 | 1 &lt;&lt; 10); &#125; &#125;&#125; 三、设置层级、脚本补充回到Unity编辑器，在Hierarchy选中Player，在Inspector设置层级。 回到CameraHandler.cs，在Awake方法下编写FollowTarget方法和HandleCameraRotation方法： 123456789101112131415161718192021222324private void Awake()... public void FollowTarget(float delta) &#123; Vector3 targetPosition = Vector3.Lerp(myTransform.position, targetTransform.position, delta / followSpeed); myTransform.position = targetPosition; &#125;public void HandleCameraRotation(float delta, float mouseXInput, float mouseYInput)&#123; lookAngle += (mouseXInput * lookSpeed) / delta; pivotAngle -= (mouseYInput * pivotSpeed) / delta; pivotAngle = Mathf.Clamp(pivotAngle, minimumPivot, maximumPivot); Vector3 rotation = Vector3.zero; rotation.y = lookAngle; Quaternion targetRotation = Quaternion.Euler(rotation); myTransform.rotation = targetRotation; rotation = Vector3.zero; rotation.x = pivotAngle; targetRotation = Quaternion.Euler(rotation); cameraPivotTransform.localRotation = targetRotation;&#125; 回到InputHandler.cs 声明CameraHandler类型变量cameraHandler，编写Awake方法和FixedUpdate方法 1234567891011121314151617CameraHandler cameraHandler;private void Awake()&#123; cameraHandler = CameraHandler.singleton;&#125;private void FixedUpdate()&#123; float delta = Time.fixedDeltaTime; if(cameraHandler != null) &#123; cameraHandler.FollowTarget(delta); cameraHandler.HandleCameraRotation(delta, mouseX, mouseY); &#125;&#125; 四、配置摄像机保存脚本，回到Unity编辑器，选中将CameraHandler.cs添加到Camera Holder，并给Target Transform、Camera Transform、Camera Pivot Transform赋值。 然后将Player、Camera Holder、Camera Pivot的位置坐标全部重置为（0，0，0），选中Main Camera ,调整到角色后背合适的位置。调整摄像机视野Main Camera|Camera|Field of View。 现在保存场景，播放游戏，在移动角色的同时，我们可以像再黑暗之魂里一样移动摄像机的视角。 五、脚本汇总CameraHandler.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ&#123; public class CameraHandler : MonoBehaviour &#123; public Transform targetTransform; public Transform cameraTransform; public Transform cameraPivotTransform; private Transform myTransform; private Vector3 cameraTransformPosition; private LayerMask ignoreLayers; public static CameraHandler singleton; public float lookSpeed = 0.1f; public float followSpeed = 0.1f; public float pivotSpeed = 0.03f; private float defaultPosition; private float lookAngle; private float pivotAngle; public float minimumPivot = -35; public float maximumPivot = 35; private void Awake() &#123; singleton = this; myTransform = transform; defaultPosition = cameraTransform.localPosition.z; ignoreLayers = ~(1 &lt;&lt; 8 | 1 &lt;&lt; 9 | 1 &lt;&lt; 10); &#125; public void FollowTarget(float delta) &#123; Vector3 targetPosition = Vector3.Lerp(myTransform.position, targetTransform.position, delta / followSpeed); myTransform.position = targetPosition; &#125; public void HandleCameraRotation(float delta, float mouseXInput, float mouseYInput) &#123; lookAngle += (mouseXInput * lookSpeed) / delta; pivotAngle -= (mouseYInput * pivotSpeed) / delta; pivotAngle = Mathf.Clamp(pivotAngle, minimumPivot, maximumPivot); Vector3 rotation = Vector3.zero; rotation.y = lookAngle; Quaternion targetRotation = Quaternion.Euler(rotation); myTransform.rotation = targetRotation; rotation = Vector3.zero; rotation.x = pivotAngle; targetRotation = Quaternion.Euler(rotation); cameraPivotTransform.localRotation = targetRotation; &#125; &#125;&#125; InputHandler.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class InputHandler : MonoBehaviour &#123; public float horizontal; public float vertical; public float moveAmount; public float mouseX; public float mouseY; PlayerControls inputActions; CameraHandler cameraHandler; Vector2 movementInput; Vector2 cameraInput; private void Awake() &#123; cameraHandler = CameraHandler.singleton; &#125; private void FixedUpdate() &#123; float delta = Time.fixedDeltaTime; if(cameraHandler != null) &#123; cameraHandler.FollowTarget(delta); cameraHandler.HandleCameraRotation(delta, mouseX, mouseY); &#125; &#125; public void OnEnable() &#123; if(inputActions == null) &#123; inputActions = new PlayerControls(); inputActions.PlayerMovement.Movement.performed += inputActions =&gt; movementInput = inputActions.ReadValue&lt;Vector2&gt;(); inputActions.PlayerMovement.Camera.performed += i =&gt; cameraInput = i.ReadValue&lt;Vector2&gt;(); &#125; inputActions.Enable(); &#125; private void OnDisable() &#123; inputActions.Disable(); &#125; public void TickInput(float delta) &#123; MoveInput(delta); &#125; private void MoveInput(float delta) &#123; horizontal = movementInput.x; vertical = movementInput.y; moveAmount = Mathf.Clamp01(Mathf.Abs(horizontal) + Mathf.Abs(vertical)); mouseX = cameraInput.x; mouseY = cameraInput.y; &#125; &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"DarkSoulsDemo（一）角色行走","slug":"DarkSoulsDemo（一）角色行走","date":"2020-06-17T10:50:01.000Z","updated":"2020-06-23T07:45:06.193Z","comments":true,"path":"2020/06/17/DarkSoulsDemo（一）角色行走/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/17/DarkSoulsDemo%EF%BC%88%E4%B8%80%EF%BC%89%E8%A7%92%E8%89%B2%E8%A1%8C%E8%B5%B0/","excerpt":"关键词：移动、Input System插件、混合树","text":"关键词：移动、Input System插件、混合树 本篇出自：https://www.youtube.com/watch?v=LOC5GJ5rFFw 一、资源导入本篇用到的资源链接： 动画：https://drive.google.com/drive/folders/1j2HicZMabg4h2Oe8ocxGNuKBHY5kzFJA 模型：https://drive.google.com/drive/folders/1X6DLqSsLT2EAIYpcZGYL-Z93hYOo2sxa 动画资源文件：Idle.anim、Run.anim、Sprint.anim、Walk.anim。 FBX文件：LowPolyMan.fbx 用Unity 2019.3.4f1Personal新建一个3D项目，导入上述资源，给场景SampleScene新建一个3D物体Plane。在Assets/Materials下新建一个材质（Material）取名为Floor_MAT。选中Floor_MAT，在Inspector点击Main Maps|Albedo选择Default-Checker-Gray(Texture 2D)。修改Tiling|X为5，Y为1。然后从项目窗口将Floor_MAT拖拽到场景中的Plane上。 在Hierarchy新建一个空的GameObject，重命名为Player。从项目窗口将LowPolyMan.fbx拖拽到Player，成为其子项。将场景中的LowPolyMan也重命名为Player。 新建两个脚本PlayerLocomotion.cs、InputHandler.cs。 二、Input System打开Packages Manager，安装Input System，如果没找到可以点击Advanced|Show preview packages。 安装过程中会弹出对话窗口，点击Yes。安装完后Unity编辑器将自动重启。 在项目窗口右键，选中Create|Input Action。 重命名为PlayerControls，这个将控制控制器的输入。选中PlayerControls，在Inspector勾选Generate C# Class，点击Apply。 这时，PlayerControls.cs会被自动创建，我们双击打开PlayerControls（Input Action）。 点击加号添加一个Action Maps，命名为Player Movement，添加两个Action，分别命名为Movement、Camera。修改Movement的属性Action|Action Type为Pass Through，Control Type为Vector 2 删掉Movement下的&lt;No Binding&gt;（右键选择Delete），点击Movementy同行右边的加号，选择Add 2D Vector Composite。 重命名为WASD，设置它的属性Composite|Composite Type为2D Vector，Mode为Analog 设置WASD下的四个动作如下， 选择Camera下的&lt;No Binding&gt;，设置Path为Right Stick [Gamepad]，添加Processor Stick Deadzone。 在Camera下添加Binding，设置Path为Delta[Mouse]，添加属性Normalize Vector 2。 然后关闭窗口，在弹出的对话框中选择Save。 然后打开Project Setting，选中Input System Package，点击Create settings asset按钮，修改Default Hold Time为0。 三、给角色添加碰撞体组件和刚体组件给Player添加胶囊碰撞体组件，设置属性Radus为0.3，Height为2。 添加Rigidbody组件，勾选Constraints Freeze Rotation X、Y、Z。 四、编写脚本实现角色转向然后用VS2017打开InputHandler.cs，编写脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class InputHandler : MonoBehaviour &#123; public float horizontal; public float vertical; public float moveAmount; public float mouseX; public float mouseY; PlayerControls inputActions; Vector2 movementInput; Vector2 cameraInput; public void OnEnable() &#123; if(inputActions == null) &#123; inputActions = new PlayerControls(); inputActions.PlayerMovement.Movement.performed += inputActions =&gt; movementInput = inputActions.ReadValue&lt;Vector2&gt;(); inputActions.PlayerMovement.Camera.performed += i =&gt; cameraInput = i.ReadValue&lt;Vector2&gt;(); &#125; inputActions.Enable(); &#125; private void OnDisable() &#123; inputActions.Disable(); &#125; public void TickInput(float delta) &#123; MoveInput(delta); &#125; private void MoveInput(float delta) &#123; horizontal = movementInput.x; vertical = movementInput.y; moveAmount = Mathf.Clamp01(Mathf.Abs(horizontal) + Mathf.Abs(vertical)); mouseX = cameraInput.x; mouseY = cameraInput.y; &#125; &#125;&#125; 然后用VS2017打开PlayerLocomotion.cs，编写脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class PlayerLocomotion : MonoBehaviour &#123; Transform cameraObject; InputHandler inputHandler; Vector3 moveDirection; [HideInInspector] public Transform myTransform; public new Rigidbody rigidbody; public GameObject normalCamera; [Header(\"Stats\")] [SerializeField] float movementSpeed = 5; [SerializeField] float rotationSpeed = 10; // Start is called before the first frame update void Start() &#123; rigidbody = GetComponent&lt;Rigidbody&gt;(); inputHandler = GetComponent&lt;InputHandler&gt;(); animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); cameraObject = Camera.main.transform; myTransform = transform; &#125; public void Update() &#123; float delta = Time.deltaTime; inputHandler.TickInput(delta); moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; moveDirection.Normalize(); moveDirection.y = 0; float speed = movementSpeed; moveDirection *= speed; Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector); rigidbody.velocity = projectedVelocity; &#125; #region Movement Vector3 normalVector; Vector3 targetPostion; private void HandleRotation(float delta) &#123; Vector3 targetDir = Vector3.zero; float moveOverride = inputHandler.moveAmount; targetDir = cameraObject.forward * inputHandler.vertical; targetDir += cameraObject.right * inputHandler.horizontal; targetDir.Normalize(); targetDir.y = 0; if(targetDir == Vector3.zero) &#123; targetDir = myTransform.forward; &#125; float rs = rotationSpeed; Quaternion tr = Quaternion.LookRotation(targetDir); Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta); myTransform.rotation = targetRotation; &#125; #endregion &#125;&#125; 回到Unity编辑器，将InputHandler.cs和PlayerLocomotion.cs添加到Player 播放游戏，通过WASD我们可以控制角色在平面上“滑行”。 如果在按W/S键的时候角色往天上移动，则需要将Main Camera放置在能够平视角色的位置上（通过Ctrl+Shift+F设置位置）。 接下来添加脚本来控制动画。 新建脚本AnimatorHandler.cs，编写脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class AnimatorHandler : MonoBehaviour &#123; public Animator anim; int vertical; int horizontal; public bool canRotate; public void Initialize() &#123; anim = GetComponent&lt;Animator&gt;(); vertical = Animator.StringToHash(\"Vertical\"); horizontal = Animator.StringToHash(\"Horizontal\"); &#125; public void UpdateAnimatorValues(float verticalMovement, float horizontalMovement) &#123; #region Vertical float v = 0; if(verticalMovement &gt; 0 &amp;&amp; verticalMovement &lt; 0.55f) &#123; v = 0.5f; &#125;else if(verticalMovement &gt; 0.55f) &#123; v = 1; &#125;else if(verticalMovement &lt; 0 &amp;&amp; verticalMovement &gt; -0.55f) &#123; v = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; v = -1; &#125; else &#123; v = 0; &#125; #endregion #region Horizontal float h = 0; if(horizontalMovement &gt; 0 &amp;&amp; horizontalMovement &lt; 0.55f) &#123; h = 0.5f; &#125;else if(horizontalMovement &gt; 0.55f) &#123; h = 1; &#125;else if(horizontalMovement &lt; 0 &amp;&amp; horizontalMovement &gt; -0.55f) &#123; h = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; h = -1; &#125; else &#123; h = 0; &#125; #endregion anim.SetFloat(vertical, v, 0.1f, Time.deltaTime); anim.SetFloat(horizontal, h, 0.1f, Time.deltaTime); &#125; public void CanRotate() &#123; canRotate = true; &#125; public void StopRotate() &#123; canRotate = false; &#125; &#125;&#125; 打开PlayerLocomotion.cs，添加AnimatorHandler类型公共变量animatorHandler： 123456789... [HideInInspector] public Transform myTransform; //↓↓↓声明变量animatorHandler [HideInInspector] public AnimatorHandler animatorHandler; public new Rigidbody rigidbody;... 在Start方法添加语句获取AnimatorHandler组件以及调用animatorHandler的初始化方法。 12345678910void Start()&#123; rigidbody = GetComponent&lt;Rigidbody&gt;(); inputHandler = GetComponent&lt;InputHandler&gt;(); //↓↓↓获取AnimatorHandler组件，这里用GetComponentInChildren是因为该组件是属于Player的子项Player的 animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;();... //调用animatorHandler的初始化方法 animatorHandler.Initialize();&#125; 在Update方法里添加语句实现转向判断 1234567void Update()&#123; ... if (animatorHandler.canRotate) &#123; HandleRotation(delta); &#125;&#125; 保存修改后的脚本，回到Unity编辑器，将AnimatorHandler.cs添加到Player的子项Player，勾选Can Rotate。 播放游戏，想在控制角色移动，角色会转向。 实际遇到的问题： 发现角色没有转向，原因是没有勾选Can Rotate。 按W/S键时，角色没有转向，原因是这条语句漏写了。 12345private void HandleRotation(float delta)&#123;... targetDir = cameraObject.forward * inputHandler.vertical; ... 五、加入动画在Assets/Animator下新建一个Animator Controller，命名为Humanoid，将其拖拽添加到场景中Player|Player|Animator|Controller，双击Humanoid打开并进入Animtor窗口。 点击Parameters标签，点击加号添加两个Float类型参数Horizontal、Vertical。 然后回到Layers标签，在Base Layer新建混合树，重命名为Locomotion。 双击进入Locomotion，将Blend Tree的混合模式设为2D Freeform Cartesian，设置参数Horizontal、Vertical，在Motion列表添加三个动作域，并分别做如下配置。 如果动画预览窗口里没有显示正确的模型，从项目窗口中拖入LowPolyMan.fbx即可。 打开PlayerLocomotion.cs，在Update方法添加如下语句： 12345public void Update()&#123;... animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0); ... 保存脚本，回到Unity编辑器，设置Player|Player|Animator|Avatar为LowPolyManAvatar。 播放游戏。此时角色的移动带有跑动动画。 实际遇到的问题： 角色没有跑动，原因： LowPolyMan模型没有设置Rig|Animation Type为Humanoid。 Player|Player|Animator|Avatar为”None“。 在Animator设置Float型参数Vertical时，错写成“vertical”。 角色跑动的时候会“闪现、乱窜“，原因是勾选了Apply Root Motion。 六、脚本汇总InputHandler.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class InputHandler : MonoBehaviour &#123; public float horizontal; public float vertical; public float moveAmount; public float mouseX; public float mouseY; PlayerControls inputActions; Vector2 movementInput; Vector2 cameraInput; public void OnEnable() &#123; if(inputActions == null) &#123; inputActions = new PlayerControls(); inputActions.PlayerMovement.Movement.performed += inputActions =&gt; movementInput = inputActions.ReadValue&lt;Vector2&gt;(); inputActions.PlayerMovement.Camera.performed += i =&gt; cameraInput = i.ReadValue&lt;Vector2&gt;(); &#125; inputActions.Enable(); &#125; private void OnDisable() &#123; inputActions.Disable(); &#125; public void TickInput(float delta) &#123; MoveInput(delta); &#125; private void MoveInput(float delta) &#123; horizontal = movementInput.x; vertical = movementInput.y; moveAmount = Mathf.Clamp01(Mathf.Abs(horizontal) + Mathf.Abs(vertical)); mouseX = cameraInput.x; mouseY = cameraInput.y; &#125; &#125;&#125; PlayerLocomotion.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class PlayerLocomotion : MonoBehaviour &#123; Transform cameraObject; InputHandler inputHandler; Vector3 moveDirection; [HideInInspector] public Transform myTransform; [HideInInspector] public AnimatorHandler animatorHandler; public new Rigidbody rigidbody; public GameObject normalCamera; [Header(\"Stats\")] [SerializeField] float movementSpeed = 5; [SerializeField] float rotationSpeed = 10; // Start is called before the first frame update void Start() &#123; rigidbody = GetComponent&lt;Rigidbody&gt;(); inputHandler = GetComponent&lt;InputHandler&gt;(); animatorHandler = GetComponentInChildren&lt;AnimatorHandler&gt;(); cameraObject = Camera.main.transform; myTransform = transform; animatorHandler.Initialize(); &#125; public void Update() &#123; float delta = Time.deltaTime; inputHandler.TickInput(delta); moveDirection = cameraObject.forward * inputHandler.vertical; moveDirection += cameraObject.right * inputHandler.horizontal; moveDirection.Normalize(); moveDirection.y = 0; float speed = movementSpeed; moveDirection *= speed; Vector3 projectedVelocity = Vector3.ProjectOnPlane(moveDirection, normalVector); rigidbody.velocity = projectedVelocity; animatorHandler.UpdateAnimatorValues(inputHandler.moveAmount, 0); if (animatorHandler.canRotate) &#123; HandleRotation(delta); &#125; &#125; #region Movement Vector3 normalVector; Vector3 targetPostion; private void HandleRotation(float delta) &#123; Vector3 targetDir = Vector3.zero; float moveOverride = inputHandler.moveAmount; targetDir = cameraObject.forward * inputHandler.vertical; targetDir += cameraObject.right * inputHandler.horizontal; targetDir.Normalize(); targetDir.y = 0; if(targetDir == Vector3.zero) &#123; targetDir = myTransform.forward; &#125; float rs = rotationSpeed; Quaternion tr = Quaternion.LookRotation(targetDir); Quaternion targetRotation = Quaternion.Slerp(myTransform.rotation, tr, rs * delta); myTransform.rotation = targetRotation; &#125; #endregion &#125;&#125; AnimatorHandler.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using System.Collections;using System.Collections.Generic;using UnityEngine;namespace MJ &#123; public class AnimatorHandler : MonoBehaviour &#123; public Animator anim; int vertical; int horizontal; public bool canRotate; public void Initialize() &#123; anim = GetComponent&lt;Animator&gt;(); vertical = Animator.StringToHash(\"Vertical\"); horizontal = Animator.StringToHash(\"Horizontal\"); &#125; public void UpdateAnimatorValues(float verticalMovement, float horizontalMovement) &#123; #region Vertical float v = 0; if(verticalMovement &gt; 0 &amp;&amp; verticalMovement &lt; 0.55f) &#123; v = 0.5f; &#125;else if(verticalMovement &gt; 0.55f) &#123; v = 1; &#125;else if(verticalMovement &lt; 0 &amp;&amp; verticalMovement &gt; -0.55f) &#123; v = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; v = -1; &#125; else &#123; v = 0; &#125; #endregion #region Horizontal float h = 0; if(horizontalMovement &gt; 0 &amp;&amp; horizontalMovement &lt; 0.55f) &#123; h = 0.5f; &#125;else if(horizontalMovement &gt; 0.55f) &#123; h = 1; &#125;else if(horizontalMovement &lt; 0 &amp;&amp; horizontalMovement &gt; -0.55f) &#123; h = -0.5f; &#125;else if(verticalMovement &lt; -0.55f) &#123; h = -1; &#125; else &#123; h = 0; &#125; #endregion anim.SetFloat(vertical, v, 0.1f, Time.deltaTime); anim.SetFloat(horizontal, h, 0.1f, Time.deltaTime); &#125; public void CanRotate() &#123; canRotate = true; &#125; public void StopRotate() &#123; canRotate = false; &#125; &#125;&#125;","categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"通过脚本改变角色控制器","slug":"通过脚本改变角色控制器","date":"2020-06-16T14:23:44.000Z","updated":"2020-06-22T07:34:16.676Z","comments":true,"path":"2020/06/16/通过脚本改变角色控制器/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/16/%E9%80%9A%E8%BF%87%E8%84%9A%E6%9C%AC%E6%94%B9%E5%8F%98%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6%E5%99%A8/","excerpt":"Unity 2018 Cookbook | Charpter 10 3D Animation | Transforming the Character Controller via scripts 根动作是一种给角色赋予动画的手段。虽然实用且精准，但有时还是需要手动调整角色动作的一两个相位。如果你只有一个现成的动画，或者你想让角色的移动受到其他变量的影响。你将需要一个脚本来重载根动作。 本文中，我们将使用一个只在Y轴上运动的跳跃动画片段，使角色在跳跃的同事向前或向后移动，我们将学习如何使用脚本通过角色的速度来影响跳跃方向。","text":"Unity 2018 Cookbook | Charpter 10 3D Animation | Transforming the Character Controller via scripts 根动作是一种给角色赋予动画的手段。虽然实用且精准，但有时还是需要手动调整角色动作的一两个相位。如果你只有一个现成的动画，或者你想让角色的移动受到其他变量的影响。你将需要一个脚本来重载根动作。 本文中，我们将使用一个只在Y轴上运动的跳跃动画片段，使角色在跳跃的同事向前或向后移动，我们将学习如何使用脚本通过角色的速度来影响跳跃方向。 本文使用的资源链接：https://github.com/PacktPublishing/Unity-2018-Cookbook-Third-Edition/tree/master/Chapter10_3DAnimation/10_05_script_transform_control 完成后项目资源链接：https://github.com/dr-matt-smith/unity-cookbook-2018-ch10-05-script-control-transform 一、设置动画片段新建一个3D项目导入Jumping.unitypackage和Swat@rifle_jump.fbx。。在项目窗口里打开场景mecanimPlayground。 选中Rig标签，改变AnimationType为Humanoid and Avatar Definition toCreate From this Model . Confirm this byclicking on Apply . 点击Animations标签页，点击Clamp Range按钮调整时间线，勾选Loop Time和LoopPose选项。在Root Transform Rotation下勾选Bake Into Pose，设置Based Upon为Original。在Root Transform Position (Y)下方，保持Bake into Pose不勾选，设置Based Upon 为Original。在Root Transform Position (XZ) 下方保持Bake Into Pos不勾选，点击Apply应用设置。 二、设置动画状态在项目窗口双击MainCharacter动画控制器并进入Animator窗口，在左上角选择Parameters选项页，点击加号新建 Trigger类型参数Jump，新建一个状态取名Jump。选中Jump状态，给它的Motion配置动画片段rifle_jump。 从Any State到Jump建立转变关系，勾选Has Exit Time，添加条件参数Jump。 从Jump到Move建立转变关系，勾选Has Exit Time。 三、编辑脚本打开脚本文件BasicController.cs，添加变量声明 1234public float jumpHeight = 1f;private float verticalSpeed = 0f;private float xVelocity = 0f;private float zVelocity = 0f; 在Update方法的” if(controller.isGrounded){ “的下一行添加如下代码： 12345if (Input.GetKey(KeyCode.Space))&#123; anim.SetTrigger(\"Jump\"); verticalSpeed = jumpHeight;&#125; 在BasicController类的底部添加方法OnAnimatorMove： 12345678910111213141516171819202122private void OnAnimatorMove()&#123; Vector3 deltaPosition = anim.deltaPosition; if (controller.isGrounded) &#123; xVelocity = controller.velocity.x; zVelocity = controller.velocity.z; &#125; else &#123; deltaPosition.x = xVelocity * Time.deltaTime; deltaPosition.z = zVelocity * Time.deltaTime; anim.SetBool(\"Jump\", false); &#125; deltaPosition.y = verticalSpeed; controller.Move(deltaPosition); verticalSpeed += Physics.gravity.y * Time.deltaTime; if((controller.collisionFlags &amp; CollisionFlags.Below) != 0) &#123; verticalSpeed = 0; &#125;&#125; 保存脚本，播放游戏，我们可以通过空格键在角色走动的时候做跳跃动作。 BasicController.cs完整代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169using UnityEngine;using System.Collections;/* ---------------------------------------- * class to demonstrate how to control a * character using Character Controller and the Mecanim system */ public class BasicController: MonoBehaviour &#123; // Variable for the character's Animator component private Animator anim; // Variable for the character's Character Controller component private CharacterController controller; // float variable for dampening speed values public float transitionTime = .25f; // float variable for speed limit private float speedLimit = 1.0f; // boolean variable for moving diagonally, combining x and z speed public bool moveDiagonally = true; // boolean variable for directing the charater's direction with the mouse public bool mouseRotate = true; // boolean variable for directing the charater's direction with the keyboard public bool keyboardRotate = false; public float jumpHeight = 1f; private float verticalSpeed = 0f; private float xVelocity = 0f; private float zVelocity = 0f; /* ---------------------------------------- * At Start, get character's Animator and Character Controller components */ void Start () &#123; // Assign character's Controller to 'controller' variable controller = GetComponent&lt;CharacterController&gt;(); // Assign character's Animator to 'anim' variable anim = GetComponent&lt;Animator&gt;(); &#125; /* ---------------------------------------- * Whenever Directional controls are used, update variables from the Animator */ void Update () &#123; // IF Character Controller is grounded... if (controller.isGrounded) &#123; if (Input.GetKey(KeyCode.Space)) &#123; anim.SetTrigger(\"Jump\"); verticalSpeed = jumpHeight; &#125; // IF 'Q' key is being pressed, THEN... if(Input.GetKey(KeyCode.Q))&#123; //... set 'TurnLeft' bool variable of the Animator as true anim.SetBool(\"TurnLeft\", true); // ... and rotate character to its left transform.Rotate(Vector3.up * (Time.deltaTime * -45.0f), Space.World); // ELSE, if 'Q' key is NOT being pressed, THEN... &#125; else &#123; //... set 'TurnLeft' bool variable of the Animator as false anim.SetBool(\"TurnLeft\", false); &#125; // IF 'E' key is being pressed, THEN... if(Input.GetKey(KeyCode.E))&#123; //... set 'TurnRight' bool variable of the Animator as true anim.SetBool(\"TurnRight\", true); // ... and rotate character to its right transform.Rotate(Vector3.up * (Time.deltaTime * 45.0f), Space.World); // ELSE, if 'E' key is NOT being pressed, THEN... &#125; else &#123; //... set 'TurnRight' bool variable of the Animator as false anim.SetBool(\"TurnRight\", false); &#125; if (Input.GetKey (KeyCode.RightShift) ||Input.GetKey (KeyCode.LeftShift)) // IF Shift key is pressed, THEN set speed limit to 0.5, slowing down the character speedLimit = 0.5f; else // ELSE, set speed limit to full speed (1.0) speedLimit = 1.0f; // a float variable to get Horizontal Axis input (left/right) float h = Input.GetAxis(\"Horizontal\"); // a float variable to get Vertical Axis input (forward/backwards) float v = Input.GetAxis(\"Vertical\"); // float variable for horizontal speed and direction, obtained by multiplying Horizontal Axis by the speed limit float xSpeed = h * speedLimit; // float variable for vertical speed and direction, obtained by multiplying Vertical Axis by the speed limit float zSpeed = v * speedLimit; // float variable for absolute speed float speed = Mathf.Sqrt(h*h+v*v); if(v!=0 &amp;&amp; !moveDiagonally) // IF Vertical Axis input is different than 0 AND moveDiagonally boolean is set to false, THEN set horizontal speed as 0 xSpeed = 0; if(v!=0 &amp;&amp; keyboardRotate) // IF Vertical Axis input is different than 0 AND keyboardRotate boolean is set to true, THEN rotate character according to Horizontal Axis input this.transform.Rotate(Vector3.up * h, Space.World); if(mouseRotate) // IF mouseRotate boolean is set to true, THEN rotate character according to Horizontal mouse movement this.transform.Rotate(Vector3.up * (Input.GetAxis(\"Mouse X\")) * Mathf.Sign(v), Space.World); // Set zSpeed float as 'zSpeed' variable of the Animator, dampening it for the amount of time in 'transitionTime' anim.SetFloat(\"zSpeed\", zSpeed, transitionTime, Time.deltaTime); // Set xSpeed float as 'xSpeed' variable of the Animator, dampening it for the amount of time in 'transitionTime' anim.SetFloat(\"xSpeed\", xSpeed, transitionTime, Time.deltaTime); // Set speed float as 'Speed' variable of the Animator, dampening it for the amount of time in 'transitionTime' anim.SetFloat(\"Speed\", speed, transitionTime, Time.deltaTime); &#125; if(Input.GetKeyDown(KeyCode.F))&#123; // IF 'F' key is pressed, THEN set 'Grenade' variable of the Animator as true anim.SetBool(\"Grenade\", true); &#125; else &#123; // ELSE, set 'Grenade' variable of the Animator as false anim.SetBool(\"Grenade\", false); &#125; if(Input.GetButtonDown(\"Fire1\"))&#123; // IF the 'Fire' button is pressed, THEN set 'Fire' variable of the Animator as true anim.SetBool(\"Fire\", true); &#125; if(Input.GetButtonUp(\"Fire1\"))&#123; // IF the 'Fire' button is released, THEN set 'Fire' variable of the Animator as false anim.SetBool(\"Fire\", false); &#125; &#125; private void OnAnimatorMove() &#123; Vector3 deltaPosition = anim.deltaPosition; if (controller.isGrounded) &#123; xVelocity = controller.velocity.x; zVelocity = controller.velocity.z; &#125; else &#123; deltaPosition.x = xVelocity * Time.deltaTime; deltaPosition.z = zVelocity * Time.deltaTime; anim.SetBool(\"Jump\", false); &#125; deltaPosition.y = verticalSpeed; controller.Move(deltaPosition); verticalSpeed += Physics.gravity.y * Time.deltaTime; if((controller.collisionFlags &amp; CollisionFlags.Below) != 0) &#123; verticalSpeed = 0; &#125; &#125;&#125; 四、工作原理注意到当这个功能脚本加入到MsLaser时，MsLaser的Animator组件|Apply Root Motion参数变为Handled by Script（由脚本管理）。 OnAnimatorMove()方法中的指令重写了动画动作，其中controller.Move(deltaPosition)通过deltaPosition 3D 向量基本上替换了跳跃的方向。deltaPosition 3D 向量由角色跳前瞬时速度和变量jumpHeight与重力的随时间变化的计算结果（Y轴）。 通过语句“ SetTrigger(“Jump”) ”在Animator控制器里触发转变条件Jump为true，实现从Any State到Jump的状态转变。 Trigger类型参数与Bool类型参数类似，不同在于Trigger类型参数在被触发为true后，自动变回false。不需要再写代码将触发器设为false。 Trigger类型参数适用于事件发生后返回原来的状态。Jump状态到Move状态不需要条件，因此Jump动画播放完返回Move状态。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"将多个状态组成子状态机","slug":"将多个状态组成子状态机","date":"2020-06-14T14:23:58.000Z","updated":"2020-06-15T07:19:07.950Z","comments":true,"path":"2020/06/14/将多个状态组成子状态机/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/14/%E5%B0%86%E5%A4%9A%E4%B8%AA%E7%8A%B6%E6%80%81%E7%BB%84%E6%88%90%E5%AD%90%E7%8A%B6%E6%80%81%E6%9C%BA/","excerpt":"Unity 2018 Cookbook | Charpter 10 3D Animation | Organizing States into Sub-State Machines 当Animator窗口中的内容太过凌乱时，我们可以考虑将多个动画状态组成子状态机。 在本篇，我们将使用这个技术来驱动角色。因为要用到的动画剪辑不包含根动作（Root Motion），借此说明如何在无需根动作（Root Motion）的条件下通过一个脚本控制角色从左/右转向45°。","text":"Unity 2018 Cookbook | Charpter 10 3D Animation | Organizing States into Sub-State Machines 当Animator窗口中的内容太过凌乱时，我们可以考虑将多个动画状态组成子状态机。 在本篇，我们将使用这个技术来驱动角色。因为要用到的动画剪辑不包含根动作（Root Motion），借此说明如何在无需根动作（Root Motion）的条件下通过一个脚本控制角色从左/右转向45°。 一、导入资源用到的资源链接： https://github.com/PacktPublishing/Unity-2018-Cookbook-Third-Edition/tree/master/Chapter10_3DAnimation/10_04_substate_machines 完成后的项目资源链接： https://github.com/dr-matt-smith/unity-cookbook-2018-ch10-04-substate-machines 导入资源Turning.unitypackage、Swat@turn_right_45_degrees.fbx、Swat@turn_left.fbx、BasicController.cs。 二、设置动画剪辑在项目窗口找到并双击打开关卡场景mecanimPlayground，接下来设置动画剪辑。 在项目窗口选中Swat@turn_left，在Inspector选中Rig标签，修改Animation Type为Humanoid，设置Avatar Definition为Create From this Model，点击Apply确认应用。 点击Animation标签，点击Clamp Range按钮，调节动画时间线（Start：0，End：40），勾选Loop Time。 勾选Root Transform Rotation下方的Bake Into Pose，设置Based Upon为Original。勾选Root Transform Position ( Y )下方的Bake Into Pose，设置Based Upon (atStart)为Original。保持Root TransformPosition (XZ)下方的Bake Into Pose未选中，点击Apply应用修改。 对Swat@turning_right_45_degrees做同样的设置。 三、添加子状态机双击动画控制器MainCharacter并进入Animator窗口，选则Parameters标签，点击加号新建两个布尔类型参数，分别重命名为TurnLeft，TurnRight。 选中Base Layer层，在网格区域右键，选择 select Create Sub-StateMachine，在Inspector重命名为Turn。双击进入子状态机Turn。在网格区域右键，选择 Create State | Empty 新建一个空状态，重命名为Turn Left。同样地，再新建一个状态Turn Right。给状态Turn Left分配动画剪辑turn_left motion clip，给状态Turn Right分配动画剪辑turning_right_45_degrees。 点击顶部信息栏的Base Layer回到Base Layer层。 从Move状态起始，新建一个转换关系, 点击Turn，选择State | Turn Left。选中刚刚建立的箭头，在Inspector里取消勾选Has Exit Time，在条件列表里点击加号，添加条件TurnLeft值为true。同样地，再建一个从Move到Turn Right子状态的转换关系。 进入子状态机Turn,选中Turn Left状态右键建立转变关系，点击(Up)Base Layer，选则States|Move。选中刚建立的箭头，再Inspector里取消勾选Has Exit Time，在条件列表里点击加号添加条件TurnLeft值为false。同样再建立从Turn Right到Move的转变关系。 四、脚本功能打开脚本BasicController.cs，在Update方法的“ if(controller.isGrounded){ “下一行添加如下代码： 123456789101112131415161718192021222324252627...void Update () &#123; // IF Character Controller is grounded... if(controller.isGrounded)&#123; if (Input.GetKey(KeyCode.Q)) &#123; anim.SetBool(\"TurnLeft\", true); transform.Rotate(Vector3.up * (Time.deltaTime * -45.0f), Space.World); &#125; else &#123; anim.SetBool(\"TurnLeft\", false); &#125; if (Input.GetKey(KeyCode.E)) &#123; anim.SetBool(\"TurnRight\", true); transform.Rotate(Vector3.up * (Time.deltaTime * 45.0f), Space.World); &#125; else &#123; anim.SetBool(\"TurnRight\", false); &#125; ... &#125; ...&#125; 保存脚本，选中Hirarchy中的MsLaser，在Inspector里的Basic Controller组件下取消勾选Move Diagonally、Mouse Rotate，勾选KeyBoard Rotate。 播放游戏，我们可以按住Q键/E键来控制角色的左右转向。 五、工作原理子状态机可以将多个状态封装成一个简便易调用的实体。子状态机内部的状态可以转变到外部的状态，甚至可以转变到其他子状态机里的状态。 关于角色转向，我们使用“ transform.Rotate(Vector3.up *(Time.deltaTime * -45.0f) , Space.World) ”语句让角色在我们按下Q/E键时转向，语句” animator.SetBool(“TurnLeft”, true) “用于触发正确的动画剪辑，从而不需要根动作（Root Motion）。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"通过动画层和动画遮罩制作混合动画","slug":"通过动画层和动画遮罩制作混合动画","date":"2020-06-14T07:42:50.000Z","updated":"2020-06-15T06:16:42.468Z","comments":true,"path":"2020/06/14/通过动画层和动画遮罩制作混合动画/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/14/%E9%80%9A%E8%BF%87%E5%8A%A8%E7%94%BB%E5%B1%82%E5%92%8C%E5%8A%A8%E7%94%BB%E9%81%AE%E7%BD%A9%E5%88%B6%E4%BD%9C%E6%B7%B7%E5%90%88%E5%8A%A8%E7%94%BB/","excerpt":"Unity 2018 Cookbook | Chapter 10 3D Animation | Mixing animations with Layersand Masks 使用混合动画可以增加角色动画的复杂度，节省了很多动画剪辑。通过混合动画，我们可以对角色指定身体部位播放指定的动画。 在本篇中，我们将使用这个技术实现角色在下半身保持闲置或行动的同时，上半身做出射击和扔手榴弹的动作。","text":"Unity 2018 Cookbook | Chapter 10 3D Animation | Mixing animations with Layersand Masks 使用混合动画可以增加角色动画的复杂度，节省了很多动画剪辑。通过混合动画，我们可以对角色指定身体部位播放指定的动画。 在本篇中，我们将使用这个技术实现角色在下半身保持闲置或行动的同时，上半身做出射击和扔手榴弹的动作。 一、导入资源需要的资源的链接： https://github.com/PacktPublishing/Unity-2018-Cookbook-Third-Edition/tree/master/Chapter10_3DAnimation/10_03_mix_mask_anims 完成后的项目资源链接： https://github.com/dr-matt-smith/unity-cookbook-2018-ch10-03-mask-layers-mixing-animations 首先导入Mixing.unitypackage、Swat@firing_rifle.fbx、Swat@toss_grenade.fbx、BasicController.cs 。 二、设置动画剪辑在项目窗口里双击打开场景mecanimPlayground level，选中项目窗口里的Swat@firing_rifle，在Inspector选中Rig标签，修改Animation Type为Humanoid，设置Avatar Definition为Create From this Model，点击Apply确认。 然后点击Animation选项卡，点击Clamp Range按钮后可以调节动画时间线。勾选Loop Time、Loop Pose，在Root Transform Rotation下方勾选Bake Into Pose，Based Upon选择Original。在Root Transform Position (Y)下方勾选Bake Into Pose，Based Upon (at Start)选择Original。Root Transform Position (XZ)下方的Bake Into Pose保持不勾选，点击Apply。 同理设置Swa t@toss_grenade，具体不同设置建下图。 三、创建动画遮罩在项目窗口新建一个Avatar Mask并重命名为BodyMask。选中BodyMask，在Inspector里展开Humanoid section，身体区块或IK节点呈现绿色表示已被选中（默认全部选中），红色则表示未选中。我们点击取消选中角色的两条腿、脚下踩着的圆形区块以及两个脚IK节点。 四、创建动画层在项目窗口里双击打开动画控制器MainCharacter并进入到Animator窗口。 点击Layers选项卡，然后点击加号新建一个动画层，命名为Upper Body。点击Upper Body右边的小齿轮按钮进一步设置，修改Weight参数为1，然后在Mask选则刚才做好的BodyMask，Blending选择Additive。 在Upper Body层里（即选中Upper Body层），在网格区里通过右键|Create State |Empty新建两个空的状态，然后分别重命名为Fire、Grenade，将橘黄色的默认状态重命名为Null。 点击Parameters选项卡，新建两个Bool类型条件参数，分别命名为Fire、Grenade。选中Fire状态，在Inspector里的Motion选择动画剪辑firing_rifle。同理，Grenade的Motion选择动画剪辑toss_grenade。 右键Null状态，选择Make Transition，点击Fire状态，建立一条由Null到Fire的转变关系（箭头）。选中这个箭头，在Inspector里取消勾选Has Exit Time选项，在Condition里点击加号添加转变条件，选择Fire，值选中true。同理，给Null状态到Grenade状态建立一个转变关系，取消勾选Has Exit Time，转变条件为Grenade值等于true。 然后再建立Grenade到Null的转变箭头，勾选Has Exit Time，转变条件为Grenade值等于false。建立Fire到Null的转变箭头，勾选Has Exit Time，转变条件为Fire值等于false。 五、脚本功能双击打开脚本BasicController.cs，再Update方法结尾处添上如下代码： 123456789101112131415161718192021void Update () &#123; ... //控制播放扔手榴弹动画 if (Input.GetKeyDown(KeyCode.F)) &#123; anim.SetBool(\"Grenade\", true); &#125; else &#123; anim.SetBool(\"Grenade\", false); &#125; //控制播放开火射击动画 if (Input.GetButtonDown(\"Fire1\")) &#123; anim.SetBool(\"Fire\", true); &#125; if (Input.GetButtonUp(\"Fire1\")) &#123; anim.SetBool(\"Fire\", false); &#125;&#125; 保存代码，然后播放游戏，这时我们可以通过WASD控制角色走动，并且可以一边走动一边单击鼠标左键开火，一边走动一边按F键扔手榴弹。 六、实现原理动画遮罩（Avatar Mask）筛出角色的某个身体部位再某个动画层中的某个动作。 除此之外，案例中Upper body层的设置参数Blending除了Additve还可以设置为Override。设置为Additive表示当前层的动画状态将附加在权重低的动画层之上。如果改为Override，当前层的动画将完全覆盖权重低的动画层。 关于动画层和动画遮罩的更多信息： http://docs.unity3d.com/Manual/AnimationLayers.html http://docs.unity3d.com/Manual/class-AvatarMask.html","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"利用根动作和混合树实现角色走动","slug":"利用根动作和混合树实现角色走动","date":"2020-06-13T07:34:48.000Z","updated":"2020-06-17T07:13:53.778Z","comments":true,"path":"2020/06/13/利用根动作和混合树实现角色走动/","link":"","permalink":"https://weimingjuncn.github.io/2020/06/13/%E5%88%A9%E7%94%A8%E6%A0%B9%E5%8A%A8%E4%BD%9C%E5%92%8C%E6%B7%B7%E5%90%88%E6%A0%91%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2%E8%B5%B0%E5%8A%A8/","excerpt":"Unity 2018 Cookbook | Charpter 10 3D Animation | Moving Your character with root motion and Blend Trees Mecanim动画系统可以将根动作（Root Motion）应用到角色上。换言之，它可以让角色根据动画剪辑自然协调地运动从而避免角色虽然有所移动但看上去像是在循环播放原地踏步。 该动画系统的另一个特色功能是混合树。混合树简单易用，可以过渡自然地混合多个动画剪辑。在本篇，物品们将利用这些特色功能实现角色的向前或向后行走、奔跑，以及以不同的速度左拐和右拐。","text":"Unity 2018 Cookbook | Charpter 10 3D Animation | Moving Your character with root motion and Blend Trees Mecanim动画系统可以将根动作（Root Motion）应用到角色上。换言之，它可以让角色根据动画剪辑自然协调地运动从而避免角色虽然有所移动但看上去像是在循环播放原地踏步。 该动画系统的另一个特色功能是混合树。混合树简单易用，可以过渡自然地混合多个动画剪辑。在本篇，物品们将利用这些特色功能实现角色的向前或向后行走、奔跑，以及以不同的速度左拐和右拐。 一、资源导入往Unity导入动画有两种形式。其中一种形式是一个动作片段对应一个动画文件，导入的每一个动画文件都有统一的命名格式（modelName@animation），比如MsLazer@idle、MsLazer@jumping等。另一种形式是一个模型对应一个动画文件，这个动画包含所有需要的动作片段，使用时需要开发者在Unity编辑器中通过指定起始帧和结束帧来剪切。 本篇使用的是第一种形式，因为比较简单明了。 了解更多可以参考文档： https://docs.unity3d.com/Manual/Splittinganimations.html . 本篇使用的资源链接：https://github.com/PacktPublishing/Unity-2018-Cookbook-Third-Edition/tree/master/Chapter10_3DAnimation/10_02_root_motion_blend 完成后项目资源链接：https://github.com/dr-matt-smith/unity-cookbook-2018-ch10-02-root-motion-blend-trees 新建一个项目，导入Character_02.unitypackage。导入FBX文件Swat@rifle_run、Swat@run_backward、Swat@strafe、Swat@strafe_2、Swat@strafe_left、Swat@strafe_right、Swat@walking、Swat@walking_backward。 二、设置动画片段在项目窗口选中Swat@rifle_run，在Inspector点击Rig标签。修改AnimationType为Humanoid，设置Avatar Definition为Create From this Model，点击Apply确认。 点击Animations标签 (Rig的右边 )，预览窗口 (Inspector底部)将显示消息“ No model is available for preview ”。拖拽MsLaser@T-Pose到预览窗口。 勾选Loop Time和Loop Pose选项。点击Clamp Range按钮调节时间线调至动画片段的实际时间段（23帧后角色暂停运动左移剪掉），点击Apply确认。 勾选Root Transform Rotation下的Bake Into Pose，设置Based Upon为Original。在Root Transform Position (Y)下勾选Bake Into Pose，设置BasedUpon (at Start)为Original。保持RootTransform Position (XZ)下的Bake Into Pose为未勾选，设置Based Upon (atStart)为Center of Mass，最后点击Apply。 重复上述步骤设置以下动画片段：Swat@run_backward、Swat@strafe、Swat@strafe_2、Swat@strafe_left、Swat@strafe_right、Swat@walking、Swat@walking_backward。 现在在场景中添加一个3D平台，在Hierarchy窗口里右键，选择3D Object | Plane。 将预制体MsLaser的一个实例拖拽到场景中的平台上。在Hierarchy窗口选中MsLaser这个GameObject，在Inspector添加一个Character Controller组件（点击Add Component按钮，选择Component | Physics| Character Controller）。然后设置Skin Width为0.0001，Center为（0, 0.9, 0），修改Radius为0.34，Height为1.79。 在Project窗口里双击动画控制器MainCharacter顺便打开了Animator窗口。选择Animator窗口左上的Parameters标签，点击加号添加3个Float类型参数，分别重命名为xSpeed、zSpeed、Speed。 三、建立混合树在已有的Base Layer动画中里已经有了一个Idle状态，这时我们需要再新建一个，在网格区域右键选择Create State | From New BlendTree。选中BlendTree状态，在Inspector里重命名为Move 。 双击进入Move，里边有一个空的混合树。选中这个Blend Tree，在Inspector重命名为itMove,，然后修改Blend Type为2DFreeform Directional。在Parameters 处设置参数为xSpeed和zSpeed。最后点击Motion列表底部的加号添加动作域，添加9个动作域。 使用以下动作片段部署动作域和他们的Pos X、Pos Y值： 动作域 Pos X Pos Y Run_backwards 0 -1 Walking_backwards 0 -0.5 Rifle_aiming_idle 0 0 Walking 0 0.5 Rifle_run 0 1 Strafe -1 0 Strafe_left -0.5 0 Strafe_right 0.5 0 Strafe_2 1 0 通过点击动作域，然后在弹出窗口选择动作片段，或者如果多个动作片段有相同的名字，可以从项目窗口点击模型图标展开，然后拖拽进来。 要回到Base Layer，可以双击Animator窗口的网格背景返回，或者点击Animator窗口顶部的Base Layer按钮。 因为Move混合树中已经具备rifle_aiming_idle动作片段，我们可以删掉原有的Idle状态（右键Idle状态，在菜单中选择Delete）。Move混合状态的颜色将变为橙色，表示成为新的默认状态。 四、添加脚本现在添加脚本，真正将玩家的输入转化为控制动画的变量。新建一个C#脚本，命名为BasicController ,将其作为组件添加到场景中的MsLazer对象。脚本代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091using UnityEngine;using System.Collections;/* ---------------------------------------- * class to demonstrate how to control a * character using Character Controller and the Mecanim system */ public class BasicController: MonoBehaviour &#123; // reference to character's Animator component private Animator anim; // reference to character's Character Controller component private CharacterController controller; // dampening speed public float transitionTime = .25f; // speed limit private float speedLimit = 1.0f; // moving diagonally glaf (true then combine x and z speed) public bool moveDiagonally = true; // control character's direction with mouse public bool mouseRotate = true; // control character's direction with keyboard public bool keyboardRotate = false; /* ---------------------------------------- * cache character's Animator and Character Controller components */ void Start () &#123; controller = GetComponent&lt;CharacterController&gt;(); anim = GetComponent&lt;Animator&gt;(); &#125; /* ---------------------------------------- * Whenever Directional controls are used, update variables from the Animator */ void Update () &#123; // IF Character Controller is grounded... if(controller.isGrounded)&#123; if (Input.GetKey (KeyCode.RightShift) ||Input.GetKey (KeyCode.LeftShift)) // IF Shift key is pressed, THEN set speed limit to 0.5, slowing down the character speedLimit = 0.5f; else // ELSE, set speed limit to full speed (1.0) speedLimit = 1.0f; // a float variable to get Horizontal Axis input (left/right) float h = Input.GetAxis(\"Horizontal\"); // a float variable to get Vertical Axis input (forward/backwards) float v = Input.GetAxis(\"Vertical\"); // float variable for horizontal speed and direction, obtained by multiplying Horizontal Axis by the speed limit float xSpeed = h * speedLimit; // float variable for vertical speed and direction, obtained by multiplying Vertical Axis by the speed limit float zSpeed = v * speedLimit; // float variable for absolute speed float speed = Mathf.Sqrt(h*h+v*v); if(v!=0 &amp;&amp; !moveDiagonally) // IF Vertical Axis input is different than 0 AND moveDiagonally boolean is set to false, THEN set horizontal speed as 0 xSpeed = 0; if(v!=0 &amp;&amp; keyboardRotate) // IF Vertical Axis input is different than 0 AND keyboardRotate boolean is set to true, THEN rotate character according to Horizontal Axis input this.transform.Rotate(Vector3.up * h, Space.World); if(mouseRotate) // IF mouseRotate boolean is set to true, THEN rotate character according to Horizontal mouse movement this.transform.Rotate(Vector3.up * (Input.GetAxis(\"Mouse X\")) * Mathf.Sign(v), Space.World); // Set zSpeed float as 'zSpeed' variable of the Animator, dampening it for the amount of time in 'transitionTime' anim.SetFloat(\"zSpeed\", zSpeed, transitionTime, Time.deltaTime); // Set xSpeed float as 'xSpeed' variable of the Animator, dampening it for the amount of time in 'transitionTime' anim.SetFloat(\"xSpeed\", xSpeed, transitionTime, Time.deltaTime); // Set speed float as 'Speed' variable of the Animator, dampening it for the amount of time in 'transitionTime' anim.SetFloat(\"Speed\", speed, transitionTime, Time.deltaTime); &#125; &#125;&#125; 播放游戏，我们可以用方向键或WASD键控制角色走动。按住Shift键将减慢走动速度。 五、工作原理当BasicController脚本检测到任一方向键被按下，它将动画状态的速度变量赋上大于0的值，进而从闲置动画转为行动动画。Move状态根据输入变量混合已部署的动作片段。输入变量xSpeed从水平轴输入获取，典型例如A/D键，输入变量zSpeed从垂直轴输入获取，典型例如W/S键。Mecanim动画系统将根动作应用到角色上，角色根据获取到的方向进行移动。 例如当W键和D键被按下， 变量xSpeed和变量zSpeed的值将提升至1.0。从Inspector可以看到，这两个变量的结合将导致动作片段rifle_run和strafe_2的混合，让角色沿前右斜对角方向行动。 BasicController组件下右3个复选框：Move Diagonally默认勾选表示允许向前/向后运动可以与向左/向右运动混合；Mouse Rotate默认勾选表示允许角色在运动过程中通过鼠标转向；Keyboard Rotate默认不勾选允许同时按下键盘前/后方向键与左/右方向键来使角色转向。 混合树使用2D Freeform Directional混合类型。然而，如果我们只有四个动作片段（前后左右），2D Simple Directional将会是更好的选择。 了解更多关于混合树和二维混合可以查看Unity文档：http://docs.unity3d.com/Manual/BlendTree-2DBlending.html 关于Mecanim动画系统的详细介绍，通过以下链接查看：http://docs.unity3d.com/Manual/AnimationOverview.html Mecanim场景样例可以在Unity Asset Store获取：https://www.assetstore.unity3d.com/en/#!/content/5328 Mecanim视频教程可以在这里获取：http://unity3d.com/pt/learn/tutorials/topics/animation","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"Unity动画系统","slug":"Unity动画系统","date":"2020-04-24T13:47:19.000Z","updated":"2020-06-13T07:43:05.817Z","comments":true,"path":"2020/04/24/Unity动画系统/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/24/Unity%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/","excerpt":"动画的播放控制、人形动画、动画遮罩、分层控制、退出控制、动画事件","text":"动画的播放控制、人形动画、动画遮罩、分层控制、退出控制、动画事件 创建一个项目AnimationDemo，导入资源包Assets.unitypackage和Mking.unitypackage，进入Assets/Fantasy Forest Environment Free Sample/Scenes下的demoScene_free场景，将Hierarchy里的LowPoly_Cyc(1)、LowPoly_Cyc(2)、LowPoly_Cyc(3)删掉，保存场景。在LowPoly_Cyc的Inspector视窗里单击Animator|Avatar：modelAvatar，然后选中modelAvatar对应的model。 model里还没有添加上动画，我们再看看model下方的Ready。 点击Inspector下方的播放小按钮，可以预览动画剪辑Ready，我们也可以添加动画剪辑，点击加号新增一个Take 001，然后设置起始时间和结束时间即可。 接下来我们右键Hierarchy下的LowPoly_Cyc，点击Unpack Prefab取消预制体，再将LowPoly_Cyc的Animator组件移除掉。下边将从零讲解Unity动画的添加与设置 一、动画的播放控制我们在Assets文件夹下新建一个Animator文件夹，在其中创建一个Animator Controller(动画控制器)，重命名为enemyAnimator，双击打开。然后将Assets/LowPoly_Cyc/FBX/Ready下的动画剪辑Ready拖拽到Animator视窗。同理，将动画剪辑Run、skill1、skill2、skill3、Stun也拖拽进来。 在Animtor窗口里，选中AnyState右键选择Make Transition（创建过渡），再点击添加进来的动画剪辑，进行连接。 接着我们在右边的Parameters视窗设置过渡条件。 过渡条件有Float、Int、Bool、Trigger。我们先添加一个Int类型过渡条件，命名为id。选中AnyState到Run之间的过渡条件箭头，在其Inspector|Conditions修改条件为“id Equals 1”。 同理，将AnyState到skill1、skill2、skill3、Stun的条件分别设置为”id Equals 0、2、3、4、5”。 将Settings|Can Transition To（可以过渡到自己）取消勾选 给LowPoly_Cyc添加一个Animator（动画器）组件，将Assets/LowPoly_Cyc/FBX/model下的modelAvatar添加到Animator|Avatar 将Assets/Animator/enemyAnimator拖拽到Animator|Controller 然后创建一个脚本文件AnimatorMgr.cs 1234567891011121314151617181920212223242526272829303132333435363738394041using System.Collections;using System.Collections.Generic;using UnityEngine;public class AnimatorMgr : MonoBehaviour&#123; Animator anim; // Start is called before the first frame update void Start() &#123; anim = transform.GetComponent&lt;Animator&gt;(); &#125; // Update is called once per frame void Update() &#123; if (Input.GetKeyDown(KeyCode.Alpha0)) &#123; anim.SetInteger(\"id\", 0); &#125; else if (Input.GetKeyDown(KeyCode.Alpha1)) &#123; anim.SetInteger(\"id\", 1); &#125; else if (Input.GetKeyDown(KeyCode.Alpha2)) &#123; anim.SetInteger(\"id\", 2); &#125; else if (Input.GetKeyDown(KeyCode.Alpha3)) &#123; anim.SetInteger(\"id\", 3); &#125; else if (Input.GetKeyDown(KeyCode.Alpha4)) &#123; anim.SetInteger(\"id\", 4); &#125; else if (Input.GetKeyDown(KeyCode.Alpha5)) &#123; anim.SetInteger(\"id\", 5); &#125; &#125;&#125; 将AnimatorMgr.cs作为组件添加到LowPoly_Cyc。 播放游戏，角色先进入Ready动画状态，然后按1进入Run状态，按2进入skill1状态，按3进入skill2状态，按4进入skill3状态，按5进入Stun状态。 要想动画循环播放，双击Animator窗口中要循环的动画状态（例如Ready），在项目窗口对应的文件会被选中，在Inspector视窗勾选Loop Time（循环时间），点击Apply即可。 二、人形动画 动画的复用 在Assets/asobi_chan_b/Assets/Meshes下有一个人型模型asobi_chan_b，在它下边只有两个动画Take001和Take002。 我们将asobi_chan_b拖拽进场景中，在Inspector取消勾选Animator|Apply Root Motion，因为根运动（Root Motion）用于动画控制，它可以使角色在场景中随着动画跑动。 然后选中Assets/Animator下的enemyAnimator，按Ctrl+D拷贝一份，重命名为PlayerAnimator，拖拽添加到场景中的asobi_chan_b的Animator|Controller。 双击打开PlayerAnimator，在Animator窗口中选中Ready，将Assets/asobi_chan_b/Assets/Meshs/asobi_chan_b/Take 001拖拽到Motion，将Take 002拖拽到Run的Motion。 在Assets/Mking/mAnimation下还有一个人形动画模型@MK_attackWhirl，我们可以将它的攻击动画复用到asobi_chan_b上。于是选中PlayerAnimtor中的skill1状态，将Assets/Mking/mAnimation/@MK_attackWhirl/MK_attackWhirl拖拽到Motion。同样地，将MK_blockAttack拖拽到skill2的Motion，将MK_stabJumpFward拖拽到skill3的Motion，将MK_hitFfront拖拽到Stun的Motion， 复制LowPoly_Cyc的脚本组件，添加到asobi_chan_b中 选中项目窗口里的asobi_chan_b，在Animation选项卡下，选中Take 002，然后勾选下方的Loop Time。 保存后播放游戏，角色开始处于闲置状态，当按下1时，开始跑动。 当按下2时，开始执行attackWhirl。 当按下3时，开始执行blockAttack。 当按下4时，开始执行stabJumpFward。 当按下5时，开始执行hitFfront。 三、动画遮罩 屏蔽某个部位的运动 在项目窗口右键新建|Avatar Mask，重名名为EnemyAvatar，拷贝一份后再重命名为PlayerAvatar。 选中EnemyAvatar，将Assets/LowPoly_Cyc/FBX/model/modelAvatar拖拽到EnemyAvatar的Transform|Use skeleton from，点击Import skeleton。 打开EnemyAnimator，点击Base Layer右边的小齿轮，点击Mask，选择EnemyAvatar。 回到EnemyAvatar的Inspector窗口，取消勾选角色的下半身节点，播放游戏，角色无论做哪些动画都是下半身僵直的。 接下来对人形动画使用遮罩，我们先在PlayerAnimator创建一个Run动画层，然后在其中添加一个Run状态，在其Motion附上动画剪辑Run。从Any State到Run建立一个转变关系，转变条件设为id值等于1，同时将Base Layer里的Any State到Run的条件改为id等于1000。拷贝一个PlayerAvatar，名为PlayerAvatar 1，设置PlayerAvatar如下： 设置PlayerAvatar 1如下： 将PlayerAvatar 1应用到Base Layer，将PlayerAvatar应用到Run，并设置Run的Weight为1。 点击播放游戏，角色会立刻开始奔跑，当我们按2时，角色下半身保持奔跑，上半身做攻击动作。 四、分层控制和退出控制五、动画事件","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"Unity用户输入管理","slug":"Unity用户输入管理","date":"2020-04-22T13:41:00.000Z","updated":"2020-06-13T08:42:30.893Z","comments":true,"path":"2020/04/22/Unity用户输入管理/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/22/Unity%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%AE%A1%E7%90%86/","excerpt":"虚拟轴、获取键盘事件、获取鼠标事件、移动设备输入","text":"虚拟轴、获取键盘事件、获取鼠标事件、移动设备输入 一、虚拟轴使用API：Input.GetAxis()，参数：轴的名称 根据当前输入实时变更，所以使用的时候应该去持续获得更新的值，否则得到的结果是不准确的 使用范围：较多应用在对角色的控制上 例子我们可以在菜单栏|Edit|Project Settings…|Input Manager里查看有关玩家输入的设置 新建一个Test.cs，将其作为组件添加到一个物体上比如一个Capsule。，编辑Test.cs如下： 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;public class Test : MonoBehaviour&#123; // Update is called once per frame void Update() &#123; float horizontal = Input.GetAxis(\"Horizontal\"); float vertical = Input.GetAxis(\"Vertical\"); if(horizontal != 0) &#123; transform.position = new Vector3(transform.position.x + (horizontal * 0.1f), transform.position.y, transform.position.z); &#125; if (vertical != 0) &#123; transform.position = new Vector3(transform.position.x, transform.position.y, transform.position.z + (vertical * 0.1f)); &#125; &#125;&#125; 播放游戏，我们可以通过按键盘的上下左右方向键或WASD控制Capsule的前后左右平移。 要控制Capsule的转向，我们还可以修改Test.cs的Update方法如下： 12345678910111213141516171819202122void Update() &#123; float horizontal = Input.GetAxis(\"Horizontal\"); float vertical = Input.GetAxis(\"Vertical\"); if(horizontal != 0) &#123; //transform.position = new Vector3(transform.position.x + (horizontal * 0.1f), // transform.position.y, // transform.position.z); transform.eulerAngles = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y + horizontal, transform.eulerAngles.z); &#125; if (vertical != 0) &#123; transform.position = new Vector3(transform.position.x, transform.position.y, transform.position.z + (vertical * 0.1f)); &#125; &#125; 播放游戏，我们可以通过左右方向键或AD键控制Capsule的水平转向。 二、获取键盘事件使用API： Input.GetKey，某个键是否被持续按下； Input.GetKeyDown，某个键是否被按下； Input.GetKeyUp，某个键是否被弹起。 可以传递小写的键的名称作为参数，也可以传递一个KeyCode的值，返回值属于布尔类型。 使用范围： 需要根据玩家按下键盘上某个键才能触发的事件上，比如说技能释放，需要等待用户按下技能键的时候进行释放，由或者说按下ESC键呼出系统菜单等。 例子编辑Test.cs如下： 1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;public class Test : MonoBehaviour&#123; // Update is called once per frame void Update() &#123; if (Input.GetKey(KeyCode.A))//或者Input.GetKey(\"a\") &#123; Debug.Log(\"A键被按下了\"); &#125; if (Input.GetKeyDown(KeyCode.Q))//或者Input.GetKeyDown(\"q\") &#123; Debug.Log(\"Q键被按下了\"); &#125; if (Input.GetKeyUp(KeyCode.W))//或者Input.GetKeyUp(\"w\") &#123; Debug.Log(\"W键被放开了\"); &#125; &#125;&#125; 播放游戏，当我们按A键时，每一帧控制台都会识别A键被按下然后打印信息，按住A键则控制台持续打印消息；当我们按下Q键时，只在按下的那一帧识别并只打印一次消息，即按一次打印一次。按住W键，只有在松开时控制台才打印消息。 三、获取鼠标事件使用的API： Input.GetMouseButtonDown，当按键按下； Input.GetMouseButtonUp，当按键抬起； Input.GetMouseButton，当按键被持续按下。 参数：0代表左键，1代表右键，2代表中键 鼠标位置获取：Input.mousePosition 适用范围：鼠标事件使用范围较广，比如左键点击地面，让角色移动过去，右键敌人发动攻击等。 例子编辑Test.cs如下： 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class Test : MonoBehaviour&#123; // Update is called once per frame void Update() &#123; GameObject Capsule = GameObject.Find(\"Capsule\"); if (Input.GetMouseButtonDown(0)) &#123; Capsule.transform.localScale = new Vector3(2, 2, 2); &#125; if (Input.GetMouseButtonUp(1)) &#123; Capsule.transform.localScale = new Vector3(1, 1, 1); &#125; if (Input.GetMouseButton(2)) &#123; Capsule.transform.localScale += new Vector3(0.5f, 0.5f, 0.5f); &#125; &#125;&#125; 播放游戏，当我们按下鼠标左键时，Capsule体积变为为2倍，当我们按住鼠标右键，松开时Capsule体积变为的1倍，当我们按住鼠标中键时，Capsule的体积持续放大。 我们将Capsule删掉，在将场景视图变为2D，在场景中新建一个Image，Test.cs添加到Main Camera上，编辑Test.cs如下： 12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;public class Test : MonoBehaviour&#123; bool isDown = false; // Update is called once per frame void Update() &#123; if (Input.GetMouseButtonDown(0)) &#123; isDown = true; &#125; if (Input.GetMouseButtonUp(0)) &#123; isDown = false; &#125; if (isDown) &#123; GameObject image = GameObject.Find(\"Image\"); image.transform.position = Input.mousePosition; &#125; &#125;&#125; 播放游戏，当鼠标按住左键，Image会跳变到鼠标所在位置，移动鼠标，Image跟随移动，松开鼠标左键，Image停止跟随。 四、移动设备输入使用的API： Input.touchCount，最后一帧有多少根手指触碰到了，不同设备能追踪到的数量不同，iPhone一般最多支持五根手指。 Input.touches存储每根手指状态的数组，可以通过索引来访问每根手指的一些信息。常用信息有： fingerid：触碰的唯一索引 position：这根手指当前所在的屏幕位置 deltaPosition：自上一帧以来，这根手指屏幕位置变化 例子编辑Test.cs如下： 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Test : MonoBehaviour&#123; Text text; void Start() &#123; text = GameObject.Find(\"Text\").GetComponent&lt;Text&gt;(); &#125; // Update is called once per frame void Update() &#123; if(Input.touchCount &gt; 1) &#123; text.text = \"当前有：\" + Input.touchCount + \"根手指触碰\" + Input.touches[0].fingerId + \"当前手指所在的位置是：\" + Input.touches[0].position + \"上一帧到当前帧的变化\" + Input.touches[0].deltaPosition; &#125; &#125;&#125; 打包成apk，","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"基于MVC的UI框架","slug":"基于MVC的UI框架","date":"2020-04-22T03:01:11.000Z","updated":"2020-04-22T08:31:37.721Z","comments":true,"path":"2020/04/22/基于MVC的UI框架/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/22/%E5%9F%BA%E4%BA%8EMVC%E7%9A%84UI%E6%A1%86%E6%9E%B6/","excerpt":"MVC","text":"MVC MVC框架介绍Mode数据模型目的：记录游戏模块相关数据。 比如：账号、密码、角色、ID、所在帮派、攻击力、防御力、穿透、暴击、商城出售的道具信息（名称、价格、使用说明…） 这些数据是可以在多个模块中进行使用的，比如角色信息，是可以用于好友模块、房间模块、战斗模块等 如果不进行复用的话，需要拷贝很多份，维护起来非常麻烦。 代码怎么写？ 建议使用单例模式 其他的没什么，只是约束了这个脚本里只保存数据，不做逻辑 但是，人是活的，有时候可以写一些对数据结构进行操作的接口，给控制器进行调用。 比如战斗模块，通常我们会在本地缓存十个玩家的信息。 提供存储、修改、查询、删除、清理的接口。 放到控制器去写也没问题，如果要在多个地方使用重复的代码，就需要在数据类中封装接口 View视图Controller控制器什么是模块？MVC带来的好处创建Model数据模型View视图设计介绍定义每个窗体用到的变量和方法画布与UI层级的设计编写窗体对外的接口编写窗体管理类视图窗体的测试与bug修复模块控制器总结","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"剑指Offer第2章基础知识笔记","slug":"剑指Offer第2章基础知识笔记","date":"2020-04-16T13:34:57.000Z","updated":"2020-04-21T10:01:14.390Z","comments":true,"path":"2020/04/16/剑指Offer第2章基础知识笔记/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/16/%E5%89%91%E6%8C%87Offer%E7%AC%AC2%E7%AB%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/","excerpt":"编程语言（C++） 数据结构（数组、字符串、链表、树、栈、队列） 算法和数据操作（查找、排序、递归、循环、位运算）","text":"编程语言（C++） 数据结构（数组、字符串、链表、树、栈、队列） 算法和数据操作（查找、排序、递归、循环、位运算） 1. 编程语言（C++）2. 数据结构2.1 数组2.2 字符串2.3 链表2.4 树2.5 栈2.6 队列3. 算法和数据操作排序和査找是面试时考查算法的重点。在准备面试的时候，我们应该重点掌握二分査找、归并排序和快速排序，做到能随时正确、完整地写出它们的代码。 有很多算法都可以用递归和循环两种不同的方式实现。通常基于递归的实现方法代码会比较简洁，但性能不如基于循环的实现方法。在面试的时候，我们可以根据题目的特点，甚至可以和面试官讨论选择合适的方法编程。 位运算可以看成是一类特殊的算法，它是把数字表示成二进制之后对0和1的操作。由于位运算的对象为二进制数字，所以不是很直观，但掌握它也不难，因为总共只有与、或、异或、左移和右移5种位运算。 查找顺序査找、二分査找、哈希表査找和二叉排序树查找 在面试的时候，不管是用循环还是用递归，面试官都期待应聘者能够信手拈来写出完整正确的二分査找代码，否则可能连继续面试的兴趣都没有。 面试题8“旋转数组的最小数字”和面试题38 “数字在排序数组中出现的次数”都可以用二分査找算法解决。 如果面试题是要求在排序的数组（或者部分摊序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分査找算法。 排序递归循环位运算","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://weimingjuncn.github.io/tags/C/"}]},{"title":"C#网络编程","slug":"C Sharp网络编程","date":"2020-04-14T03:14:59.000Z","updated":"2020-04-21T12:13:09.604Z","comments":true,"path":"2020/04/14/C Sharp网络编程/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/14/C%20Sharp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"Socket-TCP、Socket-UDP、Http、实现文件下载的功能","text":"Socket-TCP、Socket-UDP、Http、实现文件下载的功能 目标：访问网络共享资源、实现玩家之间的交互 技术点应用：软件、游戏、网站、App、… 程序之间如何通信：通过IP找到通信的主机、通过Port找到主机上的程序 Socket-TCP服务器创建TcpListener实例x： TcpListener.Create(port); 指定监听的端口 启动服务器： x.Start(); 例子用VS2017创建控制台应用项目Server，添加类TCPServer。TCPServer.cs内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Collections.Generic;using System.Linq;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Server&#123; class TCPServer &#123; //启动服务器的接口 TcpListener tcpListener; public void Start() &#123; try &#123; //构建Socket网络通信 //它是对Socket更上一层的封装 //端口1-65535 每个程序的端口不能相同 //在控制台输入指令：netstat -ano可以查看所有使用中的端口 tcpListener = TcpListener.Create(7788); tcpListener.Start(500); Console.WriteLine(\"启动服务器成功！\"); //Accept方法进行监听来自客户端的连接 Accept(); &#125;catch(Exception error) &#123; Console.WriteLine(error); &#125; &#125; //监听客户端的接口 private async void Accept() &#123; try &#123; TcpClient tcpClient = await tcpListener.AcceptTcpClientAsync(); //访问 Console.WriteLine(\"客户端已连接：\" + tcpClient.Client.RemoteEndPoint); Accept(); &#125; catch (Exception error) &#123; Console.WriteLine(error); tcpListener.Stop();//停止服务器工作 &#125; &#125; &#125;&#125; Program.cs内容如下： 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;/// &lt;summary&gt;/// 服务器-TCP/// &lt;/summary&gt;namespace Server&#123; class Program &#123; static void Main(string[] args) &#123; TCPServer server = new TCPServer(); server.Start(); while (true) &#123; //让程序阻塞在这里 Console.ReadLine(); &#125; &#125; &#125;&#125; 程序运行后将在控制台打印“启动服务器成功！” 客户端例子用VS2017创建控制台应用项目Client，添加类Client。Client.cs内容如下： 123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.Linq;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Client&#123; class Client &#123; TcpClient client; //启动 public void Start() &#123; client = new TcpClient(); Connect(); //连接的端口：7788 &#125; //连接服务器 async void Connect() &#123; try &#123; await client.ConnectAsync(\"127.0.0.1\", 7788); Console.WriteLine(\"连接成功！\"); &#125; catch (Exception error) &#123; Console.WriteLine(error.Message); &#125; &#125; //监听服务器消息 //发送消息给服务器 &#125;&#125; Progam.cs内容如下： 1234567891011121314151617181920212223using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;/// &lt;summary&gt;/// 客户端-TCP/// &lt;/summary&gt;namespace Client&#123; class Program &#123; static void Main(string[] args) &#123; Client client = new Client(); client.Start(); while (true) &#123; Console.ReadLine(); &#125; &#125; &#125;&#125; 先运行上一个TCP服务器例子程序，然后运行TCP客户端例子程序，客户端控制台打印“连接成功！”，服务器控制台打印： 启动服务器成功！客户端已连接：[::ffff:127.0.0.1]:60056 服务器与客户端相互发送、接收消息例子作为服务器的Server项目Program.cs123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;/// &lt;summary&gt;/// 服务器-TCP/// &lt;/summary&gt;namespace Server&#123; class Program &#123; static void Main(string[] args) &#123; TCPServer server = new TCPServer(); server.Start(); while (true) &#123; //让程序阻塞在这里 string text = Console.ReadLine(); server.tempClient.Send(Encoding.UTF8.GetBytes(text)); &#125; &#125; &#125;&#125; TCPServer.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System;using System.Collections.Generic;using System.Linq;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Server&#123; class TCPServer &#123; //启动服务器的接口 TcpListener tcpListener; public void Start() &#123; try &#123; //构建Socket网络通信 //它是对Socket更上一层的封装 //端口1-65535 每个程序的端口不能相同 //在控制台输入指令：netstat -ano可以查看所有使用中的端口 tcpListener = TcpListener.Create(7788); tcpListener.Start(500); Console.WriteLine(\"启动服务器成功！\"); //Accept方法进行监听来自客户端的连接 Accept(); &#125;catch(Exception error) &#123; Console.WriteLine(error); &#125; &#125; public Agent tempClient; //监听客户端的接口 private async void Accept() &#123; try &#123; TcpClient tcpClient = await tcpListener.AcceptTcpClientAsync(); //访问连接的客户端的远程IP和端口 //IPv6的格式，IPv4没有ffff:这样的前缀 Console.WriteLine(\"客户端已连接：\" + tcpClient.Client.RemoteEndPoint); //tcpClient代表与客户端的连接，通过它可以给客户端发送消息或接收客户端的消息。 //1对多，构建每一个玩家的数据模型，在它内部去模拟每个玩家的行为。 Agent agent = new Agent(tcpClient); tempClient = agent; Accept(); &#125; catch (Exception error) &#123; Console.WriteLine(error); tcpListener.Stop();//停止服务器工作 &#125; &#125; &#125;&#125; Agent.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980using System;using System.Collections.Generic;using System.Linq;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Server&#123; class Agent &#123; TcpClient client; public Agent(TcpClient tcpClient) &#123; client = tcpClient; //接收来自客户端的消息 Recieve(); &#125; void Input() &#123; Console.ReadLine(); &#125; /// &lt;summary&gt; /// 接收来自客户端的消息 /// &lt;/summary&gt; private async void Recieve() &#123; //while循环进行持续的接收 //条件是这个Socket处于连接状态 //从流中读取数据 while (client.Connected) &#123; try &#123; //缓存接收到的数据 byte[] byte[] buffer = new byte[4096]; int length = await client.GetStream().ReadAsync(buffer,0,buffer.Length); //将字节数组转化为字符串 Console.WriteLine(Encoding.UTF8.GetString(buffer, 0, length)); &#125; catch (Exception error) &#123; Console.WriteLine(error.Message); client.Close(); &#125; &#125; &#125; /// &lt;summary&gt; /// 发送消息给客户端 /// &lt;/summary&gt; /// &lt;param name=\"data\"&gt;&lt;/param&gt; public async void Send(byte[] data) &#123; //客户端处于连接状态才能发送消息 if (client.Connected) &#123; //使用try catch方式来捕捉发送的时候可能出现的异常 try &#123; //networkStream，向这个网络流，异步地写入数据=发送消息给服务器 await client.GetStream().WriteAsync(data, 0, data.Length); Console.WriteLine(\"发送成功！\"); &#125; catch (Exception error) &#123; //打印异常消息，关闭客户端与服务器的连接 client.Close(); Console.WriteLine(error.Message); &#125; &#125; &#125; &#125;&#125; 作为客户端的Client项目Program.cs123456789101112131415161718192021222324using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;/// &lt;summary&gt;/// 客户端-TCP/// &lt;/summary&gt;namespace Client&#123; class Program &#123; static void Main(string[] args) &#123; Client client = new Client(); client.Start(); while (true) &#123; string input = Console.ReadLine(); client.Send(Encoding.UTF8.GetBytes(input)); &#125; &#125; &#125;&#125; Client.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System;using System.Collections.Generic;using System.Linq;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Client&#123; class Client &#123; TcpClient client; //启动 public void Start() &#123; client = new TcpClient(); Connect(); //连接的端口：7788 &#125; //连接服务器 async void Connect() &#123; try &#123; await client.ConnectAsync(\"127.0.0.1\", 7788); Console.WriteLine(\"连接成功！\"); Recieve(); &#125; catch (Exception error) &#123; Console.WriteLine(error.Message); &#125; &#125; //监听服务器消息 //发送消息给服务器 public async void Send(byte[] data) &#123; //客户端处于连接状态才能发送消息 if (client.Connected) &#123; //使用try catch方式来捕捉发送的时候可能出现的异常 try &#123; //networkStream，向这个网络流，异步地写入数据=发送消息给服务器 await client.GetStream().WriteAsync(data, 0, data.Length); Console.WriteLine(\"发送成功！\"); &#125; catch (Exception error) &#123; //打印异常消息，关闭客户端与服务器的连接 client.Close(); Console.WriteLine(error.Message); &#125; &#125; &#125; /// &lt;summary&gt; /// 接收服务器发来的消息 /// &lt;/summary&gt; private async void Recieve() &#123; //while循环进行持续的接收 //条件是这个Socket处于连接状态 //从流中读取数据 while (client.Connected) &#123; try &#123; //缓存接收到的数据 byte[] byte[] buffer = new byte[4096]; int length = await client.GetStream().ReadAsync(buffer, 0, buffer.Length); //将字节数组转化为字符串 Console.WriteLine(Encoding.UTF8.GetString(buffer, 0, length)); &#125; catch (Exception error) &#123; Console.WriteLine(error.Message); client.Close(); &#125; &#125; &#125; &#125;&#125; 运行Server项目，服务端控制台打印消息“启动服务器成功！”。 运行Client项目，客户端控制台打印消息“连接成功！”，服务端控制台打印消息“客户端已连接…”。 在客户端输入消息后回车，服务端接收到消息并打印。 在服务端输入消息后回车，客户端端接收到消息并打印。 Socket-UDP相对TCP而言，UDP不需要建立连接。 TCP在建立连接后，每次未来数据的准确到达，都会进行发送和接收的确认。 服务器构建UdpClient对象x，构建的时候绑定端口 提供异步接收的接口，RecieveAsync 提供异步发送的接口，SendAsync 项目：Project_Server Program.cs 123456789101112131415161718192021using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Server&#123; class Program &#123; static void Main(string[] args) &#123; UDPServer server = new UDPServer(); server.Start(); while (true) &#123; string text = Console.ReadLine(); &#125; &#125; &#125;&#125; UDPServer.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Collections.Generic;using System.Linq;using System.Net;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Project_Server&#123; class UDPServer &#123; UdpClient udpClient; public void Start() &#123; //1-65535 udpClient = new UdpClient(8899); Recieve(); &#125; IPEndPoint remote; /// &lt;summary&gt; /// 接收消息 /// &lt;/summary&gt; private async void Recieve() &#123; while (udpClient != null) &#123; try &#123; //接收客户端的消息 UdpReceiveResult result = await udpClient.ReceiveAsync(); remote = result.RemoteEndPoint; string text = Encoding.UTF8.GetString(result.Buffer); Console.WriteLine(\"接收到的数据：\" + text); &#125; catch (Exception error) &#123; Console.WriteLine(\"接收异常：\" + error.Message); udpClient.Close(); udpClient = null; &#125; &#125; &#125; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=\"data\"&gt;&lt;/param&gt; private void Send(byte[] data) &#123; &#125; &#125;&#125; 客户端构建UdpClient对象x，端口可以传递0，系统自动分配 提供异步接收的接口，RecieveAsync 提供异步发送的接口，SendAsync 项目名：Project_Client Program.cs 12345678910111213141516171819202122using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Client&#123; class Program &#123; static void Main(string[] args) &#123; Client client = new Client(); client.Start(); while (true) &#123; string text = Console.ReadLine(); client.Send(Encoding.UTF8.GetBytes(text)); &#125; &#125; &#125;&#125; Client.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using System.Collections.Generic;using System.Linq;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Project_Client&#123; class Client &#123; UdpClient udpClient; public void Start() &#123; //0表示由系统任意分配 udpClient = new UdpClient(0); &#125; public async void Send(byte[] data) &#123; if (udpClient != null) &#123; try &#123; int length = await udpClient.SendAsync(data, data.Length, \"127.0.0.1\", 8899); if (data.Length == length) &#123; Console.WriteLine(\"完整的发送！\"); &#125; &#125; catch (Exception error) &#123; Console.WriteLine(error.Message); udpClient.Close(); &#125; &#125; else &#123; udpClient.Close(); udpClient = null; &#125; &#125; &#125;&#125; 程序运行后在Project_Client的控制台窗口输入要发送的消息后回车，Project_Server的控制台窗口将打印接收到的消息，如下图： ![image-20200418223632262](D:\\blog\\source_posts\\C Sharp网络编程\\image-20200418223632262.png) 服务器与客户端相互发送、接收消息例子Project_ServerProgram.cs1234567891011121314151617181920212223using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Server&#123; class Program &#123; static void Main(string[] args) &#123; UDPServer server = new UDPServer(); server.Start(); Console.WriteLine(\"服务器已打开，请先接收客户端的消息\"); while (true) &#123; string text = Console.ReadLine(); server.Send(Encoding.UTF8.GetBytes(text)); &#125; &#125; &#125;&#125; UDPServer.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182using System;using System.Collections.Generic;using System.Linq;using System.Net;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Project_Server&#123; class UDPServer &#123; UdpClient udpClient; public void Start() &#123; //1-65535 udpClient = new UdpClient(8899); Recieve(); &#125; IPEndPoint remote; /// &lt;summary&gt; /// 接收消息 /// &lt;/summary&gt; private async void Recieve() &#123; while (udpClient != null) &#123; try &#123; //接收客户端的消息 UdpReceiveResult result = await udpClient.ReceiveAsync(); remote = result.RemoteEndPoint; string text = Encoding.UTF8.GetString(result.Buffer); Console.WriteLine(\"接收到的数据：\" + text); &#125; catch (Exception error) &#123; Console.WriteLine(\"接收异常：\" + error.Message); udpClient.Close(); udpClient = null; &#125; &#125; &#125; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=\"data\"&gt;&lt;/param&gt; public async void Send(byte[] data) &#123; if(udpClient != null) &#123; try &#123; //对客户端来讲，它肯定是知道服务器的IP和端口 //对服务器来说，它无法知道客户端的IP和端口 //使用UDP都需要客户端先发送消息过来，我们才可以获取到用户的IP和端口 //其实使用TCP也是一样 int length = await udpClient.SendAsync(data, data.Length,remote); if(length == data.Length) &#123; Console.WriteLine(\"完整地发送了数据\"); &#125; &#125; catch (Exception e) &#123; Console.WriteLine(\"发送了异常：\" + e.Message); udpClient.Close(); udpClient = null; &#125; &#125; else &#123; udpClient.Close(); udpClient = null; &#125; &#125; &#125;&#125; Project_ClientProgram.cs1234567891011121314151617181920212223using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Client&#123; class Program &#123; static void Main(string[] args) &#123; Client client = new Client(); client.Start(); Console.WriteLine(\"客户端已启动，现在开始发送消息吧\"); while (true) &#123; string text = Console.ReadLine(); client.Send(Encoding.UTF8.GetBytes(text)); &#125; &#125; &#125;&#125; Client.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using System;using System.Collections.Generic;using System.Linq;using System.Net.Sockets;using System.Text;using System.Threading.Tasks;namespace Project_Client&#123; class Client &#123; UdpClient udpClient; public void Start() &#123; //0表示由系统任意分配 udpClient = new UdpClient(0); Recieve(); &#125; public async void Send(byte[] data) &#123; if (udpClient != null) &#123; try &#123; int length = await udpClient.SendAsync(data, data.Length, \"127.0.0.1\", 8899); if (data.Length == length) &#123; Console.WriteLine(\"完整的发送！\"); &#125; &#125; catch (Exception error) &#123; Console.WriteLine(error.Message); udpClient.Close(); &#125; &#125; else &#123; udpClient.Close(); udpClient = null; &#125; &#125; public async void Recieve() &#123; while (udpClient != null) &#123; try &#123; UdpReceiveResult result = await udpClient.ReceiveAsync(); Console.WriteLine(Encoding.UTF8.GetString(result.Buffer)); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); udpClient.Close(); udpClient = null; &#125; &#125; &#125; &#125;&#125; 运行两个程序后，先在客户端向服务器发送一条消息，此时服务器接收到消息并获知了客户端的端口，此时可以从服务器控制台向客户端发送消息。 ![image-20200421201139889](D:\\blog\\source_posts\\C Sharp网络编程\\image-20200421201139889.png) Http客户端发起Get请求、服务器接收请求服务器响应客户端的Get请求客户端Post请求与服务器响应实现文件下载功能","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"核心C#","slug":"核心C Sharp","date":"2020-04-12T14:12:00.000Z","updated":"2020-06-15T08:41:52.421Z","comments":true,"path":"2020/04/12/核心C Sharp/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/12/%E6%A0%B8%E5%BF%83C%20Sharp/","excerpt":"声明变量、变量的初始化和作用域、C#的预定义数据类型、在C#程序中指定执行流、使用命名空间组织class和type、Main()方法、使用内部注释和文档编制功能、预处理器指令、C#编程的推荐规则和约定","text":"声明变量、变量的初始化和作用域、C#的预定义数据类型、在C#程序中指定执行流、使用命名空间组织class和type、Main()方法、使用内部注释和文档编制功能、预处理器指令、C#编程的推荐规则和约定 1. C#基础在C#中，语句以分号（;）结尾，用花括号（{}）把语句组合为块。单行注释以两个斜杠字符开头（//），多行注释以一个斜杠和一个星号（/*）开头，以一个斜杠和一个星号（/*）结尾。C#区分大小写，即myVar和MyVar是两个不同的变量。 示例： 1234567891011using System;namespace Wrox.HelloWorldApp&#123; class Program &#123; static void Main() &#123; Console.WriteLine(\"Hello, World!\"); &#125; &#125;&#125; 在示例中，前几行代码与命名空间有关（后文将提到），命名空间是把有相关类组合在一起的方式。namespace关键字声明了一个命名空间，关联其中的类。其后花括号中的左右代码都被认为是在这个命名空间中。编译器在using语句指定的命名空间中查找没有在当前命名空间中定义但在代码中引用的类。这类似于Java中的import语句和C++中的using namespace语句。 使用using指令的原因是要使用一个库类System.Console。using System语句允许把这个类简写为Console（System命名空间中其他类也如此）如果没有using，就必须完全限定对Console.WriteLine()方法的调用，如下所示： 1System.Console.WriteLine(\"Hello World!\"); 使用using static声明，不仅可以打开命名空间，还可以打开类的所有静态成员。声明using static System.Console，可以调用Console类的WriteLine方法，但不使用类名： 123using static System.Console;//...WriteLine(\"Hello World!\"); 标准的System命名空间包含了最常用的.NET类型。在C#中做的所有工作都依赖于.NET基类。C#没有用于输入和输出的内置关键字，而是完全依赖于.NET类。 在源代码中，声明一个类Program。但是，因为该类位于Wrox.HelloWorldApp命名空间中，所以其完整名称是Wrox.HelloWorldApp.Program。 所有C#代码都必须包含在类中。类的声明包括class关键字，其后是类名和一对花括号。与类相关的所有代码都应放在这对花括号中。 1234namespace Wrox.HelloWorldApp&#123; class Program &#123; Program类包含一个方法Main()。每个C#可执行文件（如控制台应用程序、Windows应用程序、Windows服务和Web应用程序）都必须有一个入口点——Main()方法（注意，M大写）。 12static void Main()&#123; 在程序启动时调用该方法。该方法要么没有返回值（void）要么返回一个整数（int）。注意，在C#中，方法定义如下： 1234[修饰符] 返回类型 方法名([参数])&#123; &#x2F;&#x2F;方法内容.&#125; 第一个方括号里的内容表示可选关键字。修饰符用于指定用户做定义的方法的某些特性，如可以在什么地方调用该方法。在本例中，Main()方法没有使用public访问修饰符，如果需要对Main()方法进行单元测试，可以给它使用public访问修饰符。运行库不需要使用public访问修饰符，仍可以调用方法。运行库没有创建类的实例，调用方法时，需要修饰符static。把返回类型设置为void，在本例中不包含任何参数。 最后看代码语句： 1Console.WriteLine(\"Hello World!\"); 在本例中，只调用了System.Console类的WriteLine()方法，把一行文本写到控制台窗口上。WriteLine()是一个静态方法，在调用之前不需要实例化Console对象。 2. 变量没有变量不可能写出重要的程序。 C#中使用下述语句声明变量： 1datatype identifier 2.1 初始化变量2.2 类型推断类型推断使用var关键字。声明变量的语法有些变化：使用var关键字替代实际的类型。编译器可以根据变量的初始化值“推断”变量的类型。例如： 1var someNumber = 0; 变成： 1int someNumber = 0; 即使someNumber没有声明int，编译器也可以确定，只要someNumber在其作用域内，就是int类型。编译后上边两个语句是等价的。下边是另一个小例子： 12345678910111213141516171819using System;namespace VariablesSample&#123; class Program &#123; static void Main() &#123; var name = \"Bugs Bunny\"; var age = 25; var isRabbit = true; Type nameType = name.GetType(); Type ageType = age.GetType(); Type isRabbitType = isRabbit.GetType(); Console.WriteLine($\"name is of type &#123;nameType&#125;\"); Console.WriteLine($\"age is of type &#123;ageType&#125;\"); Console.WriteLine($\"isRabbit is of type &#123;isRabbitType&#125;\"); &#125; &#125;&#125; 程序输出如下： 需要遵循以下规则： 变量必须初始化，否则，编译器没有推断变量类型的依据。 初始化器不能为空。 初始化器必须放在表达式中。 不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象。 声明了变量且推断出类型后，就不能再改变变量的类型了。变量的类型确定后，对该变量进行任何赋值时，其强类型化规则必须以推断出的类型为基础。 2.3 变量作用域变量的作用域是可以访问该变量的代码区域。一般情况下，确定作用域遵循以下规则: 只要类的局部变量在某个作用域内，其字段（也称为成员变量）也在该作用域内。 局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内。 在for、while或类似语句中声明的局部变量存在于该循环体内。 1. 局部变量的作用域冲突大型程序常常在不同部分为不同的变量使用相同的变量名。只要变量的作用域是程序的不同部分，就不会有问题，也不会产生多义性。但要注意，同名的局部变量不能在同一作用域内声明两次。例如，不能使用下面的代码： 123int x = 20;// some more codeint x = 30; 考虑以下代码示例： 1234567891011121314151617181920212223using System;namespace VariableScopeSample&#123; class Program &#123; private int j; static int Main() &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(i); &#125; // i goes out of scope here // We can declare a variable named i again, because // there's no other variable with that name in scope for (int i = 9; i &gt;= 0; i--) &#123; Console.WriteLine(i); &#125; // i goes out of scope here. return 0; &#125; &#125;&#125; 这段代码很简单，使用两个for循环打印09的数字，再逆序打印09的数字。重要的是在同一个方法中，代码中的变量i声明了两次。可以这么做的原因是i在两个相互独立的循环内部声明，所以每个变量i对于各自的循环来说是局部变量。 下面是另一个例子： 1234567891011121314151617using System;namespace VariableScopeSample2&#123; class Program &#123; static int Main(string[] args) &#123; int j = 20; for (int i = 0; i &lt; 10; i++) &#123; // int j = 30; // Can't do this — j is still in scope Console.WriteLine(j + i); &#125; return 0; &#125; &#125;&#125; 如果试图编译它，会产生如下错误： 12error CS0136: 无法在此范围中声明名为“j”的局部变量或参数，因为该名称在封闭局部范围中用于定义局部变量或参数 2. 字段和局部变量的作用域冲突2.4 常量顾名思义，常量是其值在使用过程（生命周期）中不会发生变化的变量。在声明和初始化变量时，在变量的 前面加上关键字const,就可以把该变量指定为一个常量： 1const int a = 100; // This value cannot be changed. 常量具有如下特点： ‘ 常量必须在声明时初始化。指定了其值后，就不能再改写了。 常量的值必须能在编译时用于计算。因此，不能用从变量中提取的值来初始化常量。如果需要这么做,应使用只读字段。 常量总是隐式静态的。但注意，不必（实际上，是不允许）在常量声明中包含修饰符static。在程序中使用常量至少有3个好处： 由于使用易于读取的名称（名称的值易于理解）替代了较难读取的数字和字符串，常量使程序变得更易于阅读。 常量使程序更易于修改。例如，在C#程序中有一个SalesTax常量，该常量的值为6%。如果以后销售税率发生变化，把新值赋给这个常量，就可以修改所有的税款计算结果，而不必査找整个程序去修改税率为0.06的每个项。 常量更容易避免程序出现错误。如果在声明常量的位置以外的某个地方将另一个值赋给常量，编译器就会标记错误。 3. 预定义数据类型3.1 值类型和引用类型3.2 .NET类型3.3 预定义的值类型3.4 预定义的引用类型4. 程序流控制5. 命名空间6. Main()方法7. 使用注释8. C#预处理器指令9. C#编程准则10. 总结","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"用Unity 2019制作俄罗斯方块","slug":"用Unity 2019制作俄罗斯方块","date":"2020-04-09T13:26:00.000Z","updated":"2020-04-09T13:34:13.525Z","comments":true,"path":"2020/04/09/用Unity 2019制作俄罗斯方块/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/09/%E7%94%A8Unity%202019%E5%88%B6%E4%BD%9C%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/","excerpt":"版本：Unity 2019.3.4f1 Personal","text":"版本：Unity 2019.3.4f1 Personal 脚本GameManager.cs内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379using DG.Tweening;using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class GameManager : MonoBehaviour&#123; enum GameState &#123; Start, Stop &#125; GameState gameState = GameState.Stop; public Button startGame;//开始游戏按钮 public Button stopGame;//停止游戏按钮 public Transform MaxPosx;//方块X轴可移动的最小位置，相当于地图边界 public Transform MinPosx;//X轴最小 public Transform MaxPosy;//Y轴最大 public Transform MinPosy;//Y轴最小 public Transform[,] map = new Transform[11, 15];//二维数组，方块信息存储起来 public GameObject[] shapes = new GameObject[7];//7种不同的形状 public Sprite[] sprites = new Sprite[7];//七种颜色的方块 public Sprite[] levelSprite = new Sprite[5]; Transform currentShape;//当前形状 Transform nextShape;//下一个形状 private Transform preview;//预览形状的父物体 private int level = 1;//等级 private int score = 0;//分数 private float initSpeed = 0.8f;//初始每次下降的时间 private Transform shapePool;//方块的父物体 public float spacing;//两个方块的间距 private Transform gameOver;//游戏结束图片 private Image levelImage; private Text scoreText;//分数文本 private Text upgradeScoreText;//升级分数文本 private AudioSource audioSource;//音频源组件 public AudioClip[] audioClips;//音频剪辑的数组 // Start is called before the first frame update void Start() &#123; preview = GameObject.Find(\"Preview\").transform; spacing = Mathf.Abs(GameObject.Find(\"Row/Block (1)\").transform.position.x - GameObject.Find(\"Row/Block (2)\").transform.position.x); shapePool = GameObject.Find(\"ShapePool\").transform; levelImage = GameObject.Find(\"Level\").GetComponent&lt;Image&gt;(); gameOver = transform.Find(\"GameOver\"); scoreText = GameObject.Find(\"ScoreText\").GetComponent&lt;Text&gt;(); upgradeScoreText = GameObject.Find(\"UpgradeScoreText\").GetComponent&lt;Text&gt;(); audioSource = transform.GetComponent&lt;AudioSource&gt;(); startGame.onClick.AddListener(StartGame); stopGame.onClick.AddListener(StopGame); &#125; /// &lt;summary&gt; /// 停止游戏 /// &lt;/summary&gt; private void StopGame() &#123; if(gameState == GameState.Start) &#123; gameState = GameState.Stop; if(currentShape != null) &#123;//当前形状和下一块的形状不为空就销毁，等待下一局开始重新分配 Destroy(currentShape.gameObject); &#125; if(nextShape != null) &#123; Destroy(nextShape.gameObject); &#125; for(int i = 0; i &lt; shapePool.childCount; i++) &#123; Destroy(shapePool.GetChild(i).gameObject); &#125; for(int i = 0; i &lt; map.GetLength(0); i++) &#123; for(int j = 0; j &lt; map.GetLength(1); j++) &#123; map[i, j] = null; &#125; &#125; &#125; //重置等级和积分 level = 1; score = 0; scoreText.text = \"当前积分：0\"; upgradeScoreText.text = \"升级积分：100\"; levelImage.sprite = levelSprite[0]; //显示游戏结束的画面 StartCoroutine(OpenGameOver()); &#125; /// &lt;summary&gt; /// 开始游戏 /// &lt;/summary&gt; private void StartGame() &#123; if(gameState == GameState.Stop) &#123; level = 1; score = 0; scoreText.text = \"当前积分：0\"; upgradeScoreText.text = \"升级积分：100\"; gameState = GameState.Start; gameOver.gameObject.SetActive(false); //游戏开始时候的初始化工作 //生成不同形状的方块，开始游戏需要播放音频 SpawnShape();//生成形状 PlayAudio(3);//播放声音 &#125; &#125; /// &lt;summary&gt; /// 消除方块 /// &lt;/summary&gt; /// &lt;param name=\"rowIndex\"&gt;&lt;/param&gt; private void ClearShape(List&lt;int&gt; rowIndex) &#123; bool isMove = true; for(int i = 0; i &lt; rowIndex.Count; i++) &#123; for(int j = 0; j &lt; map.GetLength(0); j++) &#123; if(map[j, rowIndex[i]] != null) &#123; //对每个需要消除的格子进行消除 Transform block = map[j, rowIndex[i]]; map[j, rowIndex[i]] = null; block.GetComponent&lt;Image&gt;().DOFade(0, 0.2f) .SetLoops(4) .SetEase(Ease.Linear) .OnComplete(() =&gt; &#123; Destroy(block.gameObject); if (isMove) &#123; isMove = false; MoveLines(rowIndex); &#125; &#125;); &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 消除后移动剩余方块的方法，让他们到达应该在的位置 /// &lt;/summary&gt; /// &lt;param name=\"rowIndex\"&gt;&lt;/param&gt; private void MoveLines(List&lt;int&gt; rowIndex) &#123; for(int i = rowIndex[0];i &lt; map.GetLength(1) ; i++) &#123; for(int j= 0;j &lt; map.GetLength(0); j++) &#123; if(map[j,i] != null) &#123; int dropRow = GetDropRow(rowIndex,i); map[j, i - dropRow] = map[j, i];//将当前这个格子的数据存到要下降的那个格子去 map[j, i] = null; map[j, i - dropRow].position -= new Vector3(0, dropRow * spacing, 0); &#125; &#125; &#125; CheckGameState(); &#125; /// &lt;summary&gt; /// 获取要消除多少行 /// &lt;/summary&gt; /// &lt;param name=\"rowIndex\"&gt;&lt;/param&gt; /// &lt;param name=\"currentRow\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private int GetDropRow(List&lt;int&gt; rowIndex,int currentRow) &#123; int dropRow = 0; for(int i = 0; i &lt; rowIndex.Count; i++) &#123; if(currentRow &gt; rowIndex[i]) &#123; dropRow++; &#125; &#125; return dropRow; &#125; /// &lt;summary&gt; /// 检测游戏是否结束 /// &lt;/summary&gt; private void CheckGameState() &#123; for(int i = 0; i &lt; map.GetLength(0); i++) &#123; if(map[i, map.GetLength(1)-1]!= null) &#123; StopGame(); break; &#125; &#125; if(gameState == GameState.Start) &#123; SpawnShape(); &#125; &#125; /// &lt;summary&gt; /// 保存地图数据，方块不能掉落后就保存进来 /// &lt;/summary&gt; /// &lt;param name=\"shape\"&gt;&lt;/param&gt; public void SaveShape(Transform shape) &#123; //保存地图数据 for(int i = 0; i &lt; shape.childCount; i++) &#123; if (!shape.GetChild(i).CompareTag(\"ShapePivot\")) &#123; Vector3 childPos = shape.GetChild(i).position; int xIndex = (int)((childPos.x - MinPosx.position.x) / spacing); int yIndex = (int)((childPos.y - MinPosy.position.y) / spacing); //求出再地图内对应的格子 if(yIndex &lt; map.GetLength(1)) &#123; map[xIndex, yIndex] = shape.GetChild(i); &#125; else &#123; StopGame(); return; //游戏结束 &#125; &#125; &#125; //检查是否需要消除 CheckClear(); &#125; /// &lt;summary&gt; /// 方块消除检测 /// &lt;/summary&gt; public void CheckClear() &#123; //检查是否有需要消除的方块 List&lt;int&gt; rowIndex = new List&lt;int&gt;(); for (int i = 0; i &lt; map.GetLength(1); i++) &#123; bool isClear = true; for(int j = 0; j &lt; map.GetLength(0); j++) &#123; if(map[j, i] == null) &#123; isClear = false; break; &#125; &#125; if (isClear) &#123; rowIndex.Add(i); &#125; &#125; if (rowIndex.Count &gt;= 1) &#123; ClearShape(rowIndex);//调用消除的方法 //积分增长与升级 score += rowIndex.Count * 10;//每消除一行加10分 if(score &gt; level * 100 &amp;&amp; level &lt; 5) &#123; level += 1; levelImage.sprite = levelSprite[level - 1]; if(level &lt; 5) &#123; upgradeScoreText.text = \"升级积分：\" + level * 100; &#125; else &#123; upgradeScoreText.text = \"已经满级\"; &#125; &#125; scoreText.text = \"当前积分：\" + score; //播放消除的音效 PlayAudio(1);//播放声音 &#125; else &#123;//如果不需要消除，那么需要判断游戏是否结束，如果没有结束就要生成新的可控制方块 CheckGameState(); &#125; &#125; /// &lt;summary&gt; /// 判断方块的位置是否合法，首先是否超出地图边界，然后判断是否有和其他方块重叠 /// &lt;/summary&gt; /// &lt;param name=\"shape\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool CheckPos(Transform shape) &#123; for(int i = 0; i &lt; shape.childCount; i++) &#123; if (shape.GetChild(i).CompareTag(\"ShapePivot\") == false) &#123; Vector3 childPos = shape.GetChild(i).position; if(childPos.x &lt; MinPosx.position.x || childPos.x &gt; MaxPosx.position.x || childPos.y &lt; MinPosy.position.y) // || childPos.y &gt; MaxPosy.position.y) &#123; return false; &#125; int xIndex = (int)((childPos.x - MinPosx.position.x) / spacing); int yIndex = (int)((childPos.y - MinPosy.position.y) / spacing); Debug.Log(\"对应的索引是：\" + xIndex + \"Y的索引\" + yIndex); if(yIndex &lt; map.GetLength(1)) &#123;//Y轴小于地图边界的时候再来计算它是否有重叠 if(map[xIndex, yIndex] != null) &#123; return false; &#125; &#125; &#125; &#125; return true; &#125; /// &lt;summary&gt; /// 生成方块的方法 /// &lt;/summary&gt; public void SpawnShape() &#123; if(gameState == GameState.Stop) &#123; return; &#125; int shapeIndex;//形状的索引 int colorIndex;//颜色的索引 if(nextShape == null) &#123;//游戏刚开始的时候，下一个形状会为空 //先随机生成颜色和形状的索引 shapeIndex = UnityEngine.Random.Range(0, shapes.Length); colorIndex = UnityEngine.Random.Range(0, sprites.Length); //克隆出随机到的形状和赋予对应的颜色 currentShape = GameObject.Instantiate(shapes[shapeIndex]).transform; for(int i = 0; i &lt; currentShape.childCount; i++) &#123; if (!currentShape.GetChild(i).CompareTag(\"ShapePivot\")) &#123; currentShape.GetChild(i).GetComponent&lt;Image&gt;().sprite = sprites[colorIndex]; &#125; &#125; &#125; else &#123; currentShape = nextShape; &#125; currentShape.gameObject.AddComponent&lt;ShapeControl&gt;().Init(initSpeed - level/10f, spacing); shapeIndex = UnityEngine.Random.Range(0, shapes.Length); colorIndex = UnityEngine.Random.Range(0, sprites.Length); nextShape = GameObject.Instantiate(shapes[shapeIndex]).transform; for (int i = 0; i &lt; currentShape.childCount; i++) &#123; if (!currentShape.GetChild(i).CompareTag(\"ShapePivot\")) &#123; currentShape.GetChild(i).GetComponent&lt;Image&gt;().sprite = sprites[colorIndex]; &#125; &#125; nextShape.SetParent(preview); nextShape.localPosition = Vector3.zero; &#125; /// &lt;summary&gt; /// 开启游戏结束的图片，1秒后自动关闭 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private IEnumerator OpenGameOver() &#123; gameOver.gameObject.SetActive(true); yield return new WaitForSeconds(1); gameOver.gameObject.SetActive(false); &#125; /// &lt;summary&gt; /// 播放音效 /// &lt;/summary&gt; /// &lt;param name=\"index\"&gt;&lt;/param&gt; public void PlayAudio(int index) &#123; audioSource.clip = audioClips[index]; audioSource.Play(); &#125;&#125; ShapeControl.cs内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119using System.Collections;using System.Collections.Generic;using UnityEngine;public class ShapeControl : MonoBehaviour&#123; float speed; //下降速度，值越低下降越快 float spacing;//间距，每次下降移动的值 float mTimer;//计时 GameManager gameManager; Transform mPivot;//方块旋转的中心 bool isStopDown = false; public void Init(float speed,float spacing) &#123; //初始化设置物体生成的位置和给一些变量赋值 gameManager = GameObject.Find(\"BG\").GetComponent&lt;GameManager&gt;(); transform.SetParent(GameObject.Find(\"ShapePool\").transform); if(gameObject.name.Contains(\"Shape (3)\")) &#123; transform.localPosition = new Vector2(-spacing / 2, 0); &#125; else &#123; transform.localPosition = Vector3.zero; &#125; this.speed = speed; this.spacing = spacing; mPivot = transform.Find(\"Pivot\"); &#125; // Update is called once per frame void Update() &#123; if (isStopDown) &#123; return; &#125; mTimer += Time.deltaTime; if(mTimer &gt;= speed) &#123; mTimer = 0; //时间到了，方块向下移动一格 SetPositionOrRotate(new Vector3(0, -spacing, 0), 0); &#125; if (Input.GetKeyDown(KeyCode.LeftArrow)) &#123; //按下左方向键，控制方块向左移动一格 SetPositionOrRotate(new Vector3(-spacing, 0, 0), 0); &#125; if (Input.GetKeyDown(KeyCode.RightArrow)) &#123; //按下右方向键，控制方块向右移动一格 SetPositionOrRotate(new Vector3(spacing, 0, 0), 0); &#125; if (Input.GetKeyDown(KeyCode.UpArrow)) &#123; //按上方向键，旋转方块 SetPositionOrRotate(new Vector3(0, 0, 0), 90); &#125; if (Input.GetKeyDown(KeyCode.DownArrow)) &#123; //按下向下方向键，加快移动速度 speed = speed / 2; &#125; &#125; /// &lt;summary&gt; /// 设置这个形状的位置或者形状 /// &lt;/summary&gt; /// &lt;param name=\"pos\"&gt;移动位置&lt;/param&gt; /// &lt;param name=\"rotate\"&gt;旋转角度&lt;/param&gt; private void SetPositionOrRotate(Vector3 pos,float rotate) &#123; if(isStopDown) &#123; return; &#125; if(pos != Vector3.zero) &#123; transform.position += pos; Debug.Log(transform.position); if (gameManager.CheckPos(transform) == false) &#123; transform.position -= pos; if(pos.y != 0) &#123; isStopDown = true; gameManager.SaveShape(transform); Debug.Log(\"删除了脚本\"); Destroy(this);//删除自身这个脚本组件，不再接受控制了 &#125; &#125; else &#123; //如果移动合法，根据左右移动或者向下移动播放不同的音效 if(pos.y != 0) &#123; gameManager.PlayAudio(0);//播放下落的音效 &#125; else &#123; gameManager.PlayAudio(2);//播放移动和旋转的音效 &#125; &#125; &#125; if(rotate != 0) &#123; transform.RotateAround(mPivot.position,Vector3.forward, rotate); if(gameManager.CheckPos(transform) == false) &#123; transform.RotateAround(mPivot.position, Vector3.forward, -rotate); &#125; else &#123; gameManager.PlayAudio(2);//播放移动和旋转的音效 //播放声音 &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"C#与MySQL交互","slug":"C Sharp与MySql交互","date":"2020-04-06T05:20:00.000Z","updated":"2020-04-14T03:09:30.577Z","comments":true,"path":"2020/04/06/C Sharp与MySql交互/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/06/C%20Sharp%E4%B8%8EMySql%E4%BA%A4%E4%BA%92/","excerpt":"MySQL的基础使用 C#与MySQL的交互 实战：账号注册和登录的功能开发","text":"MySQL的基础使用 C#与MySQL的交互 实战：账号注册和登录的功能开发 为什么要学习MySQL及其应用？主要作用：集中管理网络游戏中所有玩家的数据与游戏中固定核心数据 数据库主要应用再网路游戏开发中 因为网络上有成百上千的玩家，如果把数据存储到每个玩家的本地，管理起来就有很大的风险，其一是玩家更换设备就意味着数据会丢失 如果把数据放在玩家本地，玩家就可以篡改数据，以达到作弊的目的 把数据存放在本地，不方便玩家之间的交互 与微软的SQLServer对比，MySQL更加轻量级，使用起来更加方便 官网：http://www.mysql.com/ 使用5.7版本，因为相对比较稳定 MySQL的基础使用安装MySQL 5.7.11.0和MySQL-Front以后将两者打开，我们主要在MySQL-Front（汉化界面）操作数据库。 打开MySQL-Front后选中127.0.0.1，右键选择新建|数据库 名称填game，其他默认，点击确定。 要删除数据库，只需右键game，点击删除即可。 我们选择game，右键选择新建|表格，在弹出的窗口中，名称填写user，点击确定创建一个表格 要删除表格，只需右键user，点击删除即可。 表格的Id字段在我们创建表格时自动创建了，我们再添加其他字段。选中表格user右键，选择新建|字段，名称填写account，类型设置“VarChar”，其他默认，点击确定。 添加字段“password”如下 点击数据浏览器，接下来进行添加数据 直接点击字段下的空白，然后输入数据，点击发布按钮即可 点击插入数据按钮，申请一行供插入数据，点击其右边的删除数据按钮删除一行数据。 点击SQL编辑器，然后通过SQL指令查询数据 C#与MySQL的交互添加数据连接数据库 定义SQL操作语句： 1insert to 表名（字段1，字段2，字段3，...）values（值1，值2，值3，...） 构建MySqlCommand，传递操作的sql语句和连接的实例 连接的实例需要先调用Open打开数据库 调用ExecuteNonQuery 例子用VS2017创建一个项目Project_MySQL，添加引用MySql.Data.dll 编辑Program.cs如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using MySql.Data.MySqlClient;namespace Project_MySQL&#123; class Program &#123; static void Main(string[] args) &#123; Insert(); &#125; private static MySqlConnection Connection() &#123; string sqlInfo = \"server=127.0.0.1;\" + \"port=3306;\" + \"database=game;\" + \"user=root;\" + \"password=12345\"; MySqlConnection mySqlConnection = new MySqlConnection(sqlInfo); return mySqlConnection; &#125; public static void Insert() &#123; MySqlConnection client = Connection();//连接数据库 //插入操作的sql语句 string addCmd = \"insert into user(Id,account,password) \" + \"value(1005,\\\"a777\\\",555555)\"; //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(addCmd, client); client.Open(); int result = mySqlCommand.ExecuteNonQuery(); if(result &gt; 0) &#123; Console.WriteLine(\"插入成功！\"); &#125; else &#123; Console.WriteLine(\"插入失败！\"); &#125; client.Close(); &#125; &#125;&#125; 程序运行后控制台打印“插入成功！” 在数据库里看到成功添加一行数据 修改数据1update 表名 set 字段名称1=新的值2, 字段名称2=新的值2, ... where 字段名称=值 and 字段名称=值 ... 要注意SQL操作语句中的条件是否能在数据库中找到相应的数据 例子修改Program.cs如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using MySql.Data.MySqlClient;namespace Project_MySQL&#123; class Program &#123; static void Main(string[] args) &#123; Update(); &#125; private static MySqlConnection Connection() &#123; string sqlInfo = \"server=127.0.0.1;\" + \"port=3306;\" + \"database=game;\" + \"user=root;\" + \"password=12345\"; MySqlConnection mySqlConnection = new MySqlConnection(sqlInfo); return mySqlConnection; &#125; public static void Update() &#123; MySqlConnection client = Connection();//连接数据库 //修改操作的sql语句 string addCmd = \"update user set password=333 where account=\\\"hongqigong\\\" \"; //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(addCmd, client); client.Open(); int result = mySqlCommand.ExecuteNonQuery(); if (result &gt; 0) &#123; Console.WriteLine(\"修改成功！\"); &#125; else &#123; Console.WriteLine(\"修改失败！\"); &#125; client.Close(); &#125; &#125;&#125; 运行程序后控制台打印消息“修改成功！”。 刷新数据库，表格里的数据也得到正确修改 删除数据1delete from 表的名称 条件语句 where 字段名称=值 and 字段名称=值 例子修改Program.cs如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using MySql.Data.MySqlClient;namespace Project_MySQL&#123; class Program &#123; static void Main(string[] args) &#123; Delete(); &#125; private static MySqlConnection Connection() &#123; string sqlInfo = \"server=127.0.0.1;\" + \"port=3306;\" + \"database=game;\" + \"user=root;\" + \"password=12345\"; MySqlConnection mySqlConnection = new MySqlConnection(sqlInfo); return mySqlConnection; &#125; /// &lt;summary&gt; /// 删除数据 /// &lt;/summary&gt; public static void Delete() &#123; MySqlConnection client = Connection();//连接数据库 //删除操作的sql语句 string addCmd = \"delete from user where account=\\\"hongqigong\\\" \"; //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(addCmd, client); client.Open(); int result = mySqlCommand.ExecuteNonQuery(); if (result &gt; 0) &#123; Console.WriteLine(\"删除成功！\"); &#125; else &#123; Console.WriteLine(\"删除失败！\"); &#125; client.Close(); &#125; &#125;&#125; 程序运行后，成功删除game数据库user表格中account为hongqigong的那一条数据。 查询数据1select *from 表名 条件 MySQLCommand构建的时候传递操作的sql语句，与连接的实例。 例子修改Program.cs如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using MySql.Data.MySqlClient;namespace Project_MySQL&#123; class Program &#123; static void Main(string[] args) &#123; Select(); &#125; private static MySqlConnection Connection() &#123; string sqlInfo = \"server=127.0.0.1;\" + \"port=3306;\" + \"database=game;\" + \"user=root;\" + \"password=12345\"; MySqlConnection mySqlConnection = new MySqlConnection(sqlInfo); return mySqlConnection; &#125;&#125; /// &lt;summary&gt; /// 查询数据 /// &lt;/summary&gt; public static void Select() &#123; string cmd = \"select *from user\"; MySqlConnection client = Connection();//连接数据库 //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(cmd, client); client.Open(); //执行读取 查询业务 返回的时查询到的数据 MySqlDataReader mySqlData = mySqlCommand.ExecuteReader(); //循环读取 mySqlData.Read内部 控制指针每次读取后往下一条数据进行移动 while (mySqlData.Read()) &#123; string account = mySqlData.GetString(\"account\"); int id = mySqlData.GetInt32(\"Id\"); int password = mySqlData.GetInt32(\"password\"); Console.WriteLine(id + \" \" + account + \" \" + password); &#125; Console.WriteLine(\"读取结束\"); mySqlData.Close(); client.Close(); &#125; &#125;&#125; 运行程序后，控制台打印当前从数据库表格里查询到所有数据。 实战：账号注册和登录的功能开发注册功能： 接收用户输入的账号和密码 判断数据库中是否已经存在相同的账号 如果没有就可以往内部添加 如果有，就提示用户账号已存在 登录功能： 接收用户输入的账号和密码 判断数据库中是否有匹配的记录 如果有，告知用户登录成功 如果没有，告知用户登录失败 修改Program.cs如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using MySql.Data.MySqlClient;namespace Project_MySQL&#123; class Program &#123; static void Main(string[] args) &#123; while (true) &#123; string account = \"\"; int pwd; Console.WriteLine(\"请输入，1：登录，2：注册\"); int cmd = int.Parse(Console.ReadLine()); if (cmd == 1) &#123; //登录 Console.WriteLine(\"请输入账号：\"); account = Console.ReadLine(); Console.WriteLine(\"请输入密码：\"); pwd = int.Parse(Console.ReadLine()); //数据库进行查询，如果存在匹配的记录，告诉用户登录成功 bool result = Select(\"where account = \\\"\" + account + \"\\\" and \" + \"password = \" + pwd); if (result == true) &#123; Console.WriteLine(\"登录成功\"); &#125; else &#123; Console.WriteLine(\"登录失败，请检查账号或者密码\"); &#125; &#125; else if (cmd == 2) &#123; //注册 Console.WriteLine(\"请输入账号：\"); account = Console.ReadLine(); Console.WriteLine(\"请输入密码：\"); pwd = int.Parse(Console.ReadLine()); //数据库进行查询，如果存在匹配的记录，告诉用户账户已存在 bool result = Select(String.Format(\"where account=\\\"&#123;0&#125;\\\"\", account)); if (result == true) &#123; Console.WriteLine(\"账户已存在，注册失败！\"); &#125; else &#123; //如果没有，插入数据。插入成功，通知用户，注册成功。 bool insertResult = Insert(account, pwd); if (insertResult) &#123; Console.WriteLine(\"注册成功！\"); &#125; else &#123; Console.WriteLine(\"注册失败，可能已被抢注\"); &#125; &#125; &#125; &#125; &#125; private static MySqlConnection Connection() &#123; string sqlInfo = \"server=127.0.0.1;\" + \"port=3306;\" + \"database=game;\" + \"user=root;\" + \"password=12345\"; MySqlConnection mySqlConnection = new MySqlConnection(sqlInfo); return mySqlConnection; &#125; /// &lt;summary&gt; /// 修改数据 /// &lt;/summary&gt; public static void Update() &#123; MySqlConnection client = Connection();//连接数据库 //修改操作的sql语句 string addCmd = \"update user set password=333 where account=\\\"hongqigong\\\" \"; //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(addCmd, client); client.Open(); int result = mySqlCommand.ExecuteNonQuery(); if (result &gt; 0) &#123; Console.WriteLine(\"修改成功！\"); &#125; else &#123; Console.WriteLine(\"修改失败！\"); &#125; client.Close(); &#125; /// &lt;summary&gt; /// 删除数据 /// &lt;/summary&gt; public static void Delete() &#123; MySqlConnection client = Connection();//连接数据库 //删除操作的sql语句 string addCmd = \"delete from user where account=\\\"hongqigong\\\" \"; //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(addCmd, client); client.Open(); int result = mySqlCommand.ExecuteNonQuery(); if (result &gt; 0) &#123; Console.WriteLine(\"删除成功！\"); &#125; else &#123; Console.WriteLine(\"删除失败！\"); &#125; client.Close(); &#125; /// &lt;summary&gt; /// 查询数据 /// &lt;/summary&gt; public static void Select() &#123; string cmd = \"select *from user\"; MySqlConnection client = Connection();//连接数据库 //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(cmd, client); client.Open(); //执行读取 查询业务 返回的时查询到的数据 MySqlDataReader mySqlData = mySqlCommand.ExecuteReader(); //循环读取 mySqlData.Read内部 控制指针每次读取后往下一条数据进行移动 while (mySqlData.Read()) &#123; string account = mySqlData.GetString(\"account\"); int id = mySqlData.GetInt32(\"Id\"); int password = mySqlData.GetInt32(\"password\"); Console.WriteLine(id + \" \" + account + \" \" + password); &#125; Console.WriteLine(\"读取结束\"); mySqlData.Close(); client.Close(); &#125; /// &lt;summary&gt; /// 查询账号和密码是否有匹配的记录 /// &lt;/summary&gt; /// &lt;param name=\"whereSQL\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool Select(string whereSQL) &#123; string cmd = \"select *from user \" + whereSQL; MySqlConnection client = Connection();//连接数据库 //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(cmd, client); client.Open(); //执行读取 查询业务 返回的时查询到的数据 MySqlDataReader mySqlData = mySqlCommand.ExecuteReader(); if (mySqlData.Read()) &#123; mySqlData.Close(); client.Close(); return true; &#125; else &#123; mySqlData.Close(); client.Close(); return false; &#125; &#125; int id = 1000; /// &lt;summary&gt; /// 添加数据 /// &lt;/summary&gt; /// &lt;param name=\"account\"&gt;&lt;/param&gt; /// &lt;param name=\"pwd\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool Insert(string account,int pwd) &#123; MySqlConnection client = Connection();//连接数据库 //插入操作的sql语句 string addCmd = string.Format(\"insert into user(account,password) \" + \"value(\\\"&#123;0&#125;\\\",&#123;1&#125;)\", account, pwd); //用于执行sql命令的对象 MySqlCommand mySqlCommand = new MySqlCommand(addCmd, client); client.Open(); int result = mySqlCommand.ExecuteNonQuery(); client.Close(); if (result &gt; 0) &#123; Console.WriteLine(\"插入成功！\"); return true; &#125; else &#123; Console.WriteLine(\"插入失败！\"); return false; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"UGUI图形交互系统","slug":"UGUI图形系统","date":"2020-04-04T05:47:00.000Z","updated":"2020-04-11T03:45:54.930Z","comments":true,"path":"2020/04/04/UGUI图形系统/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/04/UGUI%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/","excerpt":"Unity版本：Unity 2019.3.4f1","text":"Unity版本：Unity 2019.3.4f1 画布与事件系统画布用于承载所有UI元素在Hierarchy(层级窗口)空白处右键|UI|Canvas(画布)，创建一个画布，此时事件系统（EventSystem）也会自动被创建。 我们可以选中画布，创建子项——UI元素比如图片（UI | Image）、按钮(UI | Button)。 画布有三种模式选中画布，在检查器（Inspector窗口）|画布（Canvas）组件|渲染模式（Render Mode）进行设置。 屏幕空间 - 覆盖（Scream Space - Overlay） 屏幕空间 - 摄像机（Scream Space - Camera） 世界空间（World Space） 在Scream Space - Overlay模式下，所有UI元素都显示在画面最前端。 如果我们在画布上放一个Image，颜色设置为黄颜色，主摄像机前放一个白色的Cube。我们无论在场景窗口里怎么放置Cube，都无法挡住画布上的黄颜色Image。 当我们将渲染模式设置为Scream Space - Camera时，把Main Camera拖拽到Render Mode下方的Render Camera，设置Plane Distance为2。这时我们将Cube移动靠近摄像机，画布上的Image可以被Cube挡住。 屏幕空间 - 摄像机模式使用较少，适用于比如说在UI前边播放3D粒子效果。 当我们把渲染模式设置为World Space，画布可以随意移动和改变大小（前两个模式不可以），但只有出现在摄像机视野内才会被渲染到。适用于制作游戏中的敌人血条、立体互动广告牌等。 画布的缩放画布可以在Canvas Scaler（画布缩放器）组件下设定缩放模式以适配市面上的不同大小的手机屏幕。 设置UI Sale Mode（画布缩放模式）为Scale with Screen Size（屏幕大小调整）可以设置Reference Resolution（参考分辨率）。 事件系统事件系统（EventSystem）是用于处理各个UI控件交互，如果删除事件系统，或者把画布的Graphic Raycaster组件取消勾选，播放游戏，点击画面中的按钮将毫无反应。 图像、文本框、按钮、输入框的基本使用图像与文本框的主要作用是展示，按钮与输入框的主要作用是交互。 例子（山寨英雄联盟登录界面）接下来我们来制作一个英雄联盟登录界面。 将素材文件夹里UI文件夹拖拽导入到Unity编辑器的Assets文件夹下。 设置Scene视窗为2D模式，删除Canvas下的所有物体。 在Canvas下新建一个UI|Image，在其Rect Transform组件下设置Anchor Presets为strech-strech（按住Shift+Alt）。 选中UI/公用下的所有素材，在Inspector里设置Texture Type为Sprite(2D and UI)，点击Apply。 将BG01的Sprite拖拽到Image的Image组件|Source Image。 然后用给画布新添一个Image，重命名为BG，Source Image拖入“公用”文件夹下的Logo，点击Set Native Size(设置原生大小) 重命名为Logo，然后移动到背景左上角 在画布下新建一个UI|Panel（面板），默认和画布大小一致，重命名为UserPanel，将BG和Logo拖拽到UserPanel子项。 将“UI/用户模块”路径下所有素材设置Texture Type为Sprite(2D and UI)。 在UserPanel下新建一个Image，重命名为LoginBG，Source Image拖入“UI/用户模块“文件夹下的UserBack，并设置为原生大小。 在UserPanel下新建一个Image，重命名为Account，Source Image拖入“UI/用户模块“文件夹下的Account，并设置为原生大小。 通过快捷键Ctrl+D复制一个Account，重命名为PWD，Source Image拖入“UI/用户模块“文件夹下的PWD，并设置为原生大小。 在UserPanel下新建一个Image，重命名为Line，Source Image拖入“UI/用户模块“文件夹下的Line，并设置为原生大小。 通过快捷键Ctrl+D复制一个Line，然后将两个Line分别拖入Account、PWD的子项。 通过上述类似方法，给UserPanel添加按钮：WebsiteBtn、ContactsBtn、RetrievePWDBtn、LoginBtn、RegisterBtn 给UserPanel添加UI|Text，设置文本组件如下： 给UserPanel添加UI|InputField（文本输入框），摆放到合适位置，调整大小合适，选中其子项Placeholder和Text，在Inspector里修改字体大小（Font Size）为20。 复制一个InputField，将两个InputField的Image组件|Color设为透明。修改两个文本输入框的Placeholder、Text的Text组件设置。选中密码输入的InputField，可以修改其Input Field组件的Content Type（内容类型）为Password。完成设置后，将账号输入框重命名为UserInputField，将密码输入框重命名为PWDInputField。 为了让UI元素的摆放和美术人员给的效果图一致，我们可以采用如下方法改进： 给UserPanel的Image组件|Source Image拖入“用户模块”图片，点击Color，设置alpha值为最大（设置不透明度为最大），然后将BG取消勾选。此时我们发现原来的UI元素摆放位置和效果图有明显差距，将UI元素对应摆放到对应的位置将其覆盖即可。 完成后将UserPanel的图片设置为透明，勾选BG。 图像、文本框、按钮、输入框的脚本交互在Assets文件夹下创建文件夹Scripts用于存放脚本文件。 创建C#脚本UserPanel.cs，将UserPanel.cs作为组件添加到UserPanel。 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class UserPanel : MonoBehaviour&#123; public Sprite bg; InputField userInput; InputField pwdInput; Button logonBtn; // Start is called before the first frame update void Start() &#123; //修改图片的精灵 transform.Find(\"BG\").GetComponent&lt;Image&gt;().sprite = bg; //初始化 userInput = transform.Find(\"UserInputField\").GetComponent&lt;InputField&gt;(); pwdInput = transform.Find(\"PWDInputField\").GetComponent&lt;InputField&gt;(); logonBtn = transform.Find(\"LogonBtn\").GetComponent&lt;Button&gt;(); //没有参数的方法 //绑定事件 logonBtn.onClick.AddListener(loginBtnOnClick); transform.Find(\"WebsiteBtn\").GetComponent&lt;Button&gt;() .onClick.AddListener(WebsiteBtnOnClick); &#125; private void WebsiteBtnOnClick() &#123; Application.OpenURL(\"https://lol.qq.com/main.shtml\"); &#125; private void loginBtnOnClick() &#123; string account = userInput.text; string pwd = pwdInput.text; Debug.Log(\"账号是：\" + account); Debug.Log(\"密码是：\" + pwd); &#125;&#125; 将“UI/公共”路径下的BG02放入UserPanel的UserPanel脚本组件|bg中，播放游戏，可以看到游戏一启动我们的背景图换成了BG02，在账号输入框和密码输入框输入文本，点击登录按钮，Unity控制台窗口打印账号和密码内容，点击官网按钮，打开英雄联盟官网。 勾选框单选给UserPanel添加UI|Toggle，编辑Toggle下的Label的Text组件|Text。 选中Toggle下的Background，调整勾选框致合适大小，选中Background下的Checkmark，将其锚点设置为stretch-stretch。 播放游戏，当Toggle被勾选上时，Toggle的Toggle组件下的Is On会被勾选 修改我们的UserPanel.cs，添加一个Toggle类型变量toggle，Start方法添加获取Toggle语句。 123456Toggle toggle;// Start is called before the first frame updatevoid Start()&#123; toggle = transform.Find(\"Toggle\").GetComponent&lt;Toggle&gt;(); 修改loginBtnOnClick方法如下。 123456789101112131415private void loginBtnOnClick()&#123; if(toggle.isOn == true) &#123; string account = userInput.text; string pwd = pwdInput.text; Debug.Log(\"账号是：\" + account); Debug.Log(\"密码是：\" + pwd); &#125; else &#123; Debug.Log(\"请先同意用户隐私协议\"); &#125;&#125; 播放游戏，当勾选框没有被勾选时，点击登录按钮，控制台不会打印我们输入的账号和密码。 多选一我们复制三个Toggle，再新建一个空的GameObject，给空GameObject添加Toggle Group组件，同时选中前边的三个Toggle，将GameObject拽到Inspector的Toggle组件|Group下。 播放游戏，这三个勾选框只允许勾选其中一个。 滑动条我们在Canvas下新建一个Panel，重命名为SettingPanel，设置其Image组件|Color为黑色，不透明度适当提高，使SettingPanel显示很暗。 在SettingPanel下新建一个UI|Slider，我们可以对它的三个子项进行个性化设置，我在此只修改了大小和颜色。 当我们播放游戏时，滑动Slider可以改变其Slider组件|Value的值 要在脚本中获取滑动条的值，我们先创建一个SettingPanel.cs，编写代码如下： 12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class SettingPanel : MonoBehaviour&#123; Slider slider; // Start is called before the first frame update void Start() &#123; slider = transform.Find(\"Slider\").GetComponent&lt;Slider&gt;(); slider.onValueChanged.AddListener(OnValueChanged); &#125; void OnValueChanged(float value) &#123; Debug.Log(\"当前滑动条的进度：\" + slider.value); &#125;&#125; 然后将SettingPanel.cs作为组件添加到SettingPanel。播放游戏，当我们滑动Slider，控制台将实时打印Value的值。 滚动视图、遮罩、布局组件、内容尺寸适配器滚动视图给Canvas新建一个UI|Scrow View（滚动视图）,我们可以在Scrow View|Viewport|Content下放入要装的UI元素比如图片。 Content是我们要填装UI元素的容器，单独选中Content改变其大小可以展示总面积。如上图，在其中放入Image后还需要适当调整Image的位置。 Handle是滑条，要改变滑条背景需要在Scrollbar Horizontal/Vertical里设置。 遮罩在滚动视图的Viewport里有一个Mask组件，当我们取消勾选后，将显示被遮住的内容。 我们给Panel新建一个Image，展示颜色为红色，选中Image再新建一个Image，设置颜色为黄色。调整黄色Image的大小使之盖过红色Image，当我们给父物体红色Image添加Mask组件后，子物体黄色Image超出部分会被父物体的遮罩覆盖。 水平/垂直/网格布局组件给Content添加组件Horizontal/Vertical/Grid Layout Group，将使content内的UI元素全部呈水平/垂直排列，并做针对设置。下图给了一个垂直布局组件效果，同时我也在Padding处设置了边距 布局元素给Content下的UI元素比如Image添加Layout Element组件后，勾选Ignore Layout，该Image将不受其他三种布局组件影响，可以随意放置。 内容尺寸适配器给Content添加组件Content Size Fitter，在Content Size Fitter|Vertical Fit选择Preferrd Size，Content的尺寸大小将根据内容布局自动调整。 将Panel重命名为HeroPanel，将Content下第一个Image重命名做成预制体Hero，创建脚本HeroPanel.cs，编写代码如下： 123456789101112131415161718192021222324using System.Collections;using System.Collections.Generic;using UnityEngine;public class HeroPanel : MonoBehaviour&#123; public GameObject hero; public Transform content; // Start is called before the first frame update void Start() &#123; &#125; // Update is called once per frame void Update() &#123; if (Input.GetKeyDown(KeyCode.A)) &#123; GameObject _hero = GameObject.Instantiate(hero); _hero.transform.parent = content; &#125; &#125;&#125; 将HeroPanel.cs添加到HeroPanel，将Hero预制体拖入HeroPanel组件|hero，将Content拖入HeroPanel组件|content。播放游戏，当我们删掉Content下大部分Image，然后鼠标在Game窗口里点击一下，按A键克隆Hero，选中Content我们可看到Content随着Hero的增加动态调节尺寸适应内容。 内容尺寸适配器的另一种常见用法： 给HeroPanel添加一个Text，给Text添加组件Content Size Fitter，Content Size Fitter下边两个属性全部设置为Preferrd Size。 我们输入成段的文本，Content对根据包括换行回车在内的文本内容进行自适应。 矩形变换、UI特效、图片填充","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"C#委托与事件","slug":"C Sharp委托与事件","date":"2020-04-04T01:49:00.000Z","updated":"2020-06-26T09:43:33.048Z","comments":true,"path":"2020/04/04/C Sharp委托与事件/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/04/C%20Sharp%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/","excerpt":"关键词：委托、事件、Lambda公式","text":"关键词：委托、事件、Lambda公式 一、委托 委托就是方法的管理器、调度器。 委托把方法当参数传递和调度。 Delegate“ 委托的老大——Delegate类。” C#的Delegate类似C的指针，不同的是C的指针既可以指方法又可以指变量，而且可以进行类型转换。 C的指针实际上是内存地址变量它既可以直接操作内存，又可以通过内存地址直接访问变量，直接调用方法。 C#的Delegate是强类型，在委托声明时，就已经指定了该变量只能指向具有特定参数和返回值的方法。 使用Delegate可以直接建立任何名称的委托类型，当进行系统编译时，系统将自动生成此类型 我们可以使用“ delegate void delegateName() ”的格式建立一个委托类。 在建立委托对象时，委托的参数类型必须与委托方法相对应。只要往委托对象的构造函数输入方法名，委托就会直接绑定此方法。 使用” DelegateName.Invoke(stringMessage); “可以显式调用委托的方法。实际操作中，我们无须使用Invoke方法，直接使用“ DelegateName(); ”即可。 使用反编译指令ILDASM.exe可以观察其成员。由ILDASM.exe中可以看到，它继承了System.MulticastDelegate类，并自动生成BeginInvole、EndInvoke、Invoke等三种常用方法。 Invoke方法用于同步调用委托对象的对应方法，BeginInvoke、EndInvoke用于以异步的方式调用对应方法。 MulticastDelegate是System.Delegate的子类，是一个特殊类，编译器和其他工具可以从此类派生，但自定义类不能显式地从此类进行派生。它支持多路广播委托，并拥有一个带有链接的委托列表，在调用多路广播委托时，系统将按照调用列表中的委托出现顺序来同步调用这些委托。 MulticastDelegate具有两个常用属性：Method、Target。其中Method用于获取委托所表示的方法Target用于获取当前调用的类实例。 例1（无返回值的委托，技能激活）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectDelegate&#123; delegate void Skills();//声明一个委托，返回类型和要绑定的方法返回类型一致 class Program &#123; static void Main(string[] args) &#123; Skills skills = new Skills(MeleeSkill01); //委托是一个类，现在实例化一个委托Skills，一定要传入一个方法名 //也可以直接写成：Skills skills = MeleeSkill01; skills += MeleeSkill03;//再绑定一个方法 skills += MeleeSkill02; RangeSkill rangeSkill = new RangeSkill(); skills += rangeSkill.RangeSkill02; skills += rangeSkill.RangeSkill01; Console.WriteLine(\"------Round 1------\"); skills.Invoke();//同步调用委托对象skills的方法 Console.WriteLine(\"\\n------Round 2------\"); skills -= MeleeSkill01;//从委托中去掉指定的方法 skills -= rangeSkill.RangeSkill01; skills += rangeSkill.RangeSkill03; skills.Invoke();//也可以直接写成：skills(); &#125; public static void MeleeSkill01() &#123; Console.WriteLine(\"Meleeskill 01 is activated !\"); &#125; public static void MeleeSkill02() &#123; Console.WriteLine(\"Meleeskill 02 is activated !\"); &#125; public static void MeleeSkill03() &#123; Console.WriteLine(\"Meleeskill 03 is activated !\"); &#125; &#125; class RangeSkill &#123; public void RangeSkill01() &#123; Console.WriteLine(\"RangeSkill 01 is activated !\"); &#125; public void RangeSkill02() &#123; Console.WriteLine(\"RangeSkill 02 is activated !\"); &#125; public void RangeSkill03() &#123; Console.WriteLine(\"RangeSkill 03 is activated !\"); &#125; &#125;&#125; 例2（无返回值的委托，任务逻辑）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectDelegate&#123; delegate void Quests(Player player); class Program &#123; static void Main(string[] args) &#123; Player player = new Player(100); Quests quests = Quest01; quests += Quest02; quests += Quest03; Console.WriteLine(\"Player stamina : 100\\n\"); quests(player); &#125; public static void Quest01(Player player) &#123; if (player.Stamina &gt; 0) &#123; Console.WriteLine(\"Quest01 Begin !\"); player.Stamina = player.Stamina - 10; Console.WriteLine(\"Stamina -10 !\"); Console.WriteLine(\"Quest01 Complete !\"); Console.WriteLine(\"Player stamina : \" + player.Stamina + \"\\n\"); &#125; else &#123; Console.WriteLine(\"Quest01 fail !\"); &#125; &#125; public static void Quest02(Player player) &#123; if (player.Stamina &gt; 0) &#123; Console.WriteLine(\"Quest02 Begin !\"); player.Stamina = player.Stamina - 20; Console.WriteLine(\"Stamina -20 !\"); Console.WriteLine(\"Quest02 Complete !\"); Console.WriteLine(\"Stamina : \" + player.Stamina + \"\\n\"); &#125; else &#123; Console.WriteLine(\"Quest02 fail !\"); &#125; &#125; public static void Quest03(Player player) &#123; if (player.Stamina &gt; 0) &#123; Console.WriteLine(\"Quest03 Begin !\"); player.Stamina = player.Stamina - 30; Console.WriteLine(\"Stamina -30 !\"); Console.WriteLine(\"Quest03 Complete !\"); Console.WriteLine(\"Player stamina : \" + player.Stamina + \"\\n\"); &#125; else &#123; Console.WriteLine(\"Quest03 fail !\"); &#125; &#125; &#125; class Player &#123; float stamina; //构造 public Player(float stamina) &#123; this.stamina = stamina; &#125; //封装 public float Stamina &#123; get &#123; return stamina; &#125; set &#123; stamina = value; &#125; &#125; &#125;&#125; 例3（有返回值的委托）123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectDelegate&#123; delegate string Steps(); class Program &#123; static void Main(string[] args) &#123; Steps steps = Step01; steps += Step02; steps += Step03; Console.WriteLine(\"------Round 1------\"); Console.WriteLine(\"The return value of steps() is \" + steps()); steps += Step02; steps -= Step01; Console.WriteLine(\"\\n------Round 2------\"); Console.WriteLine(\"The return value of steps() is \" + steps()); &#125; public static string Step01() &#123; Console.WriteLine(\"Step01\"); return \"Step01\"; &#125; public static string Step02() &#123; Console.WriteLine(\"Step02\"); return \"Step02\"; &#125; public static string Step03() &#123; Console.WriteLine(\"Step03\"); return \"Step03\"; &#125; &#125;&#125; 例4（多路委托）例1、例2、例3均使用多路委托。 多路委托：一个委托绑定并调用了多个方法。 例5（泛型委托，任务逻辑）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectDelegate&#123; delegate void Quests&lt;T&gt;(T t);//使用泛型来声明委托 class Program &#123; static void Main(string[] args) &#123; Warrior warrior = new Warrior(100); Mage mage = new Mage(200); Quests&lt;Warrior&gt; questsW = Quest01; questsW += Quest02; Quests&lt;Mage&gt; questsM = Quest03; questsM += Quest04; questsW(warrior); questsM(mage); &#125; public static void Quest01(Warrior warrior) &#123; if (warrior.Stamina &gt; 0) &#123; Console.WriteLine(\"Warrior has completed Quest01 !\"); warrior.Stamina = warrior.Stamina - 100; &#125; else &#123; Console.WriteLine(\"Quest01 fail !\"); &#125; &#125; public static void Quest02(Warrior warrior) &#123; if (warrior.Stamina &gt; 0) &#123; Console.WriteLine(\"Warrior has completed Quest02 !\"); &#125; else &#123; Console.WriteLine(\"Quest02 fail !\"); &#125; &#125; public static void Quest03(Mage mage) &#123; if (mage.Mana &gt; 0) &#123; Console.WriteLine(\"Mage has completed Quest03 !\"); &#125; else &#123; Console.WriteLine(\"Quest03 fail !\"); &#125; &#125; public static void Quest04(Mage mage) &#123; if (mage.Mana &gt; 0) &#123; Console.WriteLine(\"Mage has completed Quest04 !\"); &#125; else &#123; Console.WriteLine(\"Quest04 fail !\"); &#125; &#125; &#125; class Warrior &#123; float stamina; //构造 public Warrior(float stamina) &#123; this.stamina = stamina; &#125; //封装 public float Stamina &#123; get &#123; return stamina; &#125; set &#123; stamina = value; &#125; &#125; &#125; class Mage &#123; float mana; //构造 public Mage(float mana) &#123; this.mana = mana; &#125; //封装 public float Mana &#123; get &#123; return mana; &#125; set &#123; mana = value; &#125; &#125; &#125;&#125; 二、事件事件是一种特殊的委托，它为委托提供了封装性，即： 允许从类的外部增加、删除方法； 不允许从类的外部来调用委托绑定的方法。 事件为委托对象隐式地建立起add MethodName()、remote MethodName()两个方法，用作注册与注销事件的处理方法。而且事件对应的成员变量将会被视为private变量，外界无法越过事件所在对象直接访问它们。 观察事件的编译过程可知，在编译时，系统为事件自动建立add EventName()、remote EventName()方法。 事件通过“+=”、“-=”两种方式注册或注销方法，使用“+=”或“-=”操作符时，系统自动调用对应的add MethodName()、remote MethodName()进行处理。 event关键字使用格式： 12public delegate Type DelegateName()public event DelegateName EventName; 例1（连锁反应）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectEvent&#123; class Program &#123; static void Main(string[] args) &#123; Guy guy = new Guy(); Cat cat = new Cat(); Dog dog = new Dog(); Home home = new Home(guy, cat, dog); home.alarm += cat.Attack;//不能写home.alarm = cat.Attack;只能 \"+=\" 或 \"-=\"。 home.alarm += dog.Attack; home.alarm += guy.Awake; home.Life(\"peace\");//不触发alarm。 Console.WriteLine(\"------------\"); home.Life(\"thief enter.\");//触发alarm。 //无法直接使用home.alarm(); &#125; &#125; class Guy &#123; public void Sleep() &#123; Console.WriteLine(\"This Guy is sleeping.\"); &#125; public void Awake() &#123; Console.WriteLine(\"This Guy is Awaked.\"); &#125; &#125; class Cat &#123; public void Sunbath() &#123; Console.WriteLine(\"The cat is sunbathing.\"); &#125; public void Attack() &#123; Console.WriteLine(\"The cat attacks.\"); &#125; &#125; class Dog &#123; public void Play() &#123; Console.WriteLine(\"The dog is catching a rat.\"); &#125; public void Attack() &#123; Console.WriteLine(\"The dog barks.\"); &#125; &#125; delegate void Alarm();//声明委托 class Home &#123; Guy guy; Cat cat; Dog dog; public event Alarm alarm;//声明事件 public void Life(string action) &#123; if (action == \"peace\") &#123; guy.Sleep(); cat.Sunbath(); dog.Play(); &#125; else &#123; if(alarm != null) &#123; alarm(); &#125; &#125; &#125; //构造 public Home(Guy guy, Cat cat, Dog dog) &#123; this.guy = guy; this.cat = cat; this.dog = dog; &#125; //封装 internal Guy Guy &#123; get =&gt; guy; set =&gt; guy = value; &#125; internal Cat Cat &#123; get =&gt; cat; set =&gt; cat = value; &#125; internal Dog Dog &#123; get =&gt; dog; set =&gt; dog = value; &#125; &#125;&#125; 注意： 在例1中，Home类的Life方法的事件alarm如果绑定方法不为空，即可使用alarm(string)来引发事件，但在外部的Main方法中直接使用home.Life(string)引发事件，将导致系统发出错误报告。 在事件所处的对象之外，事件只能出现在+=、-=的左边。 例2（交通信号）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Threading;namespace ProjectEvent&#123; delegate void Notify(bool IsPass);//声明一个委托 interface NotifyPass //声明一个接口 &#123; event Notify notify; &#125; class Program &#123; static void Main(string[] args) &#123; TestTrafficLight(); &#125; public static void TestTrafficLight() &#123; TranfficSignal signal = new TranfficSignal(); Bus bus = new Bus(); People people = new People(); signal.notify += bus.Movement; signal.notify += people.Movement; while(true) signal.Wait(); &#125; &#125; class TranfficSignal : NotifyPass &#123; public event Notify notify;//声明一个事件 bool IsPass = false; public void Wait() &#123; for(int i=10; i &gt;= 0; i--) &#123; Thread.Sleep(1000);//线程休眠一秒 Console.WriteLine(i); &#125; IsPass = !IsPass; notify(IsPass); &#125; &#125; class Bus &#123; public void Movement(bool IsPass) &#123; Console.WriteLine(IsPass?\"Bus go !\":\"Bus await.\"); &#125; &#125; class People &#123; public void Movement(bool IsPass) &#123; Console.WriteLine(IsPass?\"People go !\":\"People await.\"); &#125; &#125;&#125; 匿名方法绑定事件例1（交通信号）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Threading;namespace ProjectEvent&#123; delegate void Notify(bool IsPass); interface NotifyPass //声明一个接口 &#123; event Notify notify; &#125; class Program &#123; static void Main(string[] args) &#123; TestTrafficLight(); &#125; public static void TestTrafficLight() &#123; TranfficSignal signal = new TranfficSignal(); signal.notify += delegate (bool pass) &#123; Console.WriteLine(pass ? \"Bus go !\" : \"Bus await\"); &#125;; signal.notify += delegate (bool pass) &#123; Console.WriteLine(pass ? \"People go !\" : \"People await\"); &#125;; signal.notify += delegate (bool pass) &#123; Console.WriteLine(pass ? \"Carriage go !\" : \"Carriage await\"); &#125;; while (true) signal.Wait(); &#125; &#125; class TranfficSignal : NotifyPass &#123; public event Notify notify; bool IsPass = false; public void Wait() &#123; for(int i=10; i &gt;= 0; i--) &#123; Thread.Sleep(1000); Console.WriteLine(i); &#125; IsPass = !IsPass; notify(IsPass); &#125; &#125;&#125; 三、Lambda在Framework 2.0以前，声明委托的唯一方法时通过方法命名，从Framework 2.0起，系统开始支持匿名方法。 通过匿名方法，可以直接把一段代码绑定给事件，减少了实例化委托所需的编码系统开销。 从Framework 3.0起，Lambda表达式逐渐取代匿名方法，作为编写内联代码的首选方式。 总体来说，Lambda表达式使用更简单的方式编写匿名方法，彻底简化委托的使用方式。 例1（交通信号）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Threading;namespace ProjectEvent&#123; delegate void Notify(bool IsPass); interface NotifyPass //声明一个接口 &#123; event Notify notify; &#125; class Program &#123; static void Main(string[] args) &#123; TestTrafficLight(); &#125; public static void TestTrafficLight() &#123; TranfficSignal signal = new TranfficSignal(); signal.notify += (p) =&gt; &#123; Console.WriteLine(p ? \"Bus go !\" : \"Bus await\"); &#125;; signal.notify += (p) =&gt; &#123; Console.WriteLine(p ? \"People go !\" : \"People await\"); &#125;; signal.notify += (p) =&gt;&#123; Console.WriteLine(\"Ambulance GO!!!\");&#125;; while (true) signal.Wait(); &#125; &#125; class TranfficSignal : NotifyPass &#123; public event Notify notify; bool IsPass = false; public void Wait() &#123; for(int i=10; i &gt;= 0; i--) &#123; Thread.Sleep(1000); Console.WriteLine(i); &#125; IsPass = !IsPass; notify(IsPass); &#125; &#125;&#125; 四、类库中的委托例1（角色信息排序）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Threading;namespace ProjectEvent&#123; class Program &#123; static void Main(string[] args) &#123; ListSort(); &#125; public static void ListSort() &#123; List&lt;Character&gt; list = new List&lt;Character&gt;() &#123; new Character(\"Warrior\", 100, 2000), new Character(\"Mage\", 120, 1000), new Character(\"Ranger\", 80, 1500) &#125;; list.Sort((x, y) =&gt; &#123; return (int)(x.Health - y.Health); &#125;); Console.WriteLine(\"\\n按生命值排序: \\nName\\tHealth\\tDaseDamage\"); foreach(var item in list) &#123; Console.WriteLine(item); &#125; list.Sort((x, y) =&gt; &#123; return (int)(x.BaseDamage - y.BaseDamage); &#125;); Console.WriteLine(\"\\n按攻击力排序: \\nName\\tHealth\\tDaseDamage\"); foreach (var item in list) &#123; Console.WriteLine(item); &#125; list.Sort((x, y) =&gt; &#123; return x.Name.CompareTo(y.Name); &#125;);// Console.WriteLine(\"\\n按名字排序: \\nName\\tHealth\\tDaseDamage\"); foreach (var item in list) &#123; Console.WriteLine(item); &#125; &#125; &#125; class Character &#123; string name; float health; float baseDamage; public Character(string name, float health, float baseDamage) &#123; this.name = name; this.health = health; this.baseDamage = baseDamage; &#125; public string Name &#123; get =&gt; name; set =&gt; name = value; &#125; public float Health &#123; get =&gt; health; set =&gt; health = value; &#125; public float BaseDamage &#123; get =&gt; baseDamage; set =&gt; baseDamage = value; &#125; public override string ToString() &#123; return String.Format(\"&#123;0&#125;\\t&#123;1&#125;\\t&#123;2&#125;\", name, health, BaseDamage); &#125; &#125;&#125; 参考List&lt;T&gt;.Sort方法详情 五、常用委托Action泛型委托Action由系统提供，无须声明。 Action支持0~16个参数，可以按需求任意使用，无返回值。 123456789Action&lt;&gt;Action&lt;T&gt;Action&lt;T1, T2&gt;...Action&lt;T1, T2, ..., T16&gt; 例1（交通信号）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Threading;namespace ProjectAction&#123; interface NotifyPass //声明一个接口 &#123; event Action&lt;bool&gt; notify; &#125; class Program &#123; static void Main(string[] args) &#123; TestTrafficLight(); &#125; public static void TestTrafficLight() &#123; TranfficSignal signal = new TranfficSignal(); signal.notify += (p) =&gt; &#123; Console.WriteLine(p ? \"Bus go !\" : \"Bus await\"); &#125;; signal.notify += (p) =&gt; &#123; Console.WriteLine(p ? \"People go !\" : \"People await\"); &#125;; signal.notify += (p) =&gt; &#123; Console.WriteLine(\"Ambulance GO!!!\"); &#125;; while (true) signal.Wait(); &#125; class TranfficSignal : NotifyPass &#123; public event Action&lt;bool&gt; notify; bool IsPass = false; public void Wait() &#123; for (int i = 10; i &gt;= 0; i--) &#123; Thread.Sleep(1000); Console.WriteLine(i); &#125; IsPass = !IsPass; notify(IsPass); &#125; &#125; &#125;&#125; 结果同：三、Lambda|例1 Func委托Func与Action相似，同样支持0~16个参数，不同在于Func必须具备返回值。 1234Func&lt;TResult&gt;Func&lt;T, TResult&gt;Func&lt;T1, T2, TResult&gt;Func&lt;T1, T2, ..., T16, TResult&gt; 例1（计算实际伤害）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ProjectFunc&#123; class Program &#123; static void Main(string[] args) &#123; Attack( new Character(\"Warrior1\", 500, 300, 100, 2), new Character(\"Warrior2\", 600, 400, 90, 3) ); &#125; public static void Attack(Character c1, Character c2) &#123; //作为内联代码，外部无法获知 Func&lt;float, float, float, float&gt; damage = (b, f, a) =&gt; &#123; return b * f - a; &#125;; Console.WriteLine(\"&#123;0&#125;对&#123;1&#125;的实际伤害：&#123;2&#125;\", c1.Name, c2.Name, damage(c1.BaseDamage, c1.Factor, c2.Armor)); Console.WriteLine(\"&#123;0&#125;对&#123;1&#125;的实际伤害：&#123;2&#125;\", c2.Name, c1.Name, damage(c2.BaseDamage, c2.Factor, c1.Armor)); &#125; &#125; class Character &#123; string name; float health; float baseDamage; float armor; float factor; public Character(string name, float health, float baseDamage, float armor, float factor) &#123; this.name = name; this.health = health; this.baseDamage = baseDamage; this.armor = armor; this.factor = factor; &#125; public string Name &#123; get =&gt; name; set =&gt; name = value; &#125; public float Health &#123; get =&gt; health; set =&gt; health = value; &#125; public float BaseDamage &#123; get =&gt; baseDamage; set =&gt; baseDamage = value; &#125; public float Armor &#123; get =&gt; armor; set =&gt; armor = value; &#125; public float Factor &#123; get =&gt; factor; set =&gt; factor = value; &#125; &#125;&#125; 例212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Func&#123; class Program &#123; //Action支持绑定1~16个带参数的方法 //Func支持绑定1~16个带参数的方法，但这些带参数的方法都必须有返回值 static Func&lt;int, int, int&gt; func1; static void Main(string[] args) &#123; //将方法与委托进行绑定 //func1 = Test; func1 += Test; func1 += Test2; //将委托调用的时候，实际就是调用绑定的方法 int result = func1(100, 500);//实际只返回Test2的结果 Console.WriteLine(\"结果1是：\" + result); //取消委托的注册，实际上就是移除掉绑定的方法 func1 -= Test2; int result2 = func1(100, 500); Console.WriteLine(\"结果2是：\" + result2); //把它当作方法的参数进行传递 int result3 = Test3(Test2, 100, 500); Console.WriteLine(\"结果3是：\" + result3); &#125; public static int Test(int a, int b) &#123; return a + b; &#125; public static int Test2(int a, int b) &#123; return a * b; &#125; //回调，有时候也不是很方便，这时可以换用Action public static int Test3(Func&lt;int,int,int&gt; callback, int a, int b) &#123; Console.WriteLine(\"Test3...\"); if(callback != null) &#123; return callback(a, b); &#125; return 0; &#125; &#125;&#125; 程序运行结果：","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#文件管理","slug":"C Sharp文件管理","date":"2020-04-03T09:40:00.000Z","updated":"2020-04-03T14:59:19.275Z","comments":true,"path":"2020/04/03/C Sharp文件管理/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/03/C%20Sharp%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"目的和作用 通过File类对文件进行操作 通过FileStream类操作文件 通过StreamReader和StreamWriter读写文件 通过FileInfo类访问文件信息 通过DirectoryInfo类文件夹进行操作","text":"目的和作用 通过File类对文件进行操作 通过FileStream类操作文件 通过StreamReader和StreamWriter读写文件 通过FileInfo类访问文件信息 通过DirectoryInfo类文件夹进行操作 目的和作用为了像word、excel等帮软件一样，可以将一些数据保存到计算机中，方便下次使用。在游戏开发中，比如： 商城的配置 关卡的配置 装备的配置 技能的配置 … 无外乎两个操作：读取、保存 通过File类对文件进行操作首先需要知道读取哪一个文件，即要知道文件所在路径。读取到的内容赋值到string类型变量。 File.Exists判断文件是否存在。 File.ReadAllText读取文件中所有的内容。 文本文件如果有中文，需要将编码设置为UTF-8。读取的时候，我们要传递第二个参数Encoding.UTF-8。 File.AppendAllText可以把文本追加到我们的目标对象上。 Environment.NewLine表示回车换行符。 “\\r\\n”表示回车换行符。 File.WriteAllText这个操作是将目标对象中的内容替换掉。 通过File.Create创建文件。创建的时候，如果文件已存在，则覆盖已存在文件。 通过File.Delete删除文件。 例1（文件读取、文件修改）准备文本文件如下： 123456英雄ID 名称 类型 价格 拥有法力 法力值 生命值 攻击力int string int int bool float float floatID Name Type Price HaveMP HP MP Attack1001 双持 2 4500 FALSE 2250 0 2751002 钳工 1 5000 FALSE 2250 0 2121003 毁法 2 6000 TRUE 2750 0 215 用VS 2017创建一个C#控制台应用（.NET Framework）项目，取名Project_File。 编辑Program.cs如下： 1234567891011121314151617181920212223242526272829303132333435using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_File&#123; class Program &#123; static void Main(string[] args) &#123; //转义符 \\r \\n @\\ string path = @\"E:\\Study with me\\TextFile\\Save.txt\"; //判断文件是否存在 if (File.Exists(path)) &#123; Console.WriteLine(\"找到文件\"); //读取文件 string text = File.ReadAllText(path, Encoding.UTF8); Console.WriteLine(text); //写入数据到文件 string writeText = \"\\n\"+\"1004 影刺 2 9500 FALSE 4000 0 200\"; //File.WriteAllText(path, writeText);//新文本取代整个旧文本 File.AppendAllText(path, writeText);//在原来的文本末尾添加新文本 &#125; else &#123; Console.WriteLine(\"文件不存在\"); &#125; &#125; &#125;&#125; 运行程序后，在控制台界面打印原来的文本，打开查看Save.txt发现成功添加了一行新文本 例2（文件创建、文件删除）编辑Program.cs如下： 123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_File&#123; class Program &#123; static void Main(string[] args) &#123; string path = @\"E:\\Study with me\\TextFile\\Save2.txt\"; if (File.Exists(path)) &#123; File.Delete(path); Console.WriteLine(\"文件Save2.txt已删除\"); &#125; else &#123; File.Create(path); Console.WriteLine(\"文件Save2.txt已创建\"); &#125; &#125; &#125;&#125; 运行程序后，创建文本文件Save2.txt，再次运行，Save2.txt被删除。 通过FileStream类操作文件构建FileStream对象 Encoding.UTF-8.GetBytes可以将一个字符串转换为byte[ ] Encoding.UTF-8.GetString可以将byte[ ]字节数组转换为string 写入stream.Write 读取stream.Read 关闭操作流 stream.Close 无论读取还是写入，最终都是需要byte[ ]操作 Win7系统注意：读取到的文本前边多出一个问号。解决办法： 使用Notepad++打开记事本，然后转化为UTF-8无BOM格式即可。 BOM（Byte Order Mark）是为UTF-16和UTF-32准备的，用于标记字节序（byte order）。微软在UTF-8中使用BOM是因为这样可以把UTF-8和ASCII等编码明确区分开，但这样的文件在Windows系统之外的操作系统里会带来问题。[UTF-8]和[带BOM的UTF-8]的区别是有无BOM，即文件开头有没有U+FEFF。 例子通过VS 2017创建C#控制台应用项目Project_FileStream，编辑Program.cs如下： 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_FileStream&#123; class Program &#123; static void Main(string[] args) &#123; string path = @\"E:\\Study with me\\TextFile\\Save.txt\"; FileStream fileStream = new FileStream(path, FileMode.OpenOrCreate); byte[] data = new byte[fileStream.Length]; while (true) &#123; int length = fileStream.Read(data, 0, data.Length); if(length == 0) &#123; Console.WriteLine(\"读取完毕\"); break; &#125; &#125; Console.WriteLine(Encoding.UTF8.GetString(data)); fileStream.Close(); FileStream writeStream = new FileStream(path, FileMode.Open); string text = \"\\n1005 幻刺 2 6000 TRUE 2350 5000 220\"; byte[] writeData = Encoding.UTF8.GetBytes(text); //写入到文本里 //要写入的位置进行赋值 //写入的位置决定了我们写入的数据是从哪里开始 writeStream.Position = writeStream.Length; writeStream.Write(writeData, 0, writeData.Length); writeStream.Close(); &#125; &#125;&#125; 程序运行后，在控制台打印Save.txt里的旧信息，关闭控制台后打开Save.txt发现成功添加了新的一行信息。 通过StreamReader和StreamWriter读写文件ReadToEnd读取之后直接返回字符串。 Write/WriteLine也可以直接传递字符串来进行写入。 在构建StreamWriter实例时，如需追加数据需要传递第二个参数，否则覆盖。填true导致追加，默认false导致覆盖。 Close关闭流，释放占用的内存空间。 如果流没有关闭，然后已经写入了数据，那么再次写入，就是从上次的末尾来进行写入，读取从上次读取到的位置继续读取。 例1（StreamReader读文件）通过VS 2017创建控制台应用项目Project_StreamReaderWrite，编辑Program.cs如下： 1234567891011121314151617181920using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_StreamReaderWrite&#123; class Program &#123; static void Main(string[] args) &#123; string path = @\"E:\\Study with me\\TextFile\\Save.txt\"; StreamReader streamReader = new StreamReader(path); Console.WriteLine(streamReader.ReadToEnd()); streamReader.Close(); &#125; &#125;&#125; 运行程序结果如下： 例2（StreamWriter写文件）修改Program.cs： 12345678910111213141516171819202122using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_StreamReaderWrite&#123; class Program &#123; static void Main(string[] args) &#123; string path = @\"E:\\Study with me\\TextFile\\Save.txt\"; string text = \"\\n1006 双手 1 7000 FALSE 3350 0 230\"; //追加数据需要传递第二个参数，否则覆盖。true表示追加，默认false表示覆盖。 StreamWriter streamWriter = new StreamWriter(path, true); streamWriter.WriteLine(text); streamWriter.Close(); &#125; &#125;&#125; 运行程序后Save.txt成功添加了一行： 通过FileInfo类访问文件信息封装文件的一些属性： 完整路径 名称 创建日期 最近访问日期 大小（byte） 是否只读 是否存在 创建文件 删除文件 游戏开发中的应用： 验证文件是否合法 比较文件是否与服务器的版本一致（热更新） 例1（通过FileInfo创建和删除文件）用VS 2017新建一个控制台应用项目，取名Project_FileInfo，编辑Program.cs如下： 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_FileInfo&#123; class Program &#123; static void Main(string[] args) &#123; string path = @\"E:\\Study with me\\TextFile\\Save3.txt\"; FileInfo fileInfo = new FileInfo(path); if (fileInfo.Exists) &#123; fileInfo.Delete(); &#125; else &#123; fileInfo.Create(); &#125; &#125; &#125;&#125; 运行后，成功在指定目录创建了Save3.txt，再次运行则Save3.txt被删除。 例2（通过FileInfo读取文件的属性）修改Program.cs如下： 12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_FileInfo&#123; class Program &#123; static void Main(string[] args) &#123; string path = @\"E:\\Study with me\\TextFile\\Save.txt\"; FileInfo fileInfo = new FileInfo(path); if (fileInfo.Exists) &#123; Console.WriteLine(fileInfo.FullName); Console.WriteLine(fileInfo.CreationTime); Console.WriteLine(fileInfo.LastAccessTime); Console.WriteLine(fileInfo.IsReadOnly); Console.WriteLine(fileInfo.Length); Console.WriteLine(fileInfo.Name); &#125; else &#123; fileInfo.Create(); &#125; &#125; &#125;&#125; 运行后控制台打印了Save.txt的文件属性，如下图： 通过DirectoryInfo类文件夹进行操作 创建文件夹、子文件夹 删除空文件夹 获取文件夹的一些属性 文件夹是否存在 例1（通过DirectoryInfo创建与删除文件夹）通过VS 2017创建一个控制台应用项目Project_DirectoryInfo，编辑Program.cs如下： 1234567891011121314151617181920212223242526272829303132using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_DirectoryInfo&#123; class Program &#123; static void Main(string[] args) &#123; string path = @\"E:\\Study with me\\TextFile\\Skyrim\"; DirectoryInfo directoryInfo = new DirectoryInfo(path); if (!directoryInfo.Exists) &#123; Console.WriteLine(\"Skyrim件夹不存在\"); Console.WriteLine(\"Skyrim文件夹创建中...\"); directoryInfo.Create(); Console.WriteLine(\"Skyrim文件夹已创建\"); &#125; else &#123; Console.WriteLine(\"Skyrim文件夹已存在\"); Console.WriteLine(\"Skyrim文件夹删除中...\"); directoryInfo.Delete();//文件夹为空文件夹时删除，否则出现异常 Console.WriteLine(\"Skyrim文件夹已删除\"); &#125; &#125; &#125;&#125; 运行程序后，在指定路径成功创建了Skyrim文件夹，再次运行删除Skyrim文件夹。 例2（通过DirectoryInfo访问文件夹属性）编辑Program.cs如下： 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_DirectoryInfo&#123; class Program &#123; static void Main(string[] args) &#123; string path = @\"E:\\Study with me\\TextFile\\Skyrim\"; DirectoryInfo directoryInfo = new DirectoryInfo(path); if (!directoryInfo.Exists) &#123; Console.WriteLine(\"文件夹不存在\"); Console.WriteLine(\"文件夹创建中...\"); directoryInfo.Create(); Console.WriteLine(\"文件夹已创建\"); &#125; else &#123; Console.WriteLine(directoryInfo.FullName); Console.WriteLine(directoryInfo.Name); Console.WriteLine(directoryInfo.CreationTime); Console.WriteLine(directoryInfo.LastAccessTime); //访问所在盘符 Console.WriteLine(directoryInfo.Root); //创建子文件夹Data directoryInfo.CreateSubdirectory(\"Data\"); &#125; &#125; &#125;&#125; 运行程序后，成功在控制台打印Skyrim文件夹的属性信息，并成功创建了子文件Data。","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#序列化与反序列化","slug":"C Sharp序列化与反序列化","date":"2020-04-01T12:25:00.000Z","updated":"2020-04-03T07:11:13.673Z","comments":true,"path":"2020/04/01/C Sharp序列化与反序列化/","link":"","permalink":"https://weimingjuncn.github.io/2020/04/01/C%20Sharp%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"游戏中的各种配置文件存有很多参数，比如商城的配置文件存各种道具的信息，每个道具又有各种属性如名称、说明、原价、活动、优惠价等。 但是我们直接从本地文件读取到的数据十一个很长的字符串，要将这些配置信息给我们的代码使用，还需要创建很多变量，然后逐一赋值，十分麻烦。 另一方面，如果我们要做游戏存档，需要思考要存储的各种变量，在配置文件中应该起什么名称，参数的值如何进行存储。","text":"游戏中的各种配置文件存有很多参数，比如商城的配置文件存各种道具的信息，每个道具又有各种属性如名称、说明、原价、活动、优惠价等。 但是我们直接从本地文件读取到的数据十一个很长的字符串，要将这些配置信息给我们的代码使用，还需要创建很多变量，然后逐一赋值，十分麻烦。 另一方面，如果我们要做游戏存档，需要思考要存储的各种变量，在配置文件中应该起什么名称，参数的值如何进行存储。 序列化和反序列化就是用来解决上述麻烦的。 读取数据之后，不用手动去创建变量，然后逐一赋值。 存储数据的时候不用关心倒地要怎么组织存储格式，变量名称要如何定义等 前提：按照“通用的”格式进行序列化和反序列化 XML JSON 实际应用游戏中所有英雄的数据 游戏中所有道具的数据 游戏中所有技能的数据 游戏中所有XXX的数据 以上数据在后期调整修改的变化频率较大，所以会通过配置文件来进行存储。 使用反序列化接口可以使这些数据字典转化为游戏中的一个个变量 游戏存档 适用于单机游戏 使用序列化接口，可以使代码中要存储的数据转化为通用格式的字符串 方便玩家下次登录时程序再取到这些数据，然后进行反序列化操作，拿到上一次存储的重要数据 比如上一个存档中人物的各种属性 比如上一个存档中背包里所有道具的信息 比如上一个存档中任务的进度 按XML格式读取和存储 XML指可拓展标记语言 XML被设计用于结构化存储以及传输信息 XML语法如何描述一个XML文件？ XML是由若干个标签对构成 标签可以有对应内容 标签可以加上属性说明 XML文档必须有根元素 12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;...&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; 所有XML元素都必须有关闭标签 1&lt;p&gt;This is a paragraph&lt;/p&gt; XML标签对大小写敏感 12&lt;Message&gt;这是错误的&lt;/message&gt;&lt;message&gt;这是正确的&lt;/message&gt; XML必须正确嵌套 1234错误例子：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;正确例子：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt; XML的属性值须加引号 12345678910错误例子：&lt;note date=08/08/2008&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt;&lt;/note&gt;正确例子：&lt;note date=\"08/08/2008\"&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt;&lt;/note&gt; 序列化与反序列化XML序列化：将实体类转化为XML文档 XML反序列化：将XML文档转化为实体类 例子（XML反序列化）通过VS2017创建一个C#控制台应用（.NET Framework）项目，取名Project_XML。 给项目添加两个类，分别取名为SkillConfig、Skill Program.cs内容如下： 12345678910111213141516171819202122232425262728293031323334using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML&#123; class Program &#123; static void Main(string[] args) &#123; XMLDeserialize(); &#125; public static void XMLDeserialize() &#123; string path = @\"E:\\Study with me\\XMLfile\\SkillConfig.xml\"; XmlSerializer xmlSerializer = new XmlSerializer(typeof(SkillConfig)); //先读取到文件 FileStream fileStream = new FileStream(path, FileMode.Open); SkillConfig skillConfig = (SkillConfig)xmlSerializer.Deserialize(fileStream); fileStream.Close(); for(int i=0; i &lt; skillConfig.SkillList.Count; i++) &#123; Console.WriteLine(skillConfig.SkillList[i].id + \" \" + skillConfig.SkillList[i].name + \" \" + skillConfig.SkillList[i].damage); &#125; &#125; &#125;&#125; SkillConfig.cs内容如下： 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML&#123; [XmlRootAttribute(\"SkillConfig\")] public class SkillConfig &#123; public List&lt;Skill&gt; SkillList = new List&lt;Skill&gt;(); &#125;&#125; Skill.cs内容如下： 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_XML&#123; public class Skill &#123; public int id; public string name; public int damage; &#125;&#125; SkillConfig.xml内容如下： 12345678910111213141516171819&lt;SkillConfig&gt; &lt;SkillList&gt; &lt;Skill&gt; &lt;id&gt;001&lt;/id&gt; &lt;name&gt;连牙杀&lt;/name&gt; &lt;damage&gt;50000&lt;/damage&gt; &lt;/Skill&gt; &lt;Skill&gt; &lt;id&gt;002&lt;/id&gt; &lt;name&gt;虚空斩&lt;/name&gt; &lt;damage&gt;60000&lt;/damage&gt; &lt;/Skill&gt; &lt;Skill&gt; &lt;id&gt;003&lt;/id&gt; &lt;name&gt;步月流星&lt;/name&gt; &lt;damage&gt;70000&lt;/damage&gt; &lt;/Skill&gt; &lt;/SkillList&gt;&lt;/SkillConfig&gt; 运行结果如下： 例子（XML序列化）Program.cs修改后如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML&#123; class Program &#123; static void Main(string[] args) &#123; XMLSerialize(); &#125; public static void XMLSerialize() &#123; SkillConfig skillConfig = new SkillConfig(); Skill skillOne = new Skill(); skillOne.id = 101; skillOne.name = \"破天\"; skillOne.damage = 10000; Skill skillTwo = new Skill(); skillTwo.id = 102; skillTwo.name = \"流星\"; skillTwo.damage = 20000; Skill skillThree = new Skill(); skillThree.id = 103; skillThree.name = \"残月\"; skillThree.damage = 30000; skillConfig.SkillList.Add(skillOne); skillConfig.SkillList.Add(skillTwo); skillConfig.SkillList.Add(skillThree); //将以上实体类进行序列化 //第一步：确定XML文档路径 string path = @\"E:\\Study with me\\XMLfile\\SkillConfig3.xml\"; //第二步：构建用于序列化的对象 XmlSerializer xmlSerializer = new XmlSerializer(typeof(SkillConfig)); //第三步：构建文件流，写入数据 StreamWriter streamWriter = new StreamWriter(path, false, Encoding.UTF8); //可选步骤：自定义命名空间 //不建议自定义命名空间，因为没太大必要 XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces(); namespaces.Add(\"\", \"\"); //第四步：调用序列化对象的序列化的接口 //xmlSerializer.Serialize(streamWriter, skillConfig); xmlSerializer.Serialize(streamWriter, skillConfig, namespaces); streamWriter.Close(); Console.WriteLine(\"已经序列化完毕\"); &#125; &#125;&#125; 程序运行后生成SkillConfig3.xml文档如下： XML序列化和反序列化例子（带标签属性）Program.cs经修改后： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML&#123; class Program &#123; static void Main(string[] args) &#123; XMLDeserialize(); //XMLSerialize(); &#125; public static void XMLDeserialize() &#123; //string path = @\"E:\\Study with me\\XMLfile\\SkillConfig.xml\"; string path = @\"E:\\Study with me\\XMLfile\\SkillConfig4.xml\"; XmlSerializer xmlSerializer = new XmlSerializer(typeof(SkillConfig)); //先读取到文件 FileStream fileStream = new FileStream(path, FileMode.Open); SkillConfig skillConfig = (SkillConfig)xmlSerializer.Deserialize(fileStream); fileStream.Close(); for(int i=0; i &lt; skillConfig.SkillList.Count; i++) &#123; Console.WriteLine(skillConfig.SkillList[i].id + \" \" + skillConfig.SkillList[i].name.attackType + \" \" + skillConfig.SkillList[i].name.content + \" \" + skillConfig.SkillList[i].damage); &#125; &#125; public static void XMLSerialize() &#123; SkillConfig skillConfig = new SkillConfig(); Skill skillOne = new Skill(); skillOne.id = 101; //skillOne.name = \"破天\"; skillOne.name = new Name(); skillOne.name.attackType = \"近战\"; skillOne.name.content = \"破天\"; skillOne.damage = 10000; Skill skillTwo = new Skill(); skillTwo.id = 102; //skillTwo.name = \"流星\"; skillTwo.name = new Name(); skillTwo.name.attackType = \"近战\"; skillTwo.name.content = \"流星\"; skillTwo.damage = 20000; Skill skillThree = new Skill(); skillThree.id = 103; //skillThree.name = \"残月\"; skillThree.name = new Name(); skillThree.name.attackType = \"近战\"; skillThree.name.content = \"残月\"; skillThree.damage = 30000; skillConfig.SkillList.Add(skillOne); skillConfig.SkillList.Add(skillTwo); skillConfig.SkillList.Add(skillThree); //将以上实体类进行序列化 //第一步：确定XML文档路径 string path = @\"E:\\Study with me\\XMLfile\\SkillConfig4.xml\"; //第二步：构建用于序列化的对象 XmlSerializer xmlSerializer = new XmlSerializer(typeof(SkillConfig)); //第三步：构建文件流，写入数据 StreamWriter streamWriter = new StreamWriter(path, false, Encoding.UTF8); //可选：命名空间 //不建议自定义命名空间，因为没太大必要 XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces(); namespaces.Add(\"\", \"\"); //第四步：调用序列化对象的序列化的接口 //xmlSerializer.Serialize(streamWriter, skillConfig); xmlSerializer.Serialize(streamWriter, skillConfig, namespaces); streamWriter.Close(); Console.WriteLine(\"已经序列化完毕\"); &#125; &#125;&#125; Skill.cs经修改后： 123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Xml.Serialization;namespace Project_XML&#123; public class Skill &#123; public int id; //public string name; public Name name; public int damage; &#125; public class Name &#123; //因为要对name进行拓展，加上属性 [XmlAttribute(\"attackType\")] public string attackType; [XmlText] public string content; &#125;&#125; 成员标记[XmlRootAttribute]：对根节点的描述，在类声明中使用 [XmlType]：对节点描述，在类声明中使用 [XmlElement]：节点下内部节点描述，如果对数组标识，是对数组单元描述 [XmlAttribute]：节点下内部属性描述 [XmlArrayItem]：数组单元项描述 [XmlArray]：数组描述 [XmlIgnore]：使该项不序列化 [XmlText]：做为节点的text文本输出 按Json的方式进行读取和存储Json是什么？格式： 键值对 数据由逗号分隔 大括号保存对象 键值对中的值可以是一个class 值如果是string，需要加上双引号，如果不是则不需要 如果值是数组，那么需要用中括号括起来 Json的体积相比XML更小，在客户端和服务端的传输的过程中消耗资源更低，传输速度就会更快 怎样使用它序列化：将实体类转化为Json文档 反序列化：将Json文档转化为实体类 如果用于网络传输 string -&gt; 转化byte[ ] 例子（反序列化）准备Skill.json文件如下： 12345&#123;\"name\": \"破天\",\"id\":1001,\"damage\":800&#125; 用VS 2017创建一个C#控制台应用（.NET Framework）项目，取名为Project_Json。 给项目添加一个类，取名Skill。 在VS2017的解决方案资源管理器窗口的【引用】右键，选择【添加引用】，在弹出的窗口左边选择【浏览】,点击下方浏览按钮，导入文件LitJson.dll。（LitJson.dll可以在网上搜索下载） 编辑Skill.cs如下： 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Json&#123; class Skill &#123; public int id; public string name; public int damage; &#125;&#125; 编辑Program.cs如下： 12345678910111213141516171819202122232425262728293031323334353637using LitJson;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Json&#123; class Program &#123; static void Main(string[] args) &#123; ToObject(); &#125; //反序列化 static void ToObject() &#123; //1.确定读取的Json文档的路径 string path = @\"E:\\Study with me\\JsonFile\\Skill.json\"; //2.构建读取文件的流 StreamReader streamReader = new StreamReader(path); string text = streamReader.ReadToEnd(); //3.调用反序列化的API Skill skill = JsonMapper.ToObject&lt;Skill&gt;(text); Console.WriteLine(skill.id + \" \" + skill.name + \" \" + skill.damage); streamReader.Close(); &#125; &#125;&#125; 运行程序结果如下： 例子（序列化）Program.cs修改后如下： 1234567891011121314151617181920212223242526272829303132333435363738using LitJson;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Json&#123; class Program &#123; static void Main(string[] args) &#123; ToJson(); &#125; //序列化 static void ToJson() &#123; //1.构建需要进行保存的数据 Skill skill = new Skill(); skill.id = 1001; skill.name = \"末日\"; skill.damage = 99999; //2.确定保存路径 string path = @\"E:\\Study with me\\JsonFile\\Skill2.json\"; //3.通过序列化的API获取到需要写入的文本 string text = JsonMapper.ToJson(skill); //4.通过文件流进行写入操作 StreamWriter streamWriter = new StreamWriter(path); streamWriter.Write(text); streamWriter.Close(); Console.WriteLine(\"Json文档保存成功\"); &#125; &#125;&#125; 程序运行结果： 案例：开发一个角色的背包分三步开发 写一个辅助类JsonHelper： 提供序列化接口和反序列化接口，可以复用。 创建实体类和本地的Json文件 写管理类，提供增删改查功能。（内部维护的一个数据结构，通常为字典） 准备一个MyProp.json如下： 12345678&#123; \"props\":[ &#123;\"name\":\"滴石\",\"id\":1001,\"use\":false&#125;, &#123;\"name\":\"辉滴石\",\"id\":1002,\"use\":false&#125;, &#123;\"name\":\"古老的辉滴石\",\"id\":1003,\"use\":false&#125;, &#123;\"name\":\"元素瓶\",\"id\":1004,\"use\":false&#125; ]&#125; 用VS 2017创建个控制台应用项目，取名为Project_Warehouse。 添加引用LitJson.dll。（注意：如果是添加最近的引用，需要勾选后再点击确定） 添加三个类，分别取名为MyProp，MyPropManager，JsonHelper。 MyProp.cs内容如下： 1234567891011121314151617181920212223using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Warehouse&#123; class MyProp &#123; //我的道具列表 public List&lt;Prop&gt; props = new List&lt;Prop&gt;(); &#125; /// &lt;summary&gt; /// 道具的实体类 /// &lt;/summary&gt; class Prop &#123; public int id;//道具ID public string name;//道具名称 public bool use;//是否使用过 &#125;&#125; MyPropManager.cs内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Warehouse&#123; class MyPropManager &#123; public Dictionary&lt;int, Prop&gt; props = new Dictionary&lt;int, Prop&gt;(); public MyProp myProp = new MyProp(); string path = @\"E:\\Study with me\\JsonFile\\MyProp.json\"; public void Init() &#123; myProp = JsonHelper.ToObject&lt;MyProp&gt;(path); //通过ID查找一个物体... for(int i = 0; i &lt; myProp.props.Count; i++) &#123; if (!props.ContainsKey(myProp.props[i].id)) &#123; props.Add(myProp.props[i].id, myProp.props[i]); &#125; &#125; Console.WriteLine(\"初始化结束\"); &#125; public List&lt;Prop&gt; GetAll() &#123; return myProp.props; &#125; public Prop Get(int id) &#123; if (!props.ContainsKey(id)) &#123; return null; &#125; else &#123; return props[id]; &#125; &#125; public bool Add(Prop prop) &#123; if (!props.ContainsKey(prop.id)) &#123; props.Add(prop.id, prop); myProp.props = props.Values.ToList(); JsonHelper.ToJson&lt;MyProp&gt;(myProp, path); return true; &#125; else &#123; return false; &#125; &#125; public bool Remove(int id) &#123; if (props.ContainsKey(id)) &#123; props.Remove(id); myProp.props = props.Values.ToList(); JsonHelper.ToJson&lt;MyProp&gt;(myProp, path); return true; &#125; else &#123; return false; &#125; &#125; public bool Update(int id, bool use) &#123; if (props.ContainsKey(id)) &#123; props[id].use = use; myProp.props = props.Values.ToList(); JsonHelper.ToJson&lt;MyProp&gt;(myProp, path); return true; &#125; else &#123; return false; &#125; &#125; &#125;&#125; JsonHelper.cs内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142using LitJson;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Warehouse&#123; class JsonHelper &#123; /// &lt;summary&gt; /// 序列化 /// &lt;/summary&gt; /// &lt;typeparam name=\"T\"&gt;类型&lt;/typeparam&gt; /// &lt;param name=\"o\"&gt;要序列化的对象&lt;/param&gt; /// &lt;param name=\"path\"&gt;路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ToJson&lt;T&gt;(T o, string path) &#123; string text = JsonMapper.ToJson(o); StreamWriter streamWriter = new StreamWriter(path, false, Encoding.UTF8); streamWriter.Write(text); streamWriter.Close(); return text; &#125; /// &lt;summary&gt; /// 反序列化 /// &lt;/summary&gt; /// &lt;typeparam name=\"T\"&gt;类型&lt;/typeparam&gt; /// &lt;param name=\"path\"&gt;路径&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static T ToObject&lt;T&gt;(string path) &#123; StreamReader streamReader = new StreamReader(path); string text = streamReader.ReadToEnd(); streamReader.Close(); T o = JsonMapper.ToObject&lt;T&gt;(text); return o; &#125; &#125;&#125; Program.cs内容： 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Warehouse&#123; class Program &#123; static void Main(string[] args) &#123; MyPropManager myPropManager = new MyPropManager(); myPropManager.Init();//初始化 //查找所有道具 //List&lt;Prop&gt; props = myPropManager.GetAll(); //for (int i = 0; i &lt; props.Count; i++) //&#123; // Console.WriteLine(props[i].id + \" \" // + props[i].name + \" \" // + props[i].use); //&#125; //查找单个道具 //Prop prop = myPropManager.Get(1001); //Console.WriteLine(\"1001: \" + prop.name); //添加物品 //Prop prop = new Prop() &#123; id = 1005, name = \"飞镖\", use = false &#125;; //myPropManager.Add(prop); //Console.WriteLine(\"添加【\" + prop.name +\"】成功\"); //删除物品 //myPropManager.Remove(1005); //更新物品属性 //myPropManager.Update(1002, true); //Console.WriteLine(\"更新属性成功\"); &#125; &#125;&#125; 总结 所有业务模块基本均有增删查改构成 模块独立化，比如本例中JsonHelper类的出现，能少写很多条调用序列化和反序列化的代码。 所有的功能需求都是数学问题，即数学建模。 构建一个类，包含背包的信息无非是各种字段/属性。 背包的业务：增加物品、删除物品、修改物品、查找物品。 初始化一定要做，否则容易出问题。","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"C#多线程与异步操作","slug":"C Sharp多线程与异步操作","date":"2020-03-31T15:16:00.000Z","updated":"2020-06-13T15:15:55.104Z","comments":true,"path":"2020/03/31/C Sharp多线程与异步操作/","link":"","permalink":"https://weimingjuncn.github.io/2020/03/31/C%20Sharp%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/","excerpt":"什么是线程？为什么使用线程？线程的使用、线程池、任务、委托异步执行、Thread类、Task类","text":"什么是线程？为什么使用线程？线程的使用、线程池、任务、委托异步执行、Thread类、Task类 一、线程基础为什么使用线程？ 将某段代码同其他低吗隔离，提高应用程序可靠性。 简化代码。 实现并发执行 什么是并发执行？ … 什么是线程？1. 进程与线程进程是操作系统执行程序的基本单位，拥有应用程序的资源。 （例：一个应用程序的一次运行。） 进程包含线程，进程的资源被线程共享，线程不拥有资源。 （一个进程包含很多线程。） 2. 前台线程和后台线程通过Thread类新建线程默认为前台线程。当所有前台线程关闭时，所有的后台线程也会被直接终止，不会抛出异常。 3. 挂起（Suspend）和唤醒（Resume）由于线程的执行顺序和程序的执行情况不可预知所以使用挂起和唤醒容易发生死锁的情况，在实际应用中应该尽量少用。 4. 阻塞线程Join，阻塞调用线程，直到该线程终止。 5. 终止线程Abort：抛出ThreadAbortException异常让线程终止，终止后的线程不可以唤醒。 Interrupt：抛出ThreadInterruptException异常让线程终止，通过捕获异常可以继续执行。 6. 线程优先级AbortNormal、BelowNormal、Highest、Lowest、Normal，默认为Normal。 线程的使用线程函数通过委托传递，可以不带参数，也可以带参数（只能有一个参数），可以用一个类或结构体封装参数。 123456789101112131415161718192021222324using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;namespace TheardTest&#123; class Program &#123; static void Main(string[] args) &#123; Thread t = new Thread(Run); t.Start(); &#125; static void Run() &#123; while(true) &#123; Console.WriteLine(\"aaa\"); &#125; &#125; &#125;&#125; 线程池任务委托异步执行二、线程同步原子操作（Interlocked）lock()语句Monitor实现线程同步ReaderWriterLock事件（Event）类实现同步信号量（Semaphore）互斥体（Mutex）跨进程间的同步多线程处理的作用： 实现多任务。 解决延迟。 多线程应用：计算量大的场景、计算时长久的业务，比如LOL中的战争迷雾，它需要算很多可视化和迷雾单位，需要独立的线程进行计算。 在LOL中，每个正在战斗的房间，底层也是要求相互独立，可并行的，所以也需要多线程的支持。 每次打开王者荣耀，要更新很多内容，如果不使用多线程下载更新，速度会更慢。 其他 有关线程的对象：Thread（.net 4.0）、Task （.net 4.0之后） 线程同步保证数据的可靠性 Thread 创建线程 构建Thread实例，参数需要指定一个方法 通过Start方法开始执行线程 如果需要给方法传递参数，则使用匿名函数( ) =&gt; { } 如果有返回值怎么办？定义变量进行接收 暂停线程 通过Thread实例调用Join，可以阻止其他线程的调用，直到由该实例表示的线程终止 线程实例.Join(); 可以传递一个参数，表示最长阻塞多长时间的（单位：毫秒） 计时等待 Thread.Sleep()让线程休眠一段时间 通过静态方法可以让当前的线程等待一定的时间，由参数决定等待的时间（单位：毫秒） 它只影响当前执行的线程，其他线程依旧会执行 终止线程 Thread.Abort(); 该方法终止方式是对线程进行销毁，它适用于当线程要关闭的时候进行调度，能够保证线程程序关闭，线程也被销毁 其他地方尽可能不要用，有其他方式，比如用在线程内部用了lock语句，那么强制关闭线程回导致lock失效从而可能影响计算结果 通过信号控制线程的暂停执行和继续执行 ManualResetEvent 检测线程状态 thread.ThreadState 前台线程和后台线程 后台线程程序停止后可能还会继续执行 前台线程程序停止都会停止掉左右前台线程，线程默认都是前台线程 访问当前线程 Thread.CurrentThread.ManagedThreadId 例1本例包含：线程的创建、启动、阻塞（等待）、休眠、终止 IDE：VS 2017 创建项目类型：控制台应用(.NET Framework) 项目名：Project_Thread Program.cs代码如下： 12345678910111213141516171819using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Thread&#123; class Program &#123; static void Main(string[] args) &#123; ThreadDemo threadDemo = new ThreadDemo();//实例化ThreadDemo threadDemo.Start();//启动三个任务：Thread01,Thread02,Thread03 &#125; &#125;&#125; 在项目中新建一个类，取名为ThreadDemo ThreadDemo.cs代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace Project_Thread&#123; class ThreadDemo &#123; public void Start() &#123; //多个线程，可以同时执行不同的任务，减少 //通过线程调用方法 Thread t1 = new Thread(Thread01); t1.Start(); Thread t2 = new Thread(Thread02); t2.Start(); Thread t3 = new Thread(Thread03); t3.Start(); int count = 0;//局部变量 Thread t4 = new Thread(()=&gt; &#123; count=Thread04(500); &#125;);//用匿名方法传递参数 t4.Start(); //等待线程执行完毕 t4.Join(); /*************以下代码块是有关进程的终止**********/ Console.WriteLine(t4.ThreadState);//访问进程t4的当前状态 try &#123; t4.Abort();//终止线程，通过抛异常的形式销毁线程 Console.WriteLine(t4.ThreadState);//访问进程t4的当前状态 &#125; catch (Exception e)//捕获异常 &#123; Console.WriteLine(e);//打印异常信息 &#125; /********************************************/ Console.WriteLine(\"count是多少：\" + count); &#125; public void Thread01() &#123; for(int i=0; i&lt;100; i++) &#123; //Thread.Sleep(1000); //当前进程休眠1000ms（1s） Console.WriteLine(\"Thread01: \" + i); &#125; &#125; public void Thread02() &#123; for (int i = 0; i &lt; 100; i++) &#123; Console.WriteLine(\"Thread02: \" + i); &#125; &#125; public void Thread03() &#123; for (int i = 0; i &lt; 100; i++) &#123; Console.WriteLine(\"Thread03: \" + i); &#125; &#125; public int Thread04(int count) &#123; int _count = 0; for (int i = 0; i &lt; count; i++) &#123; _count++; Console.WriteLine(\"Thread04: \" + i); &#125; return _count; &#125; &#125;&#125; 例2本例包含暂停执行、继续执行 给项目新建一个类，取名为ManualResetEventDemo ManualResetEventDemo.cs内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;namespace Project_Thread&#123; //通过信号的形式控制线程的暂停与继续 class ManualResetEventDemo &#123; //停止信号 ManualResetEvent mr = new ManualResetEvent(true); public ManualResetEventDemo() &#123; Thread t = new Thread(Thread01); t.IsBackground = false;//false前台线程， true后台线程 //基本不会用到这个属性 软件开发可能用到比较多 //前台线程会在应用程序关闭的时候全部停止掉，后台线程在程序执行完之前不会停止。 t.Start(); Start(); &#125; public void Start() &#123; //发送一个让线程继续执行的信号 mr.Set();//继续 &#125; public void Stop() &#123; mr.Reset(); &#125; public void Thread01() &#123; Thread.Sleep(3000); int i = 0; while (true) &#123; mr.WaitOne(); //线程ID是系统自动分配的；每次都是不同的ID, 每个线程的ID唯一。 Console.WriteLine(\"线程的ID: \" + Thread.CurrentThread.ManagedThreadId); i++; Console.WriteLine(\"i的值：\" + i); Thread.Sleep(3000); &#125; &#125; &#125;&#125; 修改Program.cs如下： 12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Thread&#123; class Program &#123; static void Main(string[] args) &#123; //ThreadDemo threadDemo = new ThreadDemo();//实例化ThreadDemo //threadDemo.Start();//启动三个任务：Thread01,Thread02,Thread03 ManualResetEventDemo mre = new ManualResetEventDemo(); Console.WriteLine(\"输入 start:继续执行线程 stop:停止线程\"); while (true) &#123; string s = Console.ReadLine(); if(s == \"start\") &#123; mre.Start(); &#125; else if(s == \"stop\") &#123; mre.Stop(); &#125; &#125; &#125; &#125;&#125; Task.net4.0之后推出，.net4.5又开放了更多接口 创建任务 接收返回值 计时等待 等待任务执行完毕 取消任务 CancellationToken bool标志位 自定义逻辑 进行内部控制 例1（创建、接收返回值，阻塞）通过VS 2017创建C#控制台应用项目Project_Task，新建一个类TaskDemo，编辑TaskDemo.cs如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Task&#123; class TaskDemo &#123; public void Start() &#123; //开始执行三个任务 Task.Run((Action)Task01); //Run有多个重载方法，因此参数前要加上(Action)，指定只需要一个Action参数的Run方法 Task.Run((Action)Task02); Task.Run((Action)Task03); Task t4 = Task.Run(() =&gt; &#123;//用匿名方法传递参数 mCount = Task04(10); &#125;); //线程等待，等待线程的执行完毕 t4.Wait(); Console.WriteLine(\"COUNT: \" + mCount); &#125; public int mCount = 0; private int Task04(int count) &#123; int _count = 0; for (int i = 0; i &lt; count; i++) &#123; _count++; Console.WriteLine(\"Task04: \" + i); &#125;; return _count; &#125; private void Task03() &#123; for (int i = 0; i &lt; 8; i++) &#123; Console.WriteLine(\"Task03: \" + i); &#125;; &#125; private void Task02() &#123; for (int i = 0; i &lt; 8; i++) &#123; Console.WriteLine(\"Task02: \" + i); &#125; &#125; private void Task01() &#123; for(int i = 0; i &lt; 8; i++) &#123; Console.WriteLine(\"Task01: \" + i); &#125; &#125; &#125;&#125; 编辑Program.cs如下： 12345678910111213141516171819using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Task&#123; class Program &#123; static void Main(string[] args) &#123; TaskDemo taskDemo = new TaskDemo(); taskDemo.Start(); Console.ReadKey();//等待用户输入，阻塞程序，以便线程都工作完毕。 &#125; &#125;&#125; 程序运行结果如下： 例2（计时等待）修改TaskDemo.cs如下： 1234567891011121314151617181920212223242526using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Project_Task&#123; class TaskDemo &#123; public void Start() &#123; Task.Run((Action)Task05); &#125; private async void Task05() &#123; while (true) &#123; Console.WriteLine(\"Task05执行中...\"); //Task.Delay 可以执行一个延时的操作 await Task.Delay(1000);//单位毫秒 1000ms = 1s &#125; &#125; &#125;&#125; 运行后控制台每隔1秒打印一次“Task05执行中…” 例3（取消任务）","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"PluralSight课程：游戏机制设计基础","slug":"PluralSight课程：游戏机制设计基础","date":"2020-02-24T10:19:24.000Z","updated":"2020-03-14T07:36:38.180Z","comments":true,"path":"2020/02/24/PluralSight课程：游戏机制设计基础/","link":"","permalink":"https://weimingjuncn.github.io/2020/02/24/PluralSight%E8%AF%BE%E7%A8%8B%EF%BC%9A%E6%B8%B8%E6%88%8F%E6%9C%BA%E5%88%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"","categories":[],"tags":[{"name":"Game Design","slug":"Game-Design","permalink":"https://weimingjuncn.github.io/tags/Game-Design/"}]},{"title":"Unity动画基础","slug":"Unity动画基础","date":"2020-02-23T14:36:46.000Z","updated":"2020-06-13T08:53:37.123Z","comments":true,"path":"2020/02/23/Unity动画基础/","link":"","permalink":"https://weimingjuncn.github.io/2020/02/23/Unity%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/","excerpt":"Unity版本：Unity 2017.4.35f1 Personal 导入资源包unity_animation_fundamentals_module_2_begin.unitypackage","text":"Unity版本：Unity 2017.4.35f1 Personal 导入资源包unity_animation_fundamentals_module_2_begin.unitypackage 一、Animator（动画控制器）创建动画片段在Assets/Animations下新建Animation，命名为Chest_Open。 在菜单栏 &gt; Window &gt; Animation打开动画窗口。 找到选中场景中的Chest，在Animation窗口点击Create按钮在弹出的窗口中选中Open_Chest.anim点击保存。 在窗口中默认提供60帧，我们修改成30帧 展开Chest选中chest_top，在Animation窗口点击Add Property，展开chest_top &gt; Transform，点击Rotation右边的加号。 此时我们在动画起始和末尾各创建了一个关键帧，我们将白线拖动到最后一帧，然后点击记录按钮。 修改chest_top的Rotation的x为-130，再点击记录按钮关闭记录，这时我们点击Animation窗口的播放按钮，Scene窗口将循环播放Chest打开的动画。 如图操作，点击Clips列表，添加新的动画Clip，命名为Chest_Close 点击Clips列表，可改变当前要编辑的Clip. 点击Add Property，选中chest_top &gt; Transform &gt; Rotation。 使用动画曲线保持Chest被选中，点击Animation窗口下的Curves按钮，打开动画曲线界面， 重新定时动画使用动画事件将动画光标移动到箱子完全打开的关键帧位置，点击添加动画事件按钮。 此时Inpsector面板出现动画事件函数设置。我们在Hierarchy选中Chest，为其添加组件Treasure Chest(Script)。 为Chest添加空的子GameObject并重命名为Spawner。将其拖拽添加到Chest的Treasure Chest(Script)组件下Spawner属性。从Assets/Prefabs下拖拽Coin到Chest的Treasure Chest(Script)组件下Coin Prefab属性。我们双击该组件下的Script属性打开脚本文件，在其中我们发现有一个OpenChest方法。 回到Unity，在Animation窗口点击刚才添加的动画事件标记，在Inspector窗口的动画事件函数选项里我们有3种函数可以选择。选择OpenChest，这个函数就与动画事件关联上了。当我们播放游戏时，开箱动画播放到完全打开关键帧时将自动触发动画事件，调用OpenChest函数，弹出硬币。 创建多个剪辑首先为Chest_Close添加属性Rotation，通过Ctrl+C/V将Chest_Open的关键帧复制粘贴到Chest_Close里。 在Chest_Close里，将首尾两个关键帧交换位置，然后调整其动画曲线。 Animator视窗里的基本操作如果我们有多个动画片段，需要管理它们，甚至在一个动画到下一个动画之间转换，需要使用动画控制器。这是一个可以与动画组件一起使用的游戏Assets。当我们创建动画片段时，Unity会自动创建一个动画控制器，该动画控制器需要设置动画的控制参数。 双击动画控制器，打开Animation窗口 在Animation窗口中，我们看到四个节点，按住鼠标中键可以移动观图视角 Any State：特殊节点，允许中断正在播放的当前状态或正在播放以退出并进入另一个状态的当前动画。例如，当玩家的生命值降低到零，玩家处于生命状态并不重要，它将转到死亡动画。 Entry：任何游戏开始或基础层上的特殊状态机的开始，将进入的第一个默认状态/默认动画。 Exit：特殊节点，表明状态机应该退出。 Chest_Open状态是橙色的，代表默认状态，表示这个动画将在游戏开始后立即播放。如果我们希望箱子在游戏开始时时保持关闭状态，我们需要先创建一个空状态。在Animator视窗空白处右键选择Create State|Empty，重命名为Chest_Idle，且它的Motion设为None。 然后选中Chest_Idle右键选择Set as Layer Default State。此时播放动画，Chest保持关闭状态。 我们要箱子从Chest_Idle转变到Chest_Open状态，可以先右键Chest_Idle，选择Make Transition，然后点击Chest_Open，这样一个过渡箭头将两个状态连接起来。 选中这个过渡箭头，我们可以在Inspector里设置过渡条件。通常我们会取消勾选Has Exit Time，并确保下方的Condition里设置了条件。 参数和条件接下来我们将使用Condition（条件），条件在Animator视窗左边的Parameter（参数）视窗里创建。点击加号，我们可以看到有四种数据类型参数供选择，我们这次选择创建Bool（布尔类型）参数，并重命名为isOpen。我们将利用这个参数来控制箱子的开关，默认值设为false。 然后选中Chest_Idle到Chest_Open的过渡箭头，在Conditions点击加号，设置isOpen为true。 同理，我们将Chest_Open到Chest_Close之间的相互过渡也做条件设置，开箱到关箱的条件是isOpen为false，关箱到开箱的条件为true，记得都取消勾选Has Exit Time。 脚本控制条件参数打开Assets/Scripts下的TreasureChest.cs，以下只展示部分关键代码（重点看Update方法）： 1234567891011121314151617181920212223242526272829using System.Collections;using System.Collections.Generic;using UnityEngine;public class TreasureChest : MonoBehaviour&#123; public bool interactable = false; public bool isOpen = false; private Animator anim; public Rigidbody coinPrefab; public Transform spawner; // Use this for initialization void Start () &#123; anim = GetComponent&lt;Animator&gt;(); &#125; // Update is called once per frame void Update () &#123; if(Input.GetKeyDown(KeyCode.Space)) &#123; isOpen = !isOpen; anim.SetBool(\"isOpen\", isOpen); &#125; &#125;...&#125; 然后回到Unity，将Animations文件夹下的Chest_Close、Chest_Open的Loop Time取消勾选，不让其循环播放动画剪辑。 然后保存，播放场景，箱子一开始是关闭的，按空格键箱子打开，再按一次空格键箱子关闭。 二、Maya导出动画用Maya 2018打开资料里Referenced Files里的rig_DwarfHero_root_motion.ma。 三、导入设置回到Unity，选中Assets/Mesh/dwarf_hero，Inspector视窗里选中Model，取消勾选Import Visibility、Import Cameras、Import Lights，其他保持默认，点击Materials，勾选Import Materials，点击Apply。此时可见素材的材质得到了应用。 点击Rig，Animation Type默认设置为Generic。此项可以可选的值有： None：一般用于箱子、机关门等，因为他们没有骨骼。 Legacy：专用功能，用于兼容老版本Unity 5项目。 Generic：基于骨骼创建avatar，没有人形的特征。 Humanoid：用于将已有的动画重新用在多个角色人物上。 这里我们将Animation Type设为Humanoid，Avatar Definition设置为Create From This Mode，点击Apply，点击Configure，选择保存当前场景，进入到角色的临时场景，角色处于T形姿势，方便在骨骼上绑定其他物品。 通过Inspector视窗我们可以定位骨骼关节并在场景窗口中改变骨骼布局。 Mapping中的点，外圈是实线环的是必要节点，外边是虚线环的是可选节点。 因为这个案例中的骨骼健壮性很强，所以在Unity中都自动映射好了。要使用Unity的自动映射，我们可以点击Mapping，选择Automap。 或者可以选择Clear，自己手动一个一个映射。 我们可以更改角色的姿势，点击Pose。当前我们使用的是Enforce T-Pose，如果选择Sample Blind-Pose则转为角色的原始姿势 保持T-Pose，点击Apply应用设置。 骨骼设置好后，点击Muscles&amp;Settings进行肌肉设置。 肌肉并非必要的设置项，它只是为骨骼设置运动范围。通过Musles Group Preview可以很好地了解角色的运动方式以及如何重定位角色的其他动画。例如，我们可以调节Open Close来调整骨骼的打开和关闭状态。 通过Per-Muscle Settings，我们可以对具体的骨骼本身进行运动范围的修改。例如我们要将body伸展开，调节时会有特定的范围。我们放大会看到扇形的范围区。 此时spine Front-Back处于最大值，对应骨骼处在扇形的边缘，我们可以调节下方的滑块的两端来调整活动范围最大值或最小值，可以看到扇形的大小也顺便改变了。 本案例的默认设定已经满足学习，我们可以点击Revert重置会默认设定，接着点击Done返回游戏场景。 那么我们使用humanoid类型有什么意义？ 因为我们使用的动画可能来源各异，可能来自动作捕捉，可能来自Unity资源商店。humanoid类型提供很大的灵活性，方便我们使用不同的动画，提高开发效率。 四、导入动画剪辑动画剪辑已经导入，我们先修改设置。先选中Animations文件夹下的anm_dwarfHero_idle、anm_dwarfHero_jump、anm_dwarfHero_run、anm_dwarfHero_walk动画，然后转到Model设置界面。 取消勾选Import Visibility、Import Cameras、Import Lights、Import Matrtials。因为我们不需要任何额外的东西，我们并不真正需要动画剪辑材料。 点击Rig将Animation Type设为Humanoid。现在我们可以继续为每个动画剪辑创建新的avatar，但没有多大作用，特别是我们将要用于重新定向。因此如果我们使用同一类型模型同一设置，只需将Avatar Definition设置为Copy From Other Avatar，然后在下方Source设置准备好的Avatar。这里我们设置上dwarf_heroAvatar，然后点击Apply。 在Import Messages那会出现警告消息：我们重新定向的质量可能较低，因为我们没有在人形动画的Spine_1节点，实际上这属于正常情况。 然后我们选中Project视窗里的anm_dwarfHero_idle，在Inspector里点击Animation设置动画剪辑，将Loop Time勾选上，这将可以让闲置动画循环播放。下方的Loop Pose的作用是，如果动画中角色的骨骼或角色的根节点在动画开始和结束的位置存在偏差，Loop Pose将使这个衔接变得自然。在这里，loop match右边的灯是绿色的，表示衔接良好，所以我们无需勾选Loop Pose。 下方的Root Transform Rotation控制角色整体的根节点的转向。 如果我们将其下的Based Upon设置为Body Orientation，则方向箭头会指向了Z轴。设置回Original。 Root Transform Position(Y)可以控制角色的上下移动，如控制角色飞行。 在Additive Reference Pose下方有一个指示平均速率（Average Velocity）的消息。下图中，XZ方向上的速度均为0，Y方向上的速度为0.001。0.001虽然是个很小的数，但是如果控制角色移动足够远则会发现角色走到了半空中。 要解决这个问题，我们勾选Root Transform Position(Y)下的Bake Into Pose，将Based Upon (at Start)设置为Original或Feet，然后点击Apply。 五、根动作（Root motion)接下来我们使用根动作让我们的角色向前行走。我们选中一个已经应用了根动作的动画剪辑anm_dwarfHero_walk。当我们播放该动画时，角色的根节点将自动被检测并随着行走动画，改变根节点的坐标，从而驱使角色向前移动。角色移动的速度受动画控制，从而避免了滑行（即角色的脚步与角色的速度不同步）。 让我们暂停动画进行设置，首先勾选上Loop Time。注意到Root Transform Position(XZ)的loop match为红灯，表示动画循环没有匹配良好。可以知道的是我们的角色移动在XZ方向上有偏差。造成偏差的原因是在用Maya制作此动画剪辑时，角色向前迈步，XZ方向上一定会有位移，动画首尾坐标不一致。这属于正常现象，我们需要解决的是不让角色速度方向有偏差。 我们先勾选上Root Transform Rotation的Bake Into Pose，此举可以将角色在Y方向上的平均角速度变为0，从转向上消除偏差。 接着我们勾选Loop Time下边的Loop Pose。将Root Transform Rotation的Based Upon设为Body Orientation。改变Root Transform Rotation的Offset值，直到平均速度的X分量为0。 然后勾选Root Transform Position(Y)的Bake Into Pose，然后设置Based Upon (at Start)为Feet。 设置Root Transform Position(XZ)的Based Upon为Center of Mass 然后点击Apply，一个行走动画就基本调成完成。 接着我们用同样的步骤调整anm_dwarfHero_run 六、调整非人型rig的骨骼角色可能带有多余的骨骼，比如英雄肩膀上的一个护甲也绑定上了骨骼，但人型rig并不会检测到这种骨骼的存在。 让我们选中项目窗口Animation文件夹下的anm_DwarfHero_Attack03动画，在这个动画中，角色的胡子和肩膀护甲并没有按预期活动。我们可以在Inspector里调整如下参数。 将Mask下的Definition设置为Create From This Model。 然后点开Transform，找到L_Pauldron_Jnt、R_Pauldron_Jnt、Beard_1_Jnt、grp_Beard_1_Con并将它们勾选上，点击Apply。 这时我们再播放动画，胡子和肩膀护甲都按预期进行了活动，而且其他anm_DwarfHero动画也同时得到了相同的调整。 七、角色动画准备工作首先从项目窗口中将Meshes文件夹下的dwarf_hero拖拽到场景中。然后给场景中的dwarf_hero添加Rigidbody组件、Capsule Collider组件。 然后设置胶囊碰撞体参数如下，以适配角色的身体。 然后给dwarf_hero设置动画控制器，我们在项目窗口Animations文件夹下右键新建Animator Controller，重命名为DwarfHero，然后拖拽到场景中的dwarf_hero的Animator组件|Controller。 然后勾选Rigidbody组件|Is Kinematic 然后进入Animator窗口，将Animations文件夹下的anm_dwarfHero_idle拖拽进来，让它成为角色的起始播放动画。 保存场景，此时我们如果点击播放游戏，则场景中的角色在进入游戏时将成功播放闲置动画。 八、设计动画逻辑在Assets/Scripts下有一个CharacterMovement.cs脚本。我们给场景中的dwarf_hero添加组件Character Movement (Script)。接着进入Animator窗口，将Animations文件夹下的anm_dwarfHero_run拖拽进来，然后选中之前添加的anm_dwarfHero_idle，右键选择Make Transition，再点击anm_dwarfHero_run将这两个动画剪辑用箭头连接起来。 然后选中连接箭头，创建Bool类型条件参数，重名命名为IsRunning 然后在转换关系（箭头）上添加条件IsRunning，并设置条件值为true。 然后我们在创建一个从run到idle的转换关系（箭头），设置条件为IsRunning为false。 双击用VS2017打开CharacterMovement.cs脚本，其中Animating函数是控制角色跑动的关键。float类型变量lh、lv分别表示手柄/键盘输入的水平方向数据和垂直方向数据，当他们全都为0时，bool类型变量running为true，但它俩其中一个不为0则running为false。 12345678910111213141516171819...void FixedUpdate()&#123; //Store input axes float lh = Input.GetAxisRaw(\"Horizontal\"); float lv = Input.GetAxisRaw (\"Vertical\"); Move (lh, lv); Animating(lh, lv);&#125;...void Animating(float lh, float lv)&#123; bool running = lh != 0f || lv != 0f; anim.SetBool (\"IsRunning\", running);&#125; 好，如果我们现在播放游戏，并用WASD控制角色跑动，我们会发现角色先滑行一段距离才开始跑动。 进入Animator窗口，选中idle到run的转变关系箭头，取消勾选Has Exit Time。同样地，run到idle的转变关系箭头也这么修改。 Has Exit Time如果被勾选，则角色将在转变前的动画播放完毕才开始转变到下一个动画，取消勾选可以打断等待，让转变立刻发生。 九、混合树（Blend Tree）首先我们给场景中的dwarf_hero添加Nav Mesh Agent组件，并做如下参数设置。 接着添加World Interaction、Locomotion Agent两个脚本组件。World Interaction脚本让我们可以通过鼠标点击场景控制角色行动Locomotion Agen脚本不仅用于控制角色的动画还会更新Nav Mesh Agent以便适配角色的根动作（Root Motion） 回到Animator窗口，删掉之前添加进来的idle和run动画剪辑，右键选择Create State|From New Blend Tree新建混合树，重命名为Locomotion 双击建好的Locomotion进入内部，将条件Blend重命名为PlayerVelocity 选中Blend Tree，在Inspector点击Motion下的加号添加要混合的动作。 依次添加动画剪辑idle、walk、run。 播放混合动画，当我们拖拽改变PlayerVelocity时，角色动作将发生变化。 我们可以通过脚本控制参数PlayerVelocity来控制这一动作变化。 用VS2017打开Locomotion.cs，在Update函数下的关键代码如下。 1234567void Update()&#123;... // Update animation parameters anim.SetFloat(\"PlayerVelocity\", agent.velocity.magnitude);...&#125; 回到Unity，注意到PlayerVelocity的可变范围是0到1，我们可以改变这个范围。 选中Blend Tree，取消勾选Automate Thresholds，并依次改变run、walk的阈值为8、2。 播放游戏，我们在控制角色的时候可以发现角色从闲置到奔跑有过渡，我们可以改变run、walk的阈值（比如分别为6、1）使这个过渡更加自然。 十、动画层在这个小节我们将使用动画层配置角色攻击动画。首先我们先将场景中的dwarf_hero的World Interaction、Locomotion Agent两个组件删掉，然后添加脚本组件Player Attack。 进入Animator窗口，点击Parameters左边的Layers，我们看到一个Base Layer。每一个Animator都有一个Base Layer，我们可以添加动画层，在另一个动画层上做攻击动画。 点击加号，新建一个动画层，重命名为Attack Layer。在Attack Layer里我们拖拽进Attack01动画剪辑，但我们不希望默认起始动画是攻击动画，于是我们右键Create State|Empty创建一个空状态（重命名为Empty），然后选中Empty状态右键|Set as Layer Default State设置为默认状态。 然后从空状态到Attack01建立一个转变关系，取消勾选Has Exit Time，设置Trigger类型条件IsAttacking。Trigger类型条件的原理是把条件变量IsAttacking赋值为true然后在赋值为false。 然后从Attack01到Empty之间在建立一个转变关系，勾选Has Exit Time，这样一来，Attack01动画播放完毕就可以回到Empty状态等待下次触发。 在Base Layer和Attack Layer右边有小齿轮按钮，点击可以看到更多设置。 其中Weight（权重）决定动画层的优先级。Base Layer一直在播放，因此它的Weight不可改变。当我们把Attack Layer的Weight改为1时，Attack Layer将根据Blending设置的Override，完全覆盖Base Layer，即只播放Attack Layer。如果把Blending设置为Additive，Attack Layer将在Base Layer的基础上做变化。 保持Blending为Override，打开PlayerAttack.cs脚本 1234567891011...void Update ()&#123; if(Input.GetKeyDown(KeyCode.Mouse0)) &#123; anim.SetLayerWeight(1, 1f); anim.SetTrigger(\"IsAttacking\"); print(\"Attacking!\"); &#125;&#125;... 其中Update方法下的语句“anim.SetLayerWeight(1, 1f);’’SetLayerWeight传递Attack Layer的动画层索引1（Base Layer的索引是0）以及权重范围1f（表示范围是0~1）。然后”anim.SetTrigger(“IsAttacking”);“设置触发器”IsAttacking”。 播放游戏，一边控制角色跑动，一边按鼠标左键攻击，角色会在攻击的时候脚停止不动。 十一、动画遮罩（Avatar Mask）动画遮罩（Avatar Mask）用于混合动画层，让上一小节中角色的边跑边攻击动画没那么奇怪。 在Assets/Animations下右键新建|Avatar Mask，重命名为DwarfHero_LowerBody。选中DwarfHero_LowerBody，在Inspector里点开Humanoid，将需要遮挡住的部分点击变红，这里我们将双腿和根动作全部点红。因为我们要将攻击动画层中角色的下半身全部被Base Layer遮住。 接下来将这个遮罩应用到Attack Layer中。点击Attack Layer右边的小齿轮，点击Mask右边的小圆，在弹出的对话框中选择DwarfHero_LowerBody。 播放游戏，角色可以一边跑动一边攻击，脚步不停了。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"Unity 2018 UI基础","slug":"Unity 2018 UI基础","date":"2020-02-19T11:17:46.000Z","updated":"2020-04-06T12:09:41.176Z","comments":true,"path":"2020/02/19/Unity 2018 UI基础/","link":"","permalink":"https://weimingjuncn.github.io/2020/02/19/Unity%202018%20UI%E5%9F%BA%E7%A1%80/","excerpt":"三种画布的添加 不同分辨率的屏幕 文本组件","text":"三种画布的添加 不同分辨率的屏幕 文本组件 Unity版本：Unity 2018.4.13c1 Personal Interface Type 交互界面类型 Diegetic(剧情的，故事内的)：存档点 Spatial(受空间条件限制的)：高亮任务NPC或其他玩家，或玩家自己 Meta：有写摄像机玩家察觉不到，但开发者知道 Non-Diegetic ：打分面板 Canvas Type画布类型 Screen Space Overlay：在场景顶层，HUD，用于标识角色状态等信息 Screen Space Camera： World Space： Interface Type Use Canvas Type Overlay用于做No-diegetic UI Camera用于做No-diegetic &amp; diegetic UI World用于做diegetic UI What is HUD ? HUD - Head-Up Display HUD或状态条是游戏UI中视觉传达玩家信息的一种交互方式。 导入资源包 新建好项目后，导入ui-fundamentals-2018.unitypackage，进入Scenes文件件，双击打开UIScene 一、三种画布的添加1. Overlay新建一个新场景，菜单栏GameObject &gt; UI &gt; Canvas，在其组件Canvas &gt; Render Mode选中Screen Space - Overlay。 在Canvas下新建一个Cube，但我们却无法在Game视窗看到Cube，无论Cube调整到多大。这就是Overlay型画布。我们可以看见在其上边放置的二维图片，文本，和一些可以互动的东西比如按钮，而三维模型无法看到。 接着我们在Cube下新建一个UI &gt; Button，通过Game视窗，我们看到一个显示在画布上的按钮。 想要看到那个Cube，需要将其放置在摄像机的视野中，我们将Cube位置重置，接着将Cube向Z轴正方向移动5个单位长度，使其正好在Main Camera正前方，此时我们得以在Game视窗中看到Cube，注意这个Cube不在画布上。 2. Camera我们将Carves的Render Mode改成Screen Space - Camera，此时Render Camera没有指定，我们将Main Camera拖拽过去添加上。这时候我们发现Game视窗下的按钮消失了，我们选中Main Camera，将其Camera &gt; Clipping Planes Far由原来的10改成100或1000此时我们又看到了button，或者不改变摄像机的可视范围，将Canves的Plane Distance(平面距离)改为5，即把画布移到摄像机的可视范围内，也同样在Game视窗中显示button。 3. World Space我们将Canves的Render Mode改为World Space。将Cube拖拽到Main Camera的子系。 接下来我们将按钮Y方向旋转一定角度。 再看Game视窗，可以看到倾斜的按钮 二、不同的分辨率的屏幕1. 高分辨率PC游戏2. HTML5网页大小3. 移动设备横屏与竖屏File &gt; Build Settings，默认是选择PC平台 三、文本组件打开UIStart场景，选中03-Responsive，在菜单栏GameObject下选择UI &gt; Text","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"Unity载入界面基础","slug":"Unity载入界面基础","date":"2020-02-17T14:49:42.000Z","updated":"2020-04-06T12:10:32.482Z","comments":true,"path":"2020/02/17/Unity载入界面基础/","link":"","permalink":"https://weimingjuncn.github.io/2020/02/17/Unity%E8%BD%BD%E5%85%A5%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/","excerpt":"创建用户界面元素 编写场景切换脚本","text":"创建用户界面元素 编写场景切换脚本 Unity 版本：Unity 2018.4.13c1 Personal 一、创建用户界面元素新建一个场景，命名为MainMenu。删掉Directioinal light，切换为2D视角。 再Lighting窗口，设置Scene &gt; Environment &gt; Environment Lighting &gt; Source为Color，Amibient Color为黑色，Skybox material设置为None(Material)。 再Hierarchy窗口创建 &gt; UI &gt; Canvas 再Game窗口下把分辨率由Free Aspect改为16：9 再Canvas下新建 &gt; UI &gt; Text - TextMeshPro，首次新建会弹出导入TMP必备窗口，点击Import TMP Essentials，导入完成后关闭窗口即可。 然后重命名TextMeshPro为TitleText，再其Text Mesh Pro UGUI(Script)组件 &gt; Text自定义文本写上游戏名“Sword and Shovels”，在该组件 &gt; Main Settings可以修改字体。我们勾选Font Size &gt; Auto Size，这时字体大小将随文本框大小改变而自动调节。通过Aligment右边的按钮可以调节文本对齐居中等。 再Canves下新建 &gt; UI &gt; Button，将Button下的Text删掉，再Button下新建Text - TextMeshPro，调整好之后如下图： 播放游戏，画面中Play按钮可以点击。 二、编写场景切换脚本再Hirarchy窗口新建空Game Object，重命名为SceneSwitcher。再Assest/Scripts下新建SceneSwitcher.cs，用VS2017打开，编写代码如下： 123456789101112using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.SceneManagement;public class SceneSwitcher : MonoBehaviour&#123; public void SceneSwitch() &#123; SceneManager.LoadScene(1); &#125;&#125; 回到Unity，给SceneSwitcher添加Scene Switcher(Script)组件。 选中Canvas/Button，在On Click()下添加点击事件，将SceneSwitcher拖拽进来，函数选择SceneSwitcher &gt; SceneSwitch()。 保存MainMenu场景，然后点击菜单栏File &gt; Build Settings，在Build Settings弹窗点击Add Open Scenes把MainMenu添加进去，然后将Assets/Scenes下建好的Main01场景拖拽添加进来。 播放游戏，开始进入MainMenu场景，当我们点击Play后，进入Main01场景。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"PluralSight谈游戏设计基础","slug":"PluralSight课程：游戏设计基础","date":"2020-02-16T13:24:33.000Z","updated":"2020-04-06T12:14:12.912Z","comments":true,"path":"2020/02/16/PluralSight课程：游戏设计基础/","link":"","permalink":"https://weimingjuncn.github.io/2020/02/16/PluralSight%E8%AF%BE%E7%A8%8B%EF%BC%9A%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","excerpt":"12 parts in total.","text":"12 parts in total. 1. From Idea to Game Visionwriting an idea down, extends the ideas lifespan. Vision — A vivid, imaginative concept to drive your direction. 2. Communicating Your IdeaCommunicating your game’s vision with confidence is key. 3. Going to the Game PremiseYour game premise should be one Action-Packed sentence describing the user’s experience. for example, Swords and Shovels is a light-hearted, action-packed, 2D, top-down dungeon crawler. Alone dwarf and his trusty warthog explore an abandoned mine to seek our glory, riches and loot while avoiding the nightmarish creatures below. 4. Evolving Your Idea5. Thinking About the Game Core MechanicsThings to avoid Generalizations Words without meaning 6. Summary Ideas are small Turn your idea into an action-packed premise Get feedback from the RIGHT people Identify Core Mechanics 7. Managing the Scope of the Project8. Defining SMART Goals for Your Game9. Creating a Schedule for Your Game Project10. Creating Achievable Time Estimates11. Think of the Gameplay12. Creating the Pitch","categories":[],"tags":[{"name":"Game Design","slug":"Game-Design","permalink":"https://weimingjuncn.github.io/tags/Game-Design/"}]},{"title":"Unity简易角色开发","slug":"Unity简易角色开发","date":"2020-02-16T03:45:20.000Z","updated":"2020-06-10T05:26:16.385Z","comments":true,"path":"2020/02/16/Unity简易角色开发/","link":"","permalink":"https://weimingjuncn.github.io/2020/02/16/Unity%E7%AE%80%E6%98%93%E8%A7%92%E8%89%B2%E5%BC%80%E5%8F%91/","excerpt":"建立角色 动画控制器 给角色添加组件 使用Cinemachine 打包生成游戏","text":"建立角色 动画控制器 给角色添加组件 使用Cinemachine 打包生成游戏 Unity版本：Unity 2018.4.13c1 Personal 一、建立角色从Unity Assets\\Unity Fundamentals Source Assets\\Character导入Characters.unitypackage 再Assets/Models/Hero/Models/Hero/FBX下将Hero_Low拖拽到场景中，给Hero_Low添加Player Controller(Script)组件，Nav Mesh Agent组件并修改Radius为0.4，Height为1.6。设置Hero_Low的Tag为Player，Layer为Player。 再Hierarchy窗口添加空Game Object，命名为MouseManager，为其添加Mouse Manager(Script)组件，Clickable Layer设置为Clickable，并添加鼠标材质： 添加鼠标点击事件，添加上时间Object拖入Hero_Low，函数选择NavMeshAgent &gt; destination 创建一个空物体，命名为NavMeshSurface，并为其添加NavMeshSurface（Script）组件 Agent Type: Open Agent Settings &gt; Radius: 0.4, Height: 1.6。回到Inspector点击Bake。注意到中间木桥处有断开，我们可以在木桥处放一个Cube,并将其Layer设置为Clickable，角色可以走动的地面均选中并将Layer设置为Clickable，然后重新烘焙NavMeshSurface。 NavMeshSurface连成一块后，把Cube Disable掉即可。 这时我们可以播放游戏看看角色是否可以走过去了。 二、动画控制器在Assets下新建一个Animations文件夹，在Assets/Animations下新建一个Animation Controller，取名为Hero_Alt，即Hero_Alt.controller文件，双击进入其Animator窗口，界面可以通过按住鼠标中键拖拽，滚动鼠标中键缩放。 Animator窗口 &gt; Base Layer下有三个状态：Any State, Entry, Exit。 Entry：初识状态，如角色闲置动画。 Any State：任何时候都可以转换到的状态，如角色死亡动画。 Exit：结束状态。 常用的是Entry和Any State状态。 在空白处右键Create State &gt; From New Blend Tree，将建好的Blend Tree重命名为Motion Tree，双击进入Motion Tree，将里边的Blend Tree重命名为Speed，Inspector &gt; Parameter重命名为Speed。点击下方的加号 &gt; Add Motion Field，然后给我们的Motion Field选择Motion：anm_dwarfHero_idle。同样的方法，我们再添加一个Motion Field，选择anm_dwarfHero_run 添加完两个要混合的动画，点击下方动画播放小窗口的播放按钮，此时播放的是闲置动画，当我们把Speed由0播放到1时，角色动画过渡到奔跑动画。 打开Assets/Scripts下的PlayerController.cs。保存代码如下： 123456789101112131415161718192021using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour&#123; private Animator anim; private NavMeshAgent agent; // Use this for initializtion void Awake() &#123; anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); &#125; void Update() &#123; anim.SetFloat(\"Speed\", agent.velocity.magnitude); &#125;&#125; 给角色的Animator组件 &gt; Controller添加RuntimeAnimatorController：Hero_Alt。 回到Animator窗口，给Parameter添加Speed参数 回到Scene窗口，点击Play，播放游戏。鼠标点击控制角色，我们的角色行动不在像尸体一样平移，而是有闲置动画，奔跑动画的移动。 三、给角色添加附件将Assets/Models/Hero/Models/Weapons/FBX下的LowpolySword添加到场景中，调整到合适的大小。 LowpolySword的全身是灰色的，我们需要更新材质。再Assets/Models/Hero/Models/Weapons/Materials下选中Sword.mat，锁定Inspector窗口，找到Assets/Models/Hero/Models/Weapons/Textures，将Sword Base Color.png、Sword Metalic.png、Sword Normal.png分别拖拽到Inspector &gt; Main Maps &gt; Albedo、Metalic、Mormal Map。将Main &gt; Smoothness调整到0.4。 我们将LowpolySword拖拽到Hero_Low/R_Wrist_Jnt下，然后将LowpolySword的位置旋转角度都归零，调整LowpolySword的角度，使LowpolySword看上去被正确地握在Hero_Low手中。 播放游戏，可以看到LowpolySword跟随Hero_Low的右手动画运动。 四、使用Cinemachine制作跟随镜头打开Unity菜单栏 &gt; Window &gt; Package Manager，安装Cinemachine插件。 完成安装后通过Unity菜单栏 &gt; Cinemachine &gt; Create Virtual Camera新建一个虚拟摄像机CM vcam1。 虚拟摄像机可以覆盖主摄像机的设置。 在Scene窗口下选择合适的观察角色的视角，选中CM vcam1，按快捷键Ctrl+Shift+F。 将Hero_Low拖拽到CM vcam1的Inspector &gt; Cinemachine Virtual Camera(Script) &gt; Follow和Look At Aim设置为Do nothing，Body选择Framing Transposer。 转到Game视窗，选中CM vcam1，可以看到画面分为三种区域： 中间区域（原本的颜色）：叫做死亡区域，LookAt的这个目标在这个区域内，摄像机是不会跟随的。蓝色区域：代表缓冲区域，此时摄像机会开始跟随，使目标在中间的透明区域。红色区域：不可到达区域，跟随过程中目标是不可能到达这些区域的。 我们可以拖动画面上的直线改变这三种区域的大小。 播放游戏，控制角色行走，摄像机跟随角色移动。 我们还可以给虚拟摄像机添加其他设置，例如Noice设置为Basic Muti Channel Perlin，Noice Profile设置为Handheld_normal_mild，Amplitude Gain和Frequency Gain均设置为0.5，这样一来游戏中摄像机就有了轻微的晃动。 五、打包生成游戏将场景保存好后，Unity菜单栏File &gt; Build Settings，确认所有场景都在Scene In Build，选择平台，按需要勾选是否创建VS解决方案或开发build。 点击Player Settings，在其Inspector面板我们可以修改游戏名称，公司名称，版本号，游戏图标，游戏中的鼠标材质等信息。这里我们添加了一个游戏鼠标材质，其他设置均默认，然后点击Build按钮选好路径生成游戏。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"Unity简易关卡设计","slug":"Unity简易关卡设计","date":"2020-02-13T07:35:25.000Z","updated":"2020-04-06T12:17:11.713Z","comments":true,"path":"2020/02/13/Unity简易关卡设计/","link":"","permalink":"https://weimingjuncn.github.io/2020/02/13/Unity%E7%AE%80%E6%98%93%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1/","excerpt":"ProBuilder和ProGirds 搭建关卡原型 …","text":"ProBuilder和ProGirds 搭建关卡原型 … Unity版本：Unity 2018.4.13c1 一、安装ProBuilder和ProGrids开始之前，新建一个场景命名为“Main”，在Assets文件夹下新建一个Prefabs文件夹用于存放预制体。 可以回到之前的SampleScene，将之前创建的Player,NPC逐一拖拽到Prefabs文件夹中。 回到场景Main，开始安装ProBuilder,ProGrids。 首先通过Unity编辑器的菜单栏上的Window，找到并点击打开Package Manager。 切换到All packages，找到ProBuilder，选中点击右侧页面中的Install。 我在Unity 2018.4.13c1 Perconal版本中没有找到ProGrid，需要在进入项目文件夹，在Packages文件夹中找到manifest.json文件，用Notepad++或写字板打开，在dependencies的花括号内添加”com.unity.progrids”: “3.0.3-preview.4”，注意末尾添加英文逗号，保存修改后，回到Unity编辑器会立刻自动安装ProGrids。 以上工具安装完成后，All packages切换到In packages，会找到已安装的工具。 关闭Package Manager，在Unity编辑器菜单栏的Tools，点击ProGrids&gt;ProGrids Window打开ProGrids工具窗口，点击ProBuilder&gt;ProBuilder Window打开ProBuilder工具面板，将其拖拽到和Inspector窗口并列。 二、搭建关卡原型点击New Shape右边的加号，Shape Selector选择Cube点击Build，如果不点击加号，会直接创建Cube。 将Cube位置设置为（0，0，0）。通过ProBuilder我们有4种选中方式来选中Cube。 面选中模式下，我们选中Cube的一个侧面，拖拽与选中面垂直的坐标方向，将Cube拓长12个单位长度。 然后用相同的方法，将Cube拓宽到8个单位长度。 切换到边选中模式，如图选中最中间的线，然后点击ProBuilder面板的Connect Edges。用同样的方法，将Cube划分为四等份。 然后在面选中模式下，我们通过Ctrl快捷键连续选中划分成四等份的侧面中间两份，按住Shift键拖拽拓长10个单位长度。 再次按住Shift继续拓长2个单位长度，再拓长10个长度。可以看到，停顿的地方会有分界线。 然后同时选中尾段（10个单位长度）的两侧，（此时如果坐标轴不在两个面的正中间就点击图中圈起来的Center按钮使坐标系处于正中间，）然后按【R】键切换到比例调节坐标系，使两侧拓宽2个单位长度。 放置阶梯： 最终完成关卡原型如下： 三、配置环境资产 导入文件 在Assets文件夹下新建文件夹Materials、Models、Textures，Models下新建文件夹Environment。 将Unity Fundamentals Source Assets\\Level Assets\\FBX下的所有文件导入到Assets\\Models\\Environment中。 将Unity Fundamentals Source Assets\\Level Assets\\Materials下的所有文件导入到Assets\\Materials中。 将Unity Fundamentals Source Assets\\Level Assets\\Textures下的所有文件导入到Assets\\Textures中。 以上文件由美术工作人员制作好。 调整材质 进入Materials,选中Banner，Shader选择Standard(Specular setup)，要批量改变Shader，则同时选中，然后再再Inspector面板里改Shader。此处我们把剩下的材质球全部选中把Shader设置为Standard(Specular setup)。 接下来选中Barriers，锁定Inspector面板，进入Texture文件夹，把Barriers 01 Diff.tga拖拽到Inspector面板下的Main Maps&gt;Albedo，Albedo指反射率贴图，主要体现模型的纹理和颜色。通常适合放入含有单词Albedo或BaseColor（少数情况Diff或Diffuse）的tga文件。 把Barriers 01 Spec.tga拖拽到Albedo下方的Specular，把Barriers 01 Norm.tga拖拽到Specular下方的Normal Map，把Barriers 01 occlusion.tga拖拽到Occlusion，把detail normal.png拖拽到Secondary Maps&gt;Normal Map。 同理把，把剩下的Bridge、Broken_Bridge、Door、Floor_01、Floor_04、Lantern、Pillar、Stairs、Statue、Wall_01、Wall_02、Wall_03、WoodenPlank全都配置好。其中Door的Emission&gt;Color需要放入Door 01 emiss.tga。 配置Banner有些不同，即将Flag 01 Diffuse.tga放到Albedo，Flag 01 normals.tga放到Normal Map，Flag 01 occulsion.tga放到Occlusion。 配置材质到模型 进入Models/Environment,选中Barrier 01.FB。在Inspector面板中点击Materials，勾选Import Materials，在Remapped Materials&gt;Standard_20 点击最右侧的圆圈按钮打开材质选择窗口，选择Barriers，点击Apply。 同理，把Barrie_02、Barrier_03、Bridge_01、Broken_Bridge_01、Broken_Bridge_02、Broken_Bridge_03、Broken_Bridge_04、Broken_Floor_01、Door_01、Door_02、Door_03、Door_04、Flag_01（用Banner）、Floor_01（用Floor_01）、Floor_02（用Floor_01）、Floor_03（用Floor_01）、Floor_04（用Floor_04）、Floor_05（用Floor_04）、Floor_06（用Floor_04）、Lantern、Pillar_01、Pillar_02、Pillar_03、Pillar_04、Stairs_01、Statue_01、Wall_01、Wall_02、Wall_03、Wooden_Plank_01、Wooden_Plank_02都配置好。 五、创建环境预制体六、照明菜单栏的Window &gt; Rendering &gt; Lighting Settings，打开Lighting窗口，拖拽并dock到Inspector窗口旁边。 修改Lighting窗口下的Skybox Material，将默认改成BlackSky，使环境全黑。 选中Directional Light，在其Inspector窗口 &gt; Light &gt; Color，将颜色自定义成淡蓝偏灰的颜色色（冷色）。 在场景中创建四个Point Light并把它们放置到关卡中四个Lantern上，把它们的颜色都设置成浅橙色（暖色）,调高Intensity，这里设置成3。Range（光照范围）设置为6。根据需要设置Shadow Type，这里设置为No Shadows。 烘焙照明，选中Environment，勾选其Inspector面板的Static，（如果询问是否改变子项，选择确认）。 来到Lighting窗口，确保Realtime Global Illumi勾选，Baked Global Illumi勾选，然后点击下方Generate Lighting按钮或者勾选Auto Generate。 等待一段时间直到烘培完成（烘培时间取决于计算机硬件性能）。减小Lightmapping Settiing &gt; Lightmap Size的大小可以稍微加快烘培速度（此处我设置为256）。 烘焙好照明后，我们给关卡添加Reflection Probe（Hierarchy窗口 &gt; Create &gt; Light &gt; Reflection Probe）。 调节大小至包围（捕获）地形如图： 通过快捷键Ctrl+D快速复制粘贴一份，然后拖动包围旁边的桥（Reflection Probe之间重叠也没关系） 然后再Lighting窗口 &gt; Other Setting &gt; Generate Light下三角 &gt; Bake Reflection Probes。烘焙Reflection Probes完成后地形的部分阴影会稍微变淡。 七、粒子系统创建粒子系统：Hierarchy &gt; Create &gt; Effects &gt; Particle System 详细调节： Inspector &gt; Particle System &gt; Particle System Duration: 1.50 Looping: ✔ Prewarm: ✔ Start Lifetime 点击右边小三角 &gt; Random Between Two Constants Start Lifetime: 10, 15 Start Speed: 0.1, 0.5（Random Between Two Constants） Start Size: 20, 30（Random Between Two Constants） Start Rotation: 0, 360（Random Between Two Constants） Start Color: 深蓝色 Max Particles: 100 点击Particle System可最小化，这时可以看到Emission, Shape等其他可调节项目。 Emssion:✔ Rate over Time: 30 Rate over Distance: 0 Shape:✔ Shape: Box Emit from: Volume Scale: X=125, Y=75, Z=10 设置好后调整粒子系统再场景中的位置使其笼罩整个地形 Color over Lifetime:✔ Color: Alpha=0, Location 100.0% 如果没有显示Alpha则，拖动一下第一排标尺。 Size over Lifetime:✔ Size：先将起点拖动到0.800，然后起点旁边的白点稍微往上拉一点。 点击曲线的另一端（红点），这时旁边出现一个白点，向上拉动，使红色曲线接近直线。 Rotation over Lifetime: ✔ Angular Veclocity: -5, 5 (Random Between Two Constants) Render: ✔ Normal Direction: 0.7 Assets/Materials下新建一个材质，取名GlobalFag，其Shader改成Legacy/Shaders/Particle/Additive(Soft)。 再Assets/Texture下导入Unity Fundamentals Source Assets\\Level Assets\\VFX下的ParticleCloudWhite.png，然后给GlobalFag的Texture选择ParticleCloudWhite。 回到Particle System，Renderer &gt; Material选择GlobalFag。 然后回到Lighting窗口点击Generate Lighting 八、创造光条纹Hierarchy &gt; Create &gt; Effects &gt; Line Line &gt; Inspector &gt; Line Render &gt; Cast Shadows改为Off。 再Assets/Material下新建材质，命名为Streak。 Streak &gt; Inspector &gt; Shader改为Legacy Shaders/Particles/Additive Particle Texture选择Default-Particle Line &gt; Inspector &gt; Line Renderer &gt; Positions &gt; Index 1 Z=25, 拖拽Width到10 修改颜色成由黑过渡到蓝 Line Renderer &gt; Materials &gt; Element 0改成Streak 给Line添加Light组件，并且将Light &gt; Type改成Spot Light &gt; Range设置为20，Color设置为浅蓝色，Intensity设置为接近接近20（这里设置为18.23），Cookie选择ParticleCloudWhite，Shadow Type设置为Hard Shadows 点击Cookie旁边的ParticleCloudWhite，再Assets/Textures找到ParticleCloudWhite，将其Advanced &gt; Wrap Mode改为Clamp 调整角度，使光照射再门上： 给Line改名为Moonlight，保存到Assets/Prefabs/VFX下（拖拽过去）。我们还可以给场景其他地方添加Moonlight: 九、创建环境音乐在场景中新建一个空Game Object，取名AudioManager，为其添加组件Audio Source。 在Assets文件夹下新建一个Audio文件夹，向里边导入Unity Fundamentals Source Assets\\Audio下的两个音频文件：ForestNight Amb Lp.wav、Torch Lp.wav 选中AudioManager，将ForestNight Amb Lp.wav添加到Audio Source组件 &gt; AudioClip，勾选Loop，稍微降低Volume（音量）。 播放游戏，可以听到环境音乐。 十、后期处理打开Unity菜单栏Window &gt; Package Manager，安装Post Processing插件。 在Hierarchy窗口新建一个空Game Object，命名为PostProcessing，为其添加组件Post Process Volume(Script)，勾选其属性Is Global（这个属性可以影响游戏整个画面），点击Profile旁边的New创建新的Profile。 给Main Camera添加组件Post Processing Layer(Script)，属性Anti-aliasing &gt; Mode设置为Fast Approximate Anti-aliasing(FXAA)。Main Camera的Layer设置为PostProcessing。 选中PostProcessing，Layer设置为PostProcessing，在其Post Processing Volume(Script)组件下点击Add effect &gt; Unity &gt; Vignette。展开Vignette，点击All勾选下方全部属性。从Game窗口观察游戏场景，当我们调解Vignette &gt; Intensity时，可以产生让我们的目光聚集在画面中央的效果。 点击Add effect按钮添加Unity &gt; Bloom，勾选其下方所有属性，观察Game画面适当调解Intensity。 点击Add effect按钮添加Unity &gt; Chromatic Aberration，勾选其下方所有属性，观察Game画面适当调解Intensity。 点击Add effect按钮添加Unity &gt; Color Grading，勾选其下方所有属性，观察Game画面适当调解Trackball以改变画面色调。 我们还可以添加Unity &gt; Grain，继续调解画面，这些后期处理可以改善游戏画面，但也会消耗计算机性能，移动端或低配PC不建议过多调节。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"Unity简易关卡原型开发","slug":"Unity简易关卡原型开发","date":"2020-02-07T09:03:06.000Z","updated":"2020-04-06T12:18:27.565Z","comments":true,"path":"2020/02/07/Unity简易关卡原型开发/","link":"","permalink":"https://weimingjuncn.github.io/2020/02/07/Unity%E7%AE%80%E6%98%93%E5%85%B3%E5%8D%A1%E5%8E%9F%E5%9E%8B%E5%BC%80%E5%8F%91/","excerpt":"编写鼠标交互脚本 使用NavMesh组件实现角色移动 …","text":"编写鼠标交互脚本 使用NavMesh组件实现角色移动 … Unity版本：Unity 2018.4.13c1 一、准备工作在一个新建的场景下新建一个Cube，调成Cube的大小，使之成为一个扁平面（Scale参考值：x=50，y=0.36，z=50），重命名为“Floor”，重置Floor的位置到（0，0，0）。 在Floor上方新建一个Capsule,调整大小致合适。 在Floor上方新建一个Cube,调整大小致门板的样子，重命名为“Door” 在场景里新建一个空Object，命名为“MouseManager”。 在项目面板的Assets文件夹下新建一个Materials文件夹，在其中新建一个材质，取名为Gray。将Gray的Inspector面板的MainMaps下把颜色设置成灰色。拖拽Gray致Floor上。 调整角度到可以同时看到Door、Capsule、Floor和环境的合适位置后，选中Main Camera，使用快捷键【Ctrl + Shift + F】将摄像机快速调整到满足当前观察视角的位置。 完成后如下图： 在Assets文件夹下新建一个名叫“Cursors”的文件夹，导入png图片素材如下图： 二、编写鼠标交互脚本在项目面板的Assets文件夹下新建一个名叫“Scripts”的文件夹，在其中新建一个C#脚本文件，取名为MouseManager 打开MouseManager.cs，编写代码并确定无错误后保存如下： 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public class MouseManager : MonoBehaviour&#123; //which objects are clickable public LayerMask clickableLayer; //Swap cursors per object public Texture2D pointer;//Normal Pointer public Texture2D target;//Cursors for clickable objects like world public Texture2D doorway;//Cursors for doorways public Texture2D combat;//Cursors for combat sections // Update is called once per frame void Update() &#123; RaycastHit hit; if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 50, clickableLayer.value)) &#123; bool door = false; if(hit.collider.gameObject.tag == \"Doorway\") &#123; Cursor.SetCursor(doorway, new Vector2(16, 16), CursorMode.Auto); door = true; &#125; else &#123; Cursor.SetCursor(target, new Vector2(16, 16), CursorMode.Auto); &#125; &#125; else &#123; Cursor.SetCursor(pointer, Vector2.zero, CursorMode.Auto); &#125; &#125;&#125; 回到Unity编辑器，选中MouseManager，在Inspector面板点击【Add Component】按钮，搜索到MouseManager后单击添加。 把Cursors文件夹下的png素材拖拽到Mouse Manager组件如下图： 点击Inspector面板上方的Layers下拉按钮，点击Edit Layers 点开Layers，在User Layers 9填写”Clickable“ 在Hierachy面板选中MouseManager，在Inspector面板的MouseManager组件下的Clickable Layer选项点击下拉，把默认的Nothing改选成Clickable 点击播放按钮验证效果。当鼠标移动到Floor上时，鼠标样式为target，当鼠标移动到Door上时，鼠标样式为doorway，当鼠标移动到周围环境时，鼠标样式为pointer。 三、使用MavMesh组件实现鼠标点击移动接上一篇鼠标交互 将路径Unity Fundamentals Source Assets\\NaMeshComponents-Master下的两个文件夹Gizmos和NavMeshComponents拖拽复制到Unity编辑器项目面板Assets文件夹下。 在Hierachy面板新建一个空Object命名为”NavMesh Surface”，点击NavMesh Surface，在Inspector面板点击Add Component，选择NavMeshSurface。 点击Inspector面板上方的Layers下拉按钮，选择Edit Layers，在User Layer 10填上Player。 点击Cupsule，在Inspector面板将Layer设置为Player。 回到NavMeshSurface的Inspector面板，在NavMeshSurface组件下方，Agent Type默认Humanoid，Include Layers取消勾选Player 点击Bake按钮创建一层附在Floor上的蓝色NavMesh表面 在Door的Inspector面板添加NavMeshObstacle组件，默认Carve勾选。产生的效果是Capsule无法通过Door，即视Door为一个障碍。 添加NavMeshModifier组件，取消勾选Ingnore From Build。 回到NavMesh Surface的Inspector面板，再次点击Bake。 如果此时向上平移Door，原本Door下方的黑色矩形将消失，视为“门开启”，Capsule可以通过。 选中Capsule，添加组件NavMeshAgent，Agent Type默认Humanoid。 在项目面板Scripts文件夹下新建一个C#脚本文件，取名“PlayerController”。 打开脚本文件，编写代码如下，确认无报错后保存。 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour&#123; //private Animator anim; private NavMeshAgent agent; // Use this for initializtion void Awake() &#123; // anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); &#125;&#125; 打开之前写的MouseManager.cs，修改代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;public class MouseManager : MonoBehaviour&#123; //what objects are clickable public LayerMask clickableLayer; //Swap cursers per object public Texture2D pointer;//Normal Pointer public Texture2D target;//Cursers for clickable objects like world public Texture2D doorway;//Cursers for doorways public Texture2D combat;//Cursers for combat sections public EventVector3 OnclickEnviroment; // Update is called once per frame void Update() &#123; RaycastHit hit; if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 50, clickableLayer.value)) &#123; bool door = false; if(hit.collider.gameObject.tag == \"Doorway\") &#123; Cursor.SetCursor(doorway, new Vector2(16, 16), CursorMode.Auto); door = true; &#125; else &#123; Cursor.SetCursor(target, new Vector2(16, 16), CursorMode.Auto); &#125; if(Input.GetMouseButton(0)) &#123; OnclickEnviroment.Invoke(hit.point); &#125; &#125; else &#123; Cursor.SetCursor(pointer, Vector2.zero, CursorMode.Auto); &#125; &#125;&#125;[System.Serializable]public class EventVector3 : UnityEvent&lt;Vector3&gt;&#123; &#125; 回到Unity编辑器，MouseManager的Inpspector面板的MouseManager组件多出了Onclick Enviroment(Vector3)。 从Hierarchy面板拖拽Capsule到None(Object)，点击No function下拉框，勾选NavMeshAgent下的destination。 点击播放后，鼠标单击Floor上任意位置，Capsule移动跟随。 在Capsule的Inspector面板的NavMeshAgent组件下的Steering部分可以修改移动速度(Speed)、角速度(Angular Speed)、加速度(Acceleration)、制动距离(Stopping Distance)、自动刹车(Auto Braking)。 四、玩家互动行为实现修改MouseManager.cs如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Events;public class MouseManager : MonoBehaviour&#123; //what objects are clickable public LayerMask clickableLayer; //Swap cursers per object public Texture2D pointer;//Normal Pointer public Texture2D target;//Cursers for clickable objects like world public Texture2D doorway;//Cursers for doorways public Texture2D combat;//Cursers for combat sections public EventVector3 OnclickEnviroment; // Update is called once per frame void Update() &#123; RaycastHit hit; if(Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 50, clickableLayer.value)) &#123; bool door = false; bool item = false; if(hit.collider.gameObject.tag == \"Doorway\") &#123; Cursor.SetCursor(doorway, new Vector2(16, 16), CursorMode.Auto); door = true; &#125; else if(hit.collider.gameObject.tag == \"Item\") &#123; Cursor.SetCursor(combat, new Vector2(16, 16), CursorMode.Auto); item = true; &#125; else &#123; Cursor.SetCursor(target, new Vector2(16, 16), CursorMode.Auto); &#125; if(Input.GetMouseButton(0)) &#123; if(door) &#123; Transform doorway = hit.collider.gameObject.transform; OnclickEnviroment.Invoke(doorway.position); Debug.Log(\"DOOR\"); &#125; else if(item) &#123; Transform itemPos = hit.collider.gameObject.transform; OnclickEnviroment.Invoke(itemPos.position); Debug.Log(\"ITEM\"); &#125; else &#123; OnclickEnviroment.Invoke(hit.point); &#125; &#125; &#125; else &#123; Cursor.SetCursor(pointer, Vector2.zero, CursorMode.Auto); &#125; &#125;&#125;[System.Serializable]public class EventVector3 : UnityEvent&lt;Vector3&gt;&#123; &#125; 回到Unity编辑器，在Floor上新建一个Cube。 将其Layer设置成Clickable，点击Untagged按钮，选择Add Tag，点击加号按钮，填写“Item”，保存。 点击播放，当鼠标点击Door后，Unity编辑器控制台打印消息“DOOR”，当鼠标点击Cube后，控制台打印消息消息“ITEM”。 五、NPC原型设计在Scripts文件夹下新建两个C#脚本文件，分别命名为“NPCController.cs”，“PlayerController.cs”。 NPCController.cs代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class NPCController : MonoBehaviour&#123; public float patrolTime = 10f; public float aggroRange = 10f; public Transform[] waypoints; private int index; private float speed, agentSpeed; private Transform player; private Animator anim; private NavMeshAgent agent; private void Awake() &#123; anim= GetComponent&lt;Animator&gt;(); agent =GetComponent&lt;NavMeshAgent&gt;(); if(agent != null) &#123; agentSpeed = agent.speed; &#125; player = GameObject.FindGameObjectWithTag(\"Player\").transform; index = Random.Range(0, waypoints.Length); InvokeRepeating(\"Tick\", 0 , 0.5f); if(waypoints.Length &gt; 0) &#123; InvokeRepeating(\"Patrol\", 0, patrolTime); &#125; &#125; void Patrol() &#123; index= index == waypoints.Length - 1 ? 0 : index + 1; &#125; void Tick() &#123; agent.destination = waypoints[index].position; &#125;&#125; PlayerController.cs代码如下： 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class PlayerController : MonoBehaviour&#123; //private Animator anim; private NavMeshAgent agent; // Use this for initializtion void Awake() &#123; // anim = GetComponent&lt;Animator&gt;(); agent = GetComponent&lt;NavMeshAgent&gt;(); &#125;&#125; 复制Capsule一个，移到Door旁边，重命名为NPC，原来的Capsule命名为Player。 给NPC添加NPCController组件，PlayerController组件虽然暂时用不上，但可以先添加到Player上。 在Hierarchy面板新建一个空Object Waypoint (1)，在Inspector面板修改图标颜色，操作如下图。 复制Waypoint (1)，粘贴自动生成一个Waypoint (2)。把两个Waypoint平移到Floor上方便观察的位置。 选中NPC，点击Inspector面板的锁定面板按钮，同时选中Hierarchy面板的Waypoint (1)、Waypoint (2)拖拽到NPC的NPCController组件下的Waypoints 拖拽Waypoint过来后： 解除NPC的Inspector面板锁定，保存场景，点击Play播放。 我们发现NPC会先自己移动到Waypoint (1)，过了几秒后自己移动到Waypoint (2)，然后回到Waypoint (1)，循环往复。 六、NPC跟踪玩家角色修改NPCController.cs的Tick函数如下： 12345678910void Tick()&#123; agent.destination = waypoints[index].position; agent.speed = agentSpeed / 2; if(player != null &amp;&amp; Vector2.Distance(transform.position, player.position) &lt; aggroRange) &#123; agent.destination = player.position; agent.speed = agentSpeed; &#125;&#125; 保存后回到Unity编辑器，把NPC的NavMeshAgent组件下的Steering&gt;StoppingDistance设为1.5。 保存场景后点击播放按钮，我们发现，当鼠标点击Floor后，Player移动，NPC跟随在后。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"Win32窗口","slug":"Win32窗口","date":"2020-01-29T04:15:19.000Z","updated":"2020-04-06T12:19:19.106Z","comments":true,"path":"2020/01/29/Win32窗口/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/29/Win32%E7%AA%97%E5%8F%A3/","excerpt":"没写完…","text":"没写完… 一、创建项目 开发软件：VS2017 新建项目 &gt; Visual C++ &gt; Windows桌面 &gt; Windows桌面向导，填好项目名，项目路径后，下一步，选择“桌面应用程序(.exe)”，勾选“空项目”，点击确定。 PS：在VS2013、2015中，窗口程序叫”Win32项目“，在VS2017、2019中叫做“桌面应用程序”。 二、在线搜索API网址：https://docs.microsoft.com/zh-cn/ 头文件：windows.h文件是win32 API的主要头文件，首字母大小写都行。 主函数WinMain：是main函数的一个自定义函数，在底层由main函数调用它。 右键函数名，选择“转到定义”可以查看函数的具体定义。 返回值为int类型。 调用约定 WINAPI 作用：决定函数名字编译方式、参数入栈顺序、函数逻辑调用时间 参数：由系统传递供我们使用 HINSTANCE hInstance：实例句柄，当前软件运行时，系统分配给的唯一ID，int类型。 HINSTANCE hPreInstance：前一个实例句柄，即前一个打开的软件的句柄，值为NULL，功能名存实亡。 LPSTR lpCmdLine：命令行参数，main函数传递到WinMain函数的参数，类型为char*， PS：P或LP开头的转义变量类型均为指针类型 int nShowCmd：窗口显示方式，默认是窗口正常显示，值为1 SAL：微软源代码注释语言（8个） 功能：提醒编译器帮我们检查函数参数可能存在的问题，避免这些问题在运行时爆发。 SDL：安全开发生命周期 三、 WNDCLASS：窗口类（类是结构体的拓展） WNDCLASSEX：拓展版本的窗口类","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://weimingjuncn.github.io/tags/C/"}]},{"title":"2.5D回合制游戏Demo实现","slug":"2D回合制游戏Demo实现","date":"2020-01-27T02:38:32.000Z","updated":"2020-04-06T12:19:52.532Z","comments":true,"path":"2020/01/27/2D回合制游戏Demo实现/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/27/2D%E5%9B%9E%E5%90%88%E5%88%B6%E6%B8%B8%E6%88%8FDemo%E5%AE%9E%E7%8E%B0/","excerpt":"没写完…","text":"没写完… Win32窗口的机制 GDI绘图原理：基本原理、三缓冲体系 C/C++变量、数据结构、算法、库函数","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://weimingjuncn.github.io/tags/C/"}]},{"title":"Lua函数","slug":"Lua函数","date":"2020-01-26T10:04:46.000Z","updated":"2020-04-06T12:20:32.308Z","comments":true,"path":"2020/01/26/Lua函数/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/26/Lua%E5%87%BD%E6%95%B0/","excerpt":"没写完…","text":"没写完… 一、求最大值与函数作为参数传递1234567891011121314151617181920212223function max(num1, num2) if (num1 &gt; num2) then result = num1; else result = num2; end return result;endprint(\"两值比较最大值为\",max(10,4));print(\"两值比较最大值为\",max(5,6));myprint = function(param) print(\"这是一个打印函数-##\", param,\"##\")endfunction add(num1, num2, functionPrint) result = num1 + num2; functionPrint(result);endmyprint(10);add(2, 5, myprint); 两值比较最大值为 10两值比较最大值为 6这是一个打印函数-## 10 ##这是一个打印函数-## 7 ## 二、多返回值","categories":[],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://weimingjuncn.github.io/tags/Lua/"}]},{"title":"Lua变量、赋值语句、索引、循环、流程控制","slug":"Lua变量","date":"2020-01-26T09:00:49.000Z","updated":"2020-04-06T12:21:30.771Z","comments":true,"path":"2020/01/26/Lua变量/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/26/Lua%E5%8F%98%E9%87%8F/","excerpt":"变量、赋值语句、索引、循环、流程控制","text":"变量、赋值语句、索引、循环、流程控制 一、变量 全局变量 局部变量 表中的域 1234567891011121314151617181920a = 5; -- 全局变量local b = 5; -- 局部变量function joke() c = 5; -- 全局变量 local d = 6; --局部变量endprint(\"a\\t\"..\"b\\t\"..\"c\\t\"..\"d\")print(a, b, c, d);joke();print(a, b, c, d);do local a = 6; -- 局部变量 b = 6; -- 对局部变量重新赋值 print(a, b);endprint(a, b); a b c d5 5 nil nil5 5 5 nil6 65 6 二、赋值语句123456789a, b, c = 0, 1;print(\"a\\t\"..\"b\\t\"..\"c\")print(a, b, c);a, b = a+1,b+1,b+2; -- 没有被赋值的变量会被忽略print(a, b, c);a, b, c = 0; -- 同时为多个变量赋相同的值print(a, b, c); a b c0 1 nil1 2 nil0 nil nil 三、索引t[i]或t.i，t.i是当索引为字符串类型时的一种简化写法。 gettable_event(t, i)采用索引访问本质上时一个类似这样的函数调用。 1234site = &#123;&#125;;site[\"key\"] = \"www.baidu.com\";print(site[\"key\"]); -- 建议写法print(site.key); -- 不建议写法 www.baidu.comwww.baidu.com 四、循环循环体：while, for, repeat…until 循环控制语句：break 五、流程控制if语句：if … then … else … end if嵌套","categories":[],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://weimingjuncn.github.io/tags/Lua/"}]},{"title":"Lua数据类型","slug":"Lua数据类型","date":"2020-01-25T13:27:18.000Z","updated":"2020-04-06T12:22:23.313Z","comments":true,"path":"2020/01/25/Lua数据类型/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/25/Lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"布尔、数字、字符串、表、函数、线程、自定义","text":"布尔、数字、字符串、表、函数、线程、自定义 一、布尔类型Lua把false和nil看作是假，其他都看作是真 123print(type(true));print(type(false));print(type(nil)); booleanbooleannil 12345if false or nil then print(\"至少有一个是true\");else print(\"false nil都为false\");end false nil都为false 二、数字类型（number）1234567print(type(2));print(type(2.2));print(type(0.2));print(type(2e+1));print(2e+1);print(type(0.2e-1));print(type(1.25489e-6)); numbernumbernumbernumber20numbernumber 三、字符串（String）12345678910111213str1 = \"Hi,I'm MJ.\";str2 = \"Hello, MJ.Nice to meet you.\";print(str1..\"\\n\"..str2)-- 一块字符串html = [[ &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;a href = \"www.baidu.com\"&gt;百度搜索&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;]]print(html); Hi,I’m MJ.Hello, MJ.Nice to meet you. &lt;head&gt;&lt;/head&gt;​ ​ 百度搜索​ ​ 在进行数字相加时，lua会自动把字符串转成数字 12345678print('2' + 3);print('2' + '3');print('n'..'b'); -- 字符串连接print(123 .. 456); -- 数字连接，数字与点号间要有空格website = \"www.baidu.com\"print(#website); -- 输出字符串长度print(#\"www.baidu.com\") 55nb1234561313 四、表（table）1234567891011121314151617181920212223242526272829local tb1 = &#123;&#125;; -- 创建一个空表local tb2 = &#123;\"Java\",\"Python\",\"Lua\",\"C++\"&#125;; -- 直接初始化表-- 关联数组a = &#123;&#125;;a[\"key\"] = \"value\";key = 10;a[key] = 22;a[key] = a[key] + 11;for k,v in pairs(a) do print(k.. \" : \" ..v);endlocal tb1 = &#123;\"Java\",\"Python\",\"Lua\",\"C++\"&#125;;for key, val in pairs(tb1) do print(\"key\", key);enda3 = &#123;&#125;;for i = 1, 10 do a3[i] = i;enda3[\"key\"] = \"val\";print(a3[\"key\"]);print(a3[\"none\"]); key : value10 : 33key 1key 2key 3key 4valnil 五、函数1234567891011function factorial1(n) if n == 0 then return 1; else return n * factorial1(n-1); endendprint(factorial1(5));factorial2 = factorial1;print(factorial2(5)); 120120 123456789101112function testFun(tab, fun) for k, v in pairs(tab) do print(fun(k, v)) endendtab = &#123;key1 = \"val1\", key2 = \"val2\"&#125;;-- function可以以匿名函数的方式通过参数传递testFun(tab,function (key, val) -- 匿名函数 return key .. \" = \" .. val;end); key1 = val1key2 = val2 六、线程（Thread）七、自定义类型（Userdata）","categories":[],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://weimingjuncn.github.io/tags/Lua/"}]},{"title":"Lua入门","slug":"Lua入门","date":"2020-01-23T03:41:20.000Z","updated":"2020-04-06T12:23:17.128Z","comments":true,"path":"2020/01/23/Lua入门/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/23/Lua%E5%85%A5%E9%97%A8/","excerpt":"标识符、关键字、全局变量、数据类型","text":"标识符、关键字、全局变量、数据类型 一、环境搭建Windows上安装IDE：SciTE 下载地址：https://github.com/rjpcomputing/luaforwindows/releases 选好安装路径，一路Next，完成安装后即可在该环境下编写 Lua 程序并运行。 在哪运行？ 快捷键Ctrl+D，复制光标所在行并插入到光标的下一行。 二、交互式编程、脚本编程、注释写法 交互式编程方式 打开cmd控制命令窗口，使用命令： Lua -i 脚本式编程方式 将Lua代码保存成.lua文件然后运行。 123#!/usr/local/bin/lua print(\"Hello world!\"); 上边第一行表示指定解释器，解释器执行时会忽略井号开头的第一行。 注释格式 123456-- 单行注释--[[多行注释多行注释多行注释--]] 三、标识符、关键字 标识符组成 字母、数字、下划线； 必须以字母/下划线开头； 区分大小写； 关键字 保留关键字不能用作变量名或自定义标识符：and, break, do, else, elseif, end, false, for, function, if, in , local, nil, not, or, repeat, return, then, true, until, while 一般约定，用下划线开头连接一串大写字母的名字比如：_VERSION，被保留用于Lua内部全局变量。 四、全局变量 全局变量： 默认情况下，变量总被认为是全局的，全局变量不需要声明，给一个变量赋值即可创建该全局变量。 写在函数外部 作用范围从定义的那一行开始到文件末尾 1234b = 10;print(b);b = nil; -- 要删除一个变量，就给它赋值为nilprint(b); -- 当且仅当一个变量的值不为nil时，这个变量即存在 10nil 局部变量： 用关键字“local”定义 写在函数内，if语句内 作用范围从定义的那一行开始到函数结束或return 五、数据类型Lua的8种数据类型： nil(无效值), boolean, number(双精度实浮点数), string, userdata(任意存储在变量中的C数据结构), function, thread(独立线程), table(表，关联数组，通过构造表达式产生) 1234567print(type(\"Hello World!\")); -- 建议用双引号讲字符串括起来，用单引号括单个字符print(type(10.4 * 3));print(type(print));print(type(type));print(type(true));print(type(nil));print(type(type(X))); -- type()返回结果是字符串 stringnumberfunctionfunctionbooleannilstring 1tab1 = &#123;key1 = \"val1\", key2 = \"val2\",\"val3\"&#125; for k,v in pairs(tab1) do print(k..” - “.. v) – “..”表示连接endprint(“——“)tab1.key1 = nil; – 可以用nil删除键值对for k,v in pairs(tab1) do print(k.. “ - “.. v)end 12345678910 &gt;1 - val3 &gt; key1 - val1 &gt; key2 - val2 &gt; &gt; 1 - val3 &gt; key2 - val2 &#96;&#96;&#96;luaprint(type(X) &#x3D;&#x3D; nil);print(type(X) &#x3D;&#x3D; &quot;nil&quot;); falsetrue","categories":[],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://weimingjuncn.github.io/tags/Lua/"}]},{"title":"如何设置Win10右键打开CMD","slug":"如何设置Win10右键打开CMD","date":"2020-01-23T03:31:58.000Z","updated":"2020-01-23T03:39:46.820Z","comments":true,"path":"2020/01/23/如何设置Win10右键打开CMD/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/23/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEWin10%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80CMD/","excerpt":"","text":"转载出自：https://blog.csdn.net/itas109/article/details/86618799 将如下代码保存为*.reg的注册表文件，双击运行 1234567Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\cmd_here]&quot;ShowBasedOnVelocityId&quot;&#x3D;dword:00639bc8[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\cmd_here\\command]@&#x3D;&quot;cmd.exe &#x2F;s &#x2F;k pushd \\&quot;%V\\&quot;&quot; 效果：","categories":[],"tags":[]},{"title":"Unity C#脚本基础","slug":"Unity C Sharp脚本基础","date":"2020-01-18T09:34:55.000Z","updated":"2020-02-23T14:38:05.000Z","comments":true,"path":"2020/01/18/Unity C Sharp脚本基础/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/18/Unity%20C%20Sharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/","excerpt":"Unity版本：Unity 2017.4.35f1 Personal","text":"Unity版本：Unity 2017.4.35f1 Personal 一、在Unity中创建C#脚本 Project&gt;Assets下新建一个叫“Scripts”的文件夹用于存放脚本 在Scripts文件夹下右键&gt;Create&gt;C# Script，取名“ExampleScript” 两种方法给物体添加脚本： 左键单击并将脚本从项目文件夹拖拽到物体上 在物体的Inspector窗口点击Add Component按钮，选择Scripts添加现有的脚本。 通过Add Component按钮，选择New Script添加新建脚本，但脚本是被添加到Assets文件夹，而非Scripts文件夹。 删除物体的脚本：在物体的Inspector面板找到例如ExampleScript(Script)，点击小齿轮，选择Remove Component 调试时打开和关闭脚本：勾选或取消勾选相应的脚本。脚本中可能有错误，如果禁用它，它可能仍会出现并在底部显示错误。因此需要使用代码注释来屏蔽代码块 注意：项目窗口的脚本删除后无法撤销删除。 二、脚本结构双击ExampleScript将自动加载到Visual Studio 2017，如果遇到”File Modification Detected“弹窗，选择“Reload All”重新加载脚本。在Visual Studio将看到ExampleScript.cs的代码： 12345678910111213141516using System.Collections;//命名空间using System.Collections.Generic;//命名空间只是引用类的名称的集合using UnityEngine;public class NewBehaviourScript : MonoBehaviour &#123;//每一个通过Unity新建的脚本都继承自MonoBehavior // Use this for initialization void Start () &#123; &#125; // Update is called once per frame void Update () &#123; &#125;&#125; MonoBehavior来自命名空间UnityEngine，每一个通过Unity新建的脚本都继承自MonoBehavior。 MonoBehavior允许你将脚本作为组件附加到游戏对象中。 类(Class)，只是变量和方法的容器 注意到，类名和.cs文件名相同。如果要修改类的名字，.cs文件名也要一起修改。 起始函数Start()：脚本一启动就执行的方法。 更新函数Update()：每一帧都在执行以保证更新的方法。 三、对游戏对象的基本操作1. 访问、操纵游戏对象组件 导入资源包：首先在Assets文件夹导入Unity_C_Sharp_Fundamentals_Assets.unitypackage。 创建一个Floor：在Assets/Standard Assets/Prototyping/Prefabs下找到FloorPrototype08x01x08，拖拽到场景中，重置其位置。 放入角色：在Assets/Prefabs下找到dwarf_hero，拖拽到场景中的Floor上。给角色添加Capsule Collider组件，并将Capsule Collider下的Center &gt; Y设为0.8，Radius设为0.4，Height设为1.6。 为角色添加脚本：在Assets/Scripts下创建脚本Player.cs，打开脚本，编辑代码如下并保存。 12345678910111213141516using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour &#123; public CapsuleCollider playerConllider; // Use this for initialization void Start () &#123; playerConllider = GetComponent&lt;CapsuleCollider&gt;(); &#125; // Update is called once per frame void Update () &#123; &#125;&#125; 回到Unity编辑器，将Player.cs拖拽到角色的Inspector窗口里。可以看到角色增加了一个叫Player(Script)的组件，里边的Player Collider的值为None(Collider)。当我们点击播放按钮，Player Collider会很容易地自动获取到Collider组件，因为Capsule Collider组件和脚本组件在同一个游戏物体里（角色）。 如果我们在上边的代码中public Collider playerCollider;下插入一行playerCollider.enabled = false;，保存脚本回到Unity点击播放，则可以看到Capsule Collider组件被取消勾选。 同理，如果我们在上边的代码中public Collider playerCollider;下插入一行playerConllider.isTrigger = true;，保存脚本回到Unity点击播放，则可以看到Capsule Collider组件下的Is Trigger被勾选。 如果我们要在游戏启动时修改Capsule Collider的长度、中心位置，我们可以编写代码如下： 1234567void Start () &#123; playerCollider = GetComponent&lt;CapsuleCollider&gt;(); //playerCollider.enabled = false; //取消勾选Capsule Collider组件 //playerCollider.isTrigger = true; //勾选Capsule Collider组件下Is Trigger选项 playerCollider.height = 3f; //修改胶囊碰撞体的高（长度） playerCollider.center = new Vector3(0f, 2f, 0f); //修改胶囊碰撞体中心的位置坐标&#125; 2. 用户输入在Unity编辑器菜单栏，点击Edit &gt; Project Settings &gt; Input在Inspector窗口打开InputManager。我们可以在InputManager中编辑用户输入控制。 我们回到Player.cs，编辑Update函数如下： 1234567void Update ()&#123; float moveHorizontal = Input.GetAxis(\"Horizontal\"); float moveVertical = Input.GetAxis(\"Vertical\"); print(moveHorizontal);&#125; 保存后回到Unity编辑器点击播放，当我们按住【A】键时，控制台将打印消息一系列大于-1且小于0的小数，打印的小数快速减小直到打印出-1，松开键盘后归0，按住【D】键，打印大于0且小于1的小数，并且打印的小数快速增大直至打印出1。 由此我们得知，按键A关联水平负方向，W关联水平正方向。 接下来将Player.cs编辑如下： 1234567891011121314151617using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour &#123; public float moveSpeed = 5f; // Update is called once per frame void Update () &#123; float moveHorizontal = Input.GetAxis(\"Horizontal\");//获取左右移动分量 float moveVertical = Input.GetAxis(\"Vertical\");//获取前后移动分量 //创建水平面移动矢量 Vector3 movement = new Vector3(moveHorizontal, 0f, moveVertical); //将移动矢量转译到Transform组件 transform.Translate(movement * Time.deltaTime * moveSpeed); &#125;&#125; 保存后，在Unity编辑器将镜头摆到合适观察角色的位置，点击播放。通过【W】【A】【S】【D】键，我们可以控制角色前后左右移动。 四、游戏对象之间的交互1. 脚本之间交互在Assets/Prefabs下找到Battle_Dummy，拖拽进场景到Floor上。在Scripts文件夹新建一个Enemy.cs。将Enemy.cs拖拽到Battle_Dummy的Inpsector窗口中形成Enemy(Script)组件。 给Enemy添加上一个Health属性，即编辑Enemy.cs如下： 123456789101112131415using System.Collections;using System.Collections.Generic;using UnityEngine;public class Enemy : MonoBehaviour &#123; //声明Enemy类 public int enemyHealth = 4; //声明enemyHealth并初始化 // Use this for initialization void Start ()&#123; &#125; // Update is called once per frame void Update ()&#123; &#125;&#125; 编辑Player.cs如下 12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour &#123; public float moveSpeed = 5f; private GameObject enemy; private Enemy enemyScript; // Use this for initialization void Start ()&#123; enemy = GameObject.Find(\"Battle_Dummy\"); enemyScript = enemy.GetComponent&lt;Enemy&gt;(); &#125; // Update is called once per frame void Update ()&#123; float moveHorizontal = Input.GetAxis(\"Horizontal\"); float moveVertical = Input.GetAxis(\"Vertical\"); Vector3 movement = new Vector3(moveHorizontal, 0f, moveVertical); transform.Translate(movement * Time.deltaTime * moveSpeed); if (Input.GetKeyDown(KeyCode.Space)) //当键盘按下空格键时执行 &#123; enemyScript.enemyHealth--; //Health自减1 &#125; &#125;&#125; 保存脚本后，回到Unity点击播放，当我们每按一次【空格】键时，点击Battle_Dummy，通过Inspector窗口可以看到Enemy组件下的Enemy Health都会减1。 2. 碰撞交互给角色添加Rigidbody组件,并设置Constraints如图 给Battle_Dummy添加Capsule Collider组件，Center设置为（0，0.5，0），Radius设置为0.4，Height设置为2。通过快捷键Ctrl+D快速生成两个复制品，拖到旁边如图： 在Player.cs里为类Player添加方法OnCollisionEnter： 1234567void OnCollisionEnter(Collision collision)&#123; if(collision.gameObject.tag == \"Enemy\") &#123; enemyScript.enemyHealth--; &#125;&#125; 回到Unity给3个Battle_Bummy添加Tag Enemy，角色添加Tag Player。 点击播放，选中Battle_Bummy，控制角色碰到Battle_Bummy一次，其Enemy组件下EnemyHealth减1一次。 但当我们控制角色碰撞Battle_Bummy(1)、Battle_Bummy(2)时，它们的EnemyHealth却没有减少。 修改Player.cs如下后即可解决问题： 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour &#123; public float moveSpeed = 5f; //private GameObject enemy; private Enemy enemyScript; // Use this for initialization void Start () &#123; //enemy = GameObject.Find(\"Battle_Dummy\"); //enemyScript = enemy.GetComponent&lt;Enemy&gt;(); &#125; // Update is called once per frame void Update () &#123; float moveHorizontal = Input.GetAxis(\"Horizontal\"); float moveVertical = Input.GetAxis(\"Vertical\"); Vector3 movement = new Vector3(moveHorizontal, 0f, moveVertical); //角色移动 transform.Translate(movement * Time.deltaTime * moveSpeed); &#125; void OnCollisionEnter(Collision collision) &#123; if(collision.gameObject.tag == \"Enemy\") &#123; enemyScript = collision.gameObject.GetComponent&lt;Enemy&gt;(); enemyScript.enemyHealth--; &#125; &#125;&#125; 3. 触发器我们从Assets/Prefabs往场景里添加一个Chest 在Scripts文件夹里新建一个TreasureChest.cs，为类TreasureChest添加一个OnTriggerEnter方法。 1234567void OnTriggerEnter(Collider other)&#123; if(other.gameObject.tag == \"Player\") &#123; print(\"Interacting!\"); &#125;&#125; 在Unity中，给Chest添加上TreasureChest(Script)组件。 点击播放，当我们控制角色碰到Chest一次，控制台打印消息“Interacting!”一次。 如果把OnTriggerEnter换成OnTriggerStay，当我们控制角色停留在Chest旁边时，控制台会持续打印消息“Interacting!”。 如果在OnTriggerEnter方法下方添加OnTriggerExit方法： 1234567void OnTriggerExit(Collider other)&#123; if(other.gameObject.tag == \"Player\") &#123; print(\"Hey!\"); &#125;&#125; 当我们的角色靠近Chest在离开，控制台将打印一次消息“Hey!”。 我们给TreasureChest添加一个布尔类型的公共属性interactable，并初始化为false。修改OnTriggerEnter方法和OnTriggerExit方法的内容如下： 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;public class TreasureChest : MonoBehaviour &#123; public bool interactable = false; void OnTriggerEnter(Collider other) &#123; if(other.gameObject.tag == \"Player\") &#123; interactable = true; &#125; &#125; private void OnTriggerExit(Collider other) &#123; if(other.gameObject.tag == \"Player\") &#123; interactable = false; &#125; &#125;&#125; 当我们播放游戏时，Chest的TreasureChest(Script)组件下会生成一个interactable选项，当角色靠近Chest时，interactable被勾选（值为true），当角色离开时，interactable取消勾选（值为false）。 接下来加入动画， 点击Unity菜单栏的Window &gt; Animator打开Animator窗口，可以看到Parameters下有一个openChest，右边的转变图里，选中Idle_State，我们看到Transition下有一个转变情况：Idle_State -&gt; ChestOpen。点击，下方出现转变条件（Conditions）——openChest的值为true（默认）。因此我们在Update方法里可以写上，当开箱按键（这里设为空格）按下后，动画设置openChest为true。 编辑后的TreasureChest.cs如下： 1234567891011121314151617181920212223242526272829303132333435using System.Collections;using System.Collections.Generic;using UnityEngine;public class TreasureChest : MonoBehaviour &#123; public bool interactable = false; private Animator anim; // Use this for initialization void Start () &#123; anim = GetComponent&lt;Animator&gt;(); &#125; // Update is called once per frame void Update () &#123; if(interactable &amp;&amp; Input.GetKeyDown(KeyCode.Space)) &#123; anim.SetBool(\"openChest\", true); &#125; &#125; void OnTriggerEnter(Collider other) &#123; if(other.gameObject.tag == \"Player\") &#123; interactable = true; &#125; &#125; private void OnTriggerExit(Collider other) &#123; if(other.gameObject.tag == \"Player\") &#123; interactable = false; &#125; &#125;&#125; 播放游戏，当角色靠近Chest按下空格键，播放箱子打开动画。 4. 射线侦测（Raycasting）射线的一个应用时侦测角色周围是否有敌人。 回到Player.cs，我们给类Player添加以下3个变量： 123private RaycastHit hit;private Ray ray;public float rayDistance = 4f; 在Update方法做如下应用： 12ray = new Ray(transform.position, transform.forward);Debug.DrawRay(ray.origin, ray.direction * rayDistance, Color.red); 回到Unity播放游戏，点击Scene窗口，我们发现角色脚下正前方（Z轴正方向）出现一条4格长度的红线。 要把红线上移到角色重新，我们可以对上边两行代码的第一行修改成如下： 1ray = new Ray(transform.position + new Vector3(0f,playerCollider.center.y,0f), transform.forward); 接下来实现射线反馈，在Update方法里继续编写如下代码： 1234567if(Physics.Raycast(ray, out hit))&#123; if(hit.distance &lt; rayDistance) &#123; print(\"We hit something!\"); &#125;&#125; 播放游戏，移动角色，当红线触及Battle_Dummy或Chest时（其实时触及它们的碰撞体），控制台持续打印消息“We hit something!”。 接下来修改执行反馈的代码如下： 12345678910if(Physics.Raycast(ray, out hit))&#123; if(hit.distance &lt; rayDistance) &#123; if(hit.collider.gameObject.tag == \"Enemy\") &#123; print(\"There is an enemy ahead!\"); &#125; &#125;&#125; 播放游戏，当角色移动到Chest前边时，反馈但没有打印消息，当角色移动到Battle_Dummy前边时，控制台持续打印消息“There is an enemy ahead!” 至此，Player.cs完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System.Collections;using System.Collections.Generic;using UnityEngine;public class Player : MonoBehaviour &#123; public CapsuleCollider playerCollider; public float moveSpeed = 5f; private Enemy enemyScript; private RaycastHit hit; private Ray ray; public float rayDistance = 4f; // Use this for initialization void Start () &#123; playerCollider = GetComponent&lt;CapsuleCollider&gt;(); &#125; // Update is called once per frame void Update () &#123; float moveHorizontal = Input.GetAxis(\"Horizontal\"); float moveVertical = Input.GetAxis(\"Vertical\"); Vector3 movement = new Vector3(moveHorizontal, 0f, moveVertical); //角色移动 transform.Translate(movement * Time.deltaTime * moveSpeed); ray = new Ray(transform.position + new Vector3(0f,playerCollider.center.y,0f), transform.forward); Debug.DrawRay(ray.origin, ray.direction * rayDistance, Color.red); if(Physics.Raycast(ray, out hit)) &#123; if(hit.distance &lt; rayDistance) &#123; if(hit.collider.gameObject.tag == \"Enemy\") &#123; print(\"There is an enemy ahead!\"); &#125; &#125; &#125; &#125; void OnCollisionEnter(Collision collision) &#123; if(collision.gameObject.tag == \"Enemy\") &#123; enemyScript = collision.gameObject.GetComponent&lt;Enemy&gt;(); enemyScript.enemyHealth--; &#125; &#125;&#125; 5. 实例化（Instantiate）和销毁打开TreasureChest.cs，为将要实例化的预制体创建供存储的变量。 12public Rigidbody coinPrefab;public Transform spawner; 编辑Update函数如下： 123456789void Update () &#123; if(interactable &amp;&amp; Input.GetKeyDown(KeyCode.Space)) &#123; anim.SetBool(\"openChest\", true); Rigidbody coinInstance; coinInstance = Instantiate(coinPrefab, spawner.position, spawner.rotation) as Rigidbody;//将实例化结果由Object类型强转成Rigidbody类型 coinInstance.AddForce(spawner.up * 100);//给coinInstance在Y轴正方向上添加受力 &#125;&#125; 回到Unity，我们看到Chest的Treasure Chest(Script)组件下多了两个属性Coin Prefabs和Spawner。从Assets/Prefabs拖拽Coin到Coin Prefabs，注意到我们的预制体Coin也具备Rigidbody组件，因此可以放入要求Rigidbody类型的Coin Prefabs。 选中Chest新建一个空的子Object，命名为spawner，将其拖拽到Chest的TreasureChest组件下Spawner属性。 选中spawner，将其往Y轴正方向移动到Chest上方（此处移动了0.86）。 播放游戏，当角色移动到Chest前，按一次空格键，Chest打开并弹起一个Coin然后垂直落回原位，Hierarchy窗口也会生成一个Coin(Clone)。 如果此时再按空格，则Coin继续弹出，并叠在之前的Coin上。 接下来我们实现Coin实例的销毁。 在Assets/Scripts下新建Coin.cs并在Visual Studio打开，在Start方法里添加语句： 1Destroy(gameObject, 2.0f); //两秒后销毁gameObject 给Assets/Prefabs下的预制体Coin添加组件Coin(Script) 再次播放游戏，当我们每按一次空格，箱子里弹出的硬币均仅仅存在2秒。 Coin.cs完整代码： 1234567891011121314using System.Collections;using System.Collections.Generic;using UnityEngine;public class Coin : MonoBehaviour &#123; // Use this for initialization void Start () &#123; Destroy(gameObject, 2.0f); //两秒后销毁gameObject &#125; // Update is called once per frame void Update () &#123; &#125;&#125; TreasureChest.cs最终代码： 1234567891011121314151617181920212223242526272829303132333435363738394041using System.Collections;using System.Collections.Generic;using UnityEngine;public class TreasureChest : MonoBehaviour &#123; public bool interactable = false; private Animator anim; public Rigidbody coinPrefab; public Transform spawner; // Use this for initialization void Start () &#123; anim = GetComponent&lt;Animator&gt;(); &#125; // Update is called once per frame void Update () &#123; if(interactable &amp;&amp; Input.GetKeyDown(KeyCode.Space)) &#123; anim.SetBool(\"openChest\", true); Rigidbody coinInstance; coinInstance = Instantiate(coinPrefab, spawner.position, spawner.rotation) as Rigidbody;//将实例化结果由Object类型强转成Rigidbody类型 coinInstance.AddForce(spawner.up * 100); &#125; &#125; void OnTriggerEnter(Collider other) &#123; if(other.gameObject.tag == \"Player\") &#123; interactable = true; &#125; &#125; private void OnTriggerExit(Collider other) &#123; if(other.gameObject.tag == \"Player\") &#123; interactable = false; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"C#脚本基础","slug":"C Sharp脚本基础","date":"2020-01-17T08:34:55.000Z","updated":"2020-04-12T13:48:02.338Z","comments":true,"path":"2020/01/17/C Sharp脚本基础/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/17/C%20Sharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/","excerpt":"脚本结构、基础语法、数据类型","text":"脚本结构、基础语法、数据类型 一、开发环境IDE：Visual Studio 2017 新建项目途径： ​ 其他语言 &gt; Visual C# &gt; Windows桌面 &gt; 空项目(.NET Framework)或者控制台应用。 二、脚本结构一个C#脚本文件包含以下部分： 命名空间声明（Namespace declaration） 一个类（Class） 类方法 类属性 一个Main方法 语句（Statements）、表达式（Expressions） 注释 在解决方案资源管理器窗口中右键项目名称”CSProject1“，点击“添加“ &gt; ”新建项“，选择“类” &gt; 修改默认类名为”HelloWorld“，点击”添加“按钮。至此，我们创建了一个名叫”HelloWorld“的类，即HelloWorld.cs文件。 在代码编辑器中编写代码如下： 12345678910111213using System;namespace CSProject1&#123; class HelloWorld &#123; static void Main(string[] args) &#123; /*My first C Sharp Script.*/ Console.WriteLine(\"Hello World !\"); Console.ReadKey(); &#125; &#125;&#125; 运行后： Hello World ! 解释： using 关键字用于在程序中包含命名空间。 一个程序可以包含多个 using 语句。 下一行是 namespace 声明。一个 namespace 里包含了一系列的类。CSProject1命名空间包含了类 HelloWorld。 下一行是 class 声明。类 HelloWorld 包含程序使用的数据和方法声明。类一般包含多个方法。方法定义了类的行为。在这里，HelloWorld 类只有一个 Main 方法。 下一行定义了 Main 方法，是所有 C# 程序的 入口点。Main 方法说明当执行时，类将做什么动作。 下一行 /*…*/ 将会被编译器忽略，且它会在程序中添加额外的注释。 Main 方法通过语句*Console.WriteLine(“Hello World”); *指定它的行为。 WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法。该语句将消息 “Hello, World!”显示在命令提示符窗口上。 最后一行 Console.ReadKey(); 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。 以下几点值得注意： C# 对英文字母大小写敏感。 所有的语句和表达式必须以分号（;）结尾。 程序的执行从 Main 方法开始。 与 Java 不同的是，文件名可以不同于类的名称。 另一种编译执行C#程序的方式： 打开一个文本编辑器，添加上面提到的代码。 保存文件为 helloworld.cs。 打开命令提示符工具，定位到文件所保存的目录。 键入 csc helloworld.cs 并按下 enter 键来编译代码。 如果代码没有错误，命令提示符会进入下一行，并生成 helloworld.exe 可执行文件。 接下来，键入 helloworld 来执行程序。 若提示无法识别 csc 命令，需配置环境变量（Window10) 找到桌面上的“此电脑”图标，右键单击，并在弹出的菜单中点击 “属性” –”高级系统设置”–”环境变量”–”系统变量”，找到变量 Path， 添加一个路径 C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\ 注意：多个路径使用分号(;)隔开，Windows其他版本追加在后面即可。 三、基本语法先上例子： 123456789101112131415161718192021222324252627282930313233343536using System;namespace RectangleApplication&#123; class Rectangle &#123; double length;// 成员变量 double width;// 成员变量 public void Acceptdetails()//成员函数 &#123; length = 4.5; width = 3.5; &#125; public double GetArea()//成员函数 &#123; return length * width; &#125; public void Display()//成员函数 &#123; Console.WriteLine(\"Length: &#123;0&#125;\", length); Console.WriteLine(\"Width: &#123;0&#125;\", width); Console.WriteLine(\"Area: &#123;0&#125;\", GetArea()); &#125; &#125; class ExecuteRectangle//实例化Retangle类的类，它包含Main方法 &#123; static void Main(string[] args) &#123; Rectangle r = new Rectangle(); r.Acceptdetails(); r.Display(); Console.ReadLine(); &#125; &#125;&#125; 编译并执行后，结果如下： Length: 4.5Width: 3.5Area: 15.75 using关键字：用于在程序中包含命名空间，一个程序可以包含多个using语句。 在任何C#程序中的第一条语句都是：using System; class关键字：用于声明一个类。 注释：用于解释代码，编译器会忽略被注释的条目。单行注释用 // ，多行注释用 /*开始，/*结束。 成员变量：变量的类的属性或数据成员，用于存储数据。 成员函数：在类内声明的函数。函数使一系列执行指定任务的语句。 实例化一个类：上边例子中的类ExecuteRectangle。 标识符：用于来识别类、变量、函数或任何其它用户定义的项目。 在 C# 中，类的命名必须遵循如下基本规则： 标识符必须以字母、下划线或 @ 开头，后面可以跟一系列的字母、数字、下划线、@。 标识符中的第一个字符不能是数字。 标识符必须不包含任何嵌入的空格或符号，比如 ? - +! # % ^ &amp; * ( ) [ ] { } . ; : “ ‘ / \\。 标识符不能是 C# 关键字。除非它们有一个 @ 前缀。 例如，@if 是有效的标识符，但 if 不是，因为 if 是关键字。 标识符必须区分大小写。大写字母和小写字母被认为是不同的字母。 不能与C#的类库名称相同。 C#关键字：C# 编译器预定义的保留字。 这些关键字不能用作标识符，但是，如果您想使用这些关键字作为标识符，可以在关键字前面加上 @ 字符作为前缀。 在 C# 中，有些关键字在代码的上下文中有特殊的意义，如 get 和 set，这些被称为上下文关键字（contextual keywords）。 下表列出了 C# 中的保留关键字（Reserved Keywords）和上下文关键字（Contextual Keywords）： 保留关键字 abstract as base bool break byte case catch char checked class const continue decimal default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in in (generic modifier) int interface internal is lock long namespace new null object operator ou out (generic modifier) override params private protected public readonly ref return sbyte sealed short sizeof stackalloc static string struct switch this throw true try typeof uint ulong unchecked unsafe ushort using virtual void volatile while 上下文关键字 add alias ascending descending dynamic from get global group into join let orderby partial (type) partial (method) remove select set 四、数据类型在 C# 中，变量分为以下几种类型： 值类型（Value types） 引用类型（Reference types） 指针类型（Pointer types） 值类型 值类型变量可以直接分配给一个值。它们是从类 System.ValueType 中派生的。 值类型直接包含数据。比如 int、char、float。 如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用 sizeof 方法。表达式 sizeof(type) 产生以字节为单位存储对象或类型的存储尺寸。 引用类型 引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。 换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。内置的引用类型有：object、dynamic 和 string。 对象（Object）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。 当一个值类型转换为对象类型时，称为 装箱；当一个对象类型转换为值类型时，称为 拆箱。 123456int num1 = 2019;object obj = num1;//整型数据转换为了对象类型（装箱）//拆箱：之前由值类型转换而来的对象类型再转回值类型。int num2 = 2018;object obj = num2;//先装箱,只有装过箱的数据才能拆箱int num3 = （int）obj;//再拆箱 动态（Dynamic）类型变量可以存储任何类型的值。这些变量的类型检查是在运行时发生的。 声明动态类型的语法： 1dynamic &lt;variable_name&gt; = value; 例如： 1dynamic d = 20; 动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。 字符串（String）类型 允许您给变量分配任何字符串值。字符串类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串类型的值可以通过两种形式进行分配：引号和 @引号。 例如： 1String str = \"baidu.com\"; 一个 @引号字符串： 1@\"baidu.com\"; C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\\）当作普通字符对待，比如： 1string str = @\"C:\\Windows\"; 等价于： 1string str = \"C:\\\\Windows\"; @ 字符串中可以任意换行，换行符以及缩进空格都计算在字符串长度之内。 1234string str = @\"&lt;script type=\"\"text/javascript\"\"&gt; &lt;!-- --&gt;&lt;/script&gt;\"; 用户自定义引用类型有：class、interface 或 delegate。 指针类型 C# 中的指针与 C 或 C++ 中的指针有相同的功能。 声明指针类型的语法例如： 12char* cptr;int* iptr; 五、C#类型转换显式类型转换：即强制类型转换，需要强制转换运算符，会导致数据丢失。 隐式类型转换：C#默认的以安全的方式进行的转换，不会导致数据丢失。 显示类型转换例子： 12345678910111213141516using System;namespace TypeConversionApplication&#123; class ExplicitConversion &#123; static void Main(string[] args) &#123; double d = 2345.6789; int i; i = (int)d; Console.WriteLine(d); Console.Readkey(); &#125; &#125;&#125; 输出结果： 2345 C# 提供的内置类型转换方法： 方法名 转换类型后的类型 ToBoolean 布尔型 ToByte 字节类型 ToChar 单个 Unicode 字符类型 ToDateTime 把类型（整数或字符串类型）转换为 日期-时间 结构 ToDecimal 把浮点型或整数类型转换为十进制类型 ToDouble 双精度浮点型 ToInt16 16 位整数类型 ToInt32 32 位整数类型 ToInt64 64 位整数类型 ToSbyte 有符号字节类型 ToSingle 小浮点数类型 ToString 字符串类型 ToType 指定类型 ToUInt16 16 位无符号整数类型 ToUInt32 32 位无符号整数类型 ToUInt64 64 位无符号整数类型 不同类型转换为字符串类型的例子： 123456789101112131415161718192021using System;namespace TypeConversionApplication&#123; class StringConversion &#123; static void Main(string[] args) &#123; int i = 75; float f = 53.005f; double d = 2345.6789; bool b = true; Console.WriteLine(i.ToString()); Console.WriteLine(f.ToString()); Console.WriteLine(d.ToString()); Console.WriteLine(b.ToString()); Console.ReadKey(); &#125; &#125;&#125; 六、C#基本变量类型一个变量只不过是一个供程序操作的存储区的名字，变量类型决定了变量的内存大小和布局。 C# 中提供的基本的值类型大致可以分为以下几类： 类型 举例 整数类型 sbyte、byte、short、ushort、int、uint、long、ulong 和 char 浮点型 float 和 double 十进制类型 decimal 布尔类型 true 或 false 值，指定的值 空类型 可为空值的数据类型 C# 允许定义其他值类型的变量，比如 enum，也允许定义引用类型变量，比如 class。 System 命名空间中的 Console 类提供了一个函数 ReadLine()，用于接收来自用户的输入，并把它存储到一个变量中。 例如： 12int num;num &#x3D; Convert.ToInt32(Console.ReadLine()); 函数 Convert.ToInt32() 把用户输入的数据转换为 int 数据类型，因为 Console.ReadLine() 只接受字符串格式的数据。 七、C#常量整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，没有前缀则表示十进制。 整数常量也可以有后缀，可以是 U 和 L 的组合，其中，U 和 L 分别表示 unsigned 和 long。后缀可以是大写或者小写，多个后缀以任意顺序进行组合。 这里有一些整数常量的实例： 12345212 /* 合法 */215u /* 合法 */0xFeeL /* 合法 */078 /* 非法：8 不是一个八进制数字 */032UU /* 非法：不能重复后缀 */ 以下是各种类型的整数常量的实例： 123456785 /* 十进制 */0213 /* 八进制 */0x4b /* 十六进制 */30 /* int */30u /* 无符号 int */30l /* long */30ul /* 无符号 long */ 浮点常量是由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 这里有一些浮点常量的实例： 123453.14159 /* 合法 */314159E-5L /* 合法 */510E /* 非法：不完全指数 */210f /* 非法：没有小数或指数 */.e55 /* 非法：缺少整数或小数 */ 使用小数形式表示时，必须包含小数点、指数或同时包含两者。使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。有符号的指数是用 e 或 E 表示的。 字符串常量是括在双引号 “” 里，或者是括在 @”” 里。字符串常量包含的字符与字符常量相似，可以是：普通字符、转义序列和通用字符 使用字符串常量时，可以把一个很长的行拆成多个行，可以使用空格分隔各个部分。 这里是一些字符串常量的实例。下面所列的各种形式表示相同的字符串。 123456789101112string a = \"hello, world\"; // hello, worldstring b = @\"hello, world\"; // hello, worldstring c = \"hello \\t world\"; // hello worldstring d = @\"hello \\t world\"; // hello \\t worldstring e = \"Joe said \\\"Hello\\\" to me\"; // Joe said \"Hello\" to mestring f = @\"Joe said \"\"Hello\"\" to me\"; // Joe said \"Hello\" to mestring g = \"\\\\\\\\server\\\\share\\\\file.txt\"; // \\\\server\\share\\file.txtstring h = @\"\\\\server\\share\\file.txt\"; // \\\\server\\share\\file.txtstring i = \"one\\r\\ntwo\\r\\nthree\";string j = @\"onetwothree\"; 常量是使用 const 关键字来定义的 。定义一个常量的语法如下： 1const &lt;data_type&gt; &lt;constant_name&gt; = value; 下面的代码演示了如何在程序中定义和使用常量： 12345678910111213141516171819202122using System;public class ConstTest &#123; class SampleClass &#123; public int x;//属性变量 public int y;//属性变量 public const int c1 = 5;//属性常量 public const int c2 = c1 + 5;//属性常量 public SampleClass(int p1,int p2)//构造方法 &#123; x = p1; y = p2; &#125; &#125; static void Main() &#123; SampleClass mC = new SampleClass(11, 22); Console.WriteLine(\"x = &#123;0&#125;, y = &#123;1&#125;\", mC.x, mC.y); Console.WriteLine(\"c1 = &#123;0&#125;, c2 = &#123;1&#125;\", SampleClass.c1, SampleClass.c2); &#125;&#125; 输出结果： x = 11, y = 22c1 = 5, c2 = 10 八、运算符 算术运算符：+、-、*、/、%、++、– 关系运算符：==、!=、&gt;、&lt;、&gt;=、&lt;= 逻辑运算符：&amp;&amp;、||、! 位运算符：&amp;、|、^(异或)、~(非) 赋值运算符：=、+=、-=、*=、/=、%=、&lt;&lt;=(左移且赋值)、&gt;&gt;=、&amp;=、^=、|= 其他一些重要的运算符。 运算符 描述 实例 sizeof() 返回数据类型的大小。 sizeof(int)，将返回 4. typeof() 返回 class 的类型。 typeof(StreamReader); &amp; 返回变量的地址。 &a; 将得到变量的实际地址。 * 变量的指针。 *a; 将指向一个变量。 ? : 条件表达式 如果条件为真 ? 则为 X : 否则为 Y is 判断对象是否为某一类型。 If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。 as 强制转换，即使转换失败也不会抛出异常。 Object obj = new StringReader(“Hello”); StringReader r = obj as StringReader; 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 从右到左 逗号 , 从左到右 九、C# 判断、循环判断语句 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： 1Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。 ? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。 循环类型 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for或foreach 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 foreach循环例子： 12345678910111213141516171819202122232425262728293031using System;namespace ForeachTestApplication&#123; public class ForeachTest &#123; static void Main(String[] args) &#123; int[] array = new int[]&#123;2080, 2070, 2060, 1660, 1650&#125;; foreach ( int element in array) &#123; Console.WriteLine(element); &#125; Console.WriteLine(); //原理类似foreach的for循环 for(int i=0;i &lt; array.Length; i++) &#123; Console.WriteLine(array[i]); &#125; Console.WriteLine(); //加入计数器 int count = 0; foreach (int item in array) &#123; count++; Console.WriteLine(count+\" : \"+item); &#125; Console.WriteLine(\"The length of this array is \"+count); &#125; &#125;&#125; 程序输出结果： 20802070206016601650 20802070206016601650 1 : 20802 : 20703 : 20604 : 16605 : 1650The length of this array is 5 十、封装封装 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。 抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。 C# 封装根据具体的需要，设置使用者的访问权限，并通过 访问修饰符 来实现。 一个 访问修饰符 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示： public：所有对象都可以访问； private：对象本身在对象内部可以访问； protected：只有该类对象及其子类对象可以访问 internal：同一个程序集的对象可以访问； protected internal：访问限于当前程序集或派生自包含类的类型。 十一、C#方法当定义一个方法时，从根本上说是在声明它的结构的元素。在 C# 中，定义方法的语法如下： 1234&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)&#123; Method Body&#125; 下面是方法的各个元素： Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。 Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 void。 Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。 Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。 Method body：方法主体，包含了完成任务所需的指令集。 按引用传递参数 引用参数是一个对变量的内存位置的引用。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。 在 C# 中，使用 ref 关键字声明引用参数。下面的实例演示了这点： 1234567891011121314151617181920212223242526272829303132333435using System;namespace CalculatorApplication&#123; class NumberManipulator &#123; public void swap(ref int x, ref int y) &#123; int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 temp 赋值给 y */ &#125; static void Main(string[] args) &#123; NumberManipulator n = new NumberManipulator(); /* 局部变量定义 */ int a = 100; int b = 200; Console.WriteLine(\"在交换之前，a 的值： &#123;0&#125;\", a); Console.WriteLine(\"在交换之前，b 的值： &#123;0&#125;\", b); /* 调用函数来交换值 */ n.swap(ref a, ref b); Console.WriteLine(\"在交换之后，a 的值： &#123;0&#125;\", a); Console.WriteLine(\"在交换之后，b 的值： &#123;0&#125;\", b); Console.ReadLine(); &#125; &#125;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 在交换之前，a 的值：100在交换之前，b 的值：200在交换之后，a 的值：200在交换之后，b 的值：100 按输出传递参数 return 语句可用于只从函数中返回一个值。但是，可以使用 输出参数 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。 下面的实例演示了这点： 1234567891011121314151617181920212223242526272829using System;namespace CalculatorApplication&#123; class NumberManipulator &#123; public void getValue(out int x ) &#123; int temp = 5; x = temp; &#125; static void Main(string[] args) &#123; NumberManipulator n = new NumberManipulator(); /* 局部变量定义 */ int a = 100; Console.WriteLine(\"在方法调用之前，a 的值： &#123;0&#125;\", a); /* 调用函数来获取值 */ n.getValue(out a); Console.WriteLine(\"在方法调用之后，a 的值： &#123;0&#125;\", a); Console.ReadLine(); &#125; &#125;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 在方法调用之前，a 的值： 100在方法调用之后，a 的值： 5 提供给输出参数的变量不需要赋值。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用。请看下面的实例，来理解这一点： 1234567891011121314151617181920212223242526272829using System;namespace CalculatorApplication&#123; class NumberManipulator &#123; public void getValues(out int x, out int y ) &#123; Console.WriteLine(\"请输入第一个值： \"); x = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(\"请输入第二个值： \"); y = Convert.ToInt32(Console.ReadLine()); &#125; static void Main(string[] args) &#123; NumberManipulator n = new NumberManipulator(); /* 局部变量定义 */ int a , b; /* 调用函数来获取值 */ n.getValues(out a, out b); Console.WriteLine(\"在方法调用之后，a 的值： &#123;0&#125;\", a); Console.WriteLine(\"在方法调用之后，b 的值： &#123;0&#125;\", b); Console.ReadLine(); &#125; &#125;&#125; 当上面的代码被编译和执行时，它会产生下列结果（取决于用户输入）： 请输入第一个值：7请输入第二个值：8在方法调用之后，a 的值： 7在方法调用之后，b 的值： 8","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"Unity基本操作","slug":"Unity基本操作","date":"2020-01-16T04:52:05.000Z","updated":"2020-04-22T13:23:03.523Z","comments":true,"path":"2020/01/16/Unity基本操作/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/16/Unity%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"基本操作","text":"基本操作 新建场景 File&gt;New Scene（或快捷键Ctrl+N）, 默认名“Untitled”, Ctrl+S保存到Yourproject/Assets/Scenes下(没有Scenes就新建一个) 基于3D物体的创建 Hierachy面板：层级面板，用于显示当前场景中有哪些资源。在这些面板中可以往场景中添加资源。 在该面板右键创建物体 操作物体的快捷键： Q：切换到视角拖拽 W：切换到物体平移 E：切换到物体旋转 R：切换到物体缩放 Project/Console面板：Project选项卡可以管理Assets、Packages；Console选项卡可以查看控制台信息 Assets下导入素材 在Project&gt;Assets下右键，Import Packages&gt;Custom Packages，素材可以从官网（https://assetstore.unity.com ）搜索下载（官方免费素材例子：Free Rocks、Standard Assets） 导入后，选择需要的文件，拖拽到Hierachy面板即可加入场景 游戏导出 File&gt;Build Settings, 在弹出的窗口里点击【Add Open Scenes】添加场景 点击【Build】，选择导出路径并确认即可 项目目录结构 Assets：资源文件夹 Library：库文件夹 Logs Packages ProjectSettings：存放项目设置文件 Temp：存放临时文件 鼠标功能 鼠标左键：选中场景中的物体 鼠标中键：单击，视野聚焦到选中物体；拖拽，平移场景的观察角度；滚动，拉远拉近 鼠标右键：旋转场景的观察角度 Alt + 鼠标左键：旋转观察角度 Alt + 鼠标右键：拉远拉近 双击Hierachy面板中的物体：视野聚焦到双击选中的物体 Inspector面板 Transform组件(变换组件) Position：物体在直角坐标系中的位置，默认（0,0,0） Rotation：物体的旋转角度 Scale：物体的缩放，默认（1,1,1） 点击小齿轮&gt;Reset：归零 坐标系切换按钮： 自身坐标系：Local 世界坐标系：Global 摄像机两种模式切换： Persp：透视模式，近大远小 ISO：正交模式，远近一样大（多用于2D模型） Mesh Filter组件（网格过滤器）：指定mesh（物体的几何形状），物体的形状由网格决定 Mesh Renderer组件（网格渲染器）：从网格过滤器中获得几何体的形状然后进行渲染 Prefab预制体 父子关系：移动父物体，子物体会跟着移动 在Hierarchy面板中，任意两个物体都可以建立父子关系 预制体：Prefab，预先准备好的物体，可以重复使用和利用，例如手枪中的子弹 管理预制体：在Assets中建立“Prefabs”文件夹，用于管理预制体 创建预制体：直接将Hierarchy面板中的物体拖拽到Project面板的Assets中，即可创建一个预制体。预制体文件的后缀是”.prefab” 使用预制体：将预制体直接拖拽到Hierarchy面板或Scene面板，都可以在场景中创建一个相应的物体 预制体与非预制体的区别： 在Hierarchy面板中，非预制体颜色是白色，预制体颜色是蓝色 在Inspector面板中，预制体比非预制体多了一个“Prefab”选项 预制体的好处：编辑其中一个，在Inspector&gt;Prefab，“Apply”一下，所有的全部改变 Material(材质)：用来更改物体的颜色质地等属性 新建材质：在Assets文件夹下创建Materials文件夹，在Materials文件夹下右键&gt;Create&gt;Material 运用举例： 创建3个Cube预制体，在Materials文件夹下新建一个叫“Black”的材质，在Inspector&gt;Main Maps设置颜色成黑色 在Hierarchy面板选中其中一个Cube预制体，将”Black”材质拖拽到Inspector&gt;Mesh Renderer&gt;Materials&gt;Element 0，Cube的颜色变为黑色。 如果要把其他两个Cube预制体也变成黑色，则在Inspector&gt;Prefabs下点击Overrides旁的小三角，选择Apply All即可 如果此时在改变其中一个Cube预制体的材质，其他两个也会跟着一起改变","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"}]},{"title":"C#入坑与VS的使用","slug":"C Sharp入坑与VS的使用","date":"2020-01-14T06:13:12.000Z","updated":"2020-04-14T14:17:14.137Z","comments":true,"path":"2020/01/14/C Sharp入坑与VS的使用/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/14/C%20Sharp%E5%85%A5%E5%9D%91%E4%B8%8EVS%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"《Professional C# 7 and .NET Core 2.0》、《C#高级编程（第7版）》笔记","text":"《Professional C# 7 and .NET Core 2.0》、《C#高级编程（第7版）》笔记 一、C#与.netC#: 一种编程语言，可以开发基于.net平台的应用 .net能干啥？ 桌面应用程序：C/S程序，比如QQ，办公软件等（Winform应用程序） Internet应用程序：B/S程序，即网站 二、入坑编程语言国际惯例——Hello World！开发IDE：Visual Studio 2019 创建项目步骤： 打开VS2019 &gt; 创建新项目 &gt; 平台选择Windows &gt; 语言选择C# &gt; 项目类型选择控制台 &gt; 自定义项目名、路径，选.Net框架4.7.2 &gt; 完成 此时模板生成： 123456789101112131415using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp1&#123; class Program &#123; static void Main(string[] args) &#123; &#125; &#125;&#125; 于是我在Main函数下添加了两句 12Console.WriteLine(\"Long may the sun shine!\"); //控制台打印\"Long may the sun shine!\"Console.ReadKey(); //等待任意键继续 Ctrl + S 保存，点击功能栏的【启动】，运行程序 三、VS中常用快捷键 Ctrl + D：拷贝一行 Ctrl + K + C : 注释选中代码 Ctrl + K + U : 取消对所选代码的注释 折叠冗余代码：#region 和 #endregion ///：方法描述注释 输入try后按Tab键：快速生成try catch语句 四、VS界面各部分讲解 解决方案、项目、类之间的关系 解决方案包含项目，一个解决方案可以有多个项目。 项目包含类，一个项目可以包含多个类。 Properties: 属性 App.config: 配置文件 Program.cs: 类文件 引用命名空间（地址） namespace: 项目名称 Class Program: Program类 Main函数：程序主入口","categories":[],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"}]},{"title":"【GDC】Designing Unforgettable Titanfall Single Player Levels with Action Blocks","slug":"【GDC】Designing Unforgettable Titanfall Single Player Levels with Action Blocks","date":"2020-01-08T13:47:26.000Z","updated":"2020-01-08T14:35:32.283Z","comments":true,"path":"2020/01/08/【GDC】Designing Unforgettable Titanfall Single Player Levels with Action Blocks/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/08/%E3%80%90GDC%E3%80%91Designing%20Unforgettable%20Titanfall%20Single%20Player%20Levels%20with%20Action%20Blocks/","excerpt":"","text":"How to Action BlocksAction Blocknoun A form of rapid prototyping used to encourage creative play ‘Game jam’ style design sprints used throughout development to explore gameplay Common slang for reaching the highest level in Tetris One Week (or less) - Mostly Single Designer - Mostly Must Have a Skill Test No Skits or Cool Moments No Context Necessary - But not discourage Make it Playable - Mostly Show &amp; Tell Freeform Exploration! Make a Roadmap Create a Library Set Boundaries Defining Moment Going Deep Into the Abyss Abstract Thematic Exploration Kill Your (metaphorical) Babies Quick Mash-ups The Grand Rebeal One-upmanship Production Bloat Contextualization Action Blocks are not Level Design","categories":[],"tags":[{"name":"Game Design","slug":"Game-Design","permalink":"https://weimingjuncn.github.io/tags/Game-Design/"}]},{"title":"如何用Markdown画流程图","slug":"如何用Markdown画流程图","date":"2020-01-08T07:58:36.000Z","updated":"2020-01-08T08:09:41.056Z","comments":true,"path":"2020/01/08/如何用Markdown画流程图/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/08/%E5%A6%82%E4%BD%95%E7%94%A8Markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/","excerpt":"","text":"用Markdown画流程图可以用mermaid，mermaid支持三种图形的绘制, 分别是流程图, 时序图和甘特图 一、如何在markdown中使用mermaid ‘’’mermaid graph 流程图方向 流程图的内容‘’’ 流程图方向有以下几个值： TB 从上到下 BT 从下到上 RL 从右到左 LR 从左到右 TD 同TB例子 123mermaidgraph TD A --&gt; B graph TD A --> B 123mermaidgraph LR A --&gt; B graph LR A --> B 框图的基本边框 id + [文字描述]矩形 id + (文字描述)圆角矩形 id + &gt;文字描述]不对称矩形 id + {文字描述}菱形 id + ((文字描述))圆形 例子1234567mermaidgraph TD id[矩形] id4(圆角矩形) id3&gt;不对称的矩形] id1&#123;菱形&#125; id2((圆形)) graph TD id[矩形] id4(圆角矩形) id3>不对称的矩形] id1{菱形} id2((圆形))","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://weimingjuncn.github.io/tags/markdown/"}]},{"title":"【GDC】Level Design Workshop：Blockmesh and Lighting Tips","slug":"【GDC】Level Design Workshop：Blockmesh and Lighting Tips","date":"2020-01-08T06:58:13.000Z","updated":"2020-01-08T10:02:16.645Z","comments":true,"path":"2020/01/08/【GDC】Level Design Workshop：Blockmesh and Lighting Tips/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/08/%E3%80%90GDC%E3%80%91Level%20Design%20Workshop%EF%BC%9ABlockmesh%20and%20Lighting%20Tips/","excerpt":"","text":"Invisible Intuition：Blockmesh and Lighting Tips to Guide Players and Set the MoodWhat is “Blockmesh” ? Blockmesh = Greybox = Whitebox, etc. Greybox and Whitebox implt a single color - not ideal! 灰盒和白盒一般只有一种颜色，不够理想 Level Design Pipeline graph LR A(Level Requirements) --> B(Build Blockmesh Layout 搭建Blockmesh布局) B --> C(Playtest Layout 测试布局) C --> D(Process Feedback 处理反馈) D --> B Environment Type 环境需求 Time of Day 当日时间 Location in Story 故事地点 Available Character Abilities 允许玩家使用的能力 Enemy Type 敌人种类 etc. Gameplay and Narrative Beats 游戏性以及叙事性的节拍 Affordance 可见性 Form implies function 形式暗示着功能 Affordance … in Games A way to communicate to the player what to play with or where to go. 一种告诉玩家玩什么或到哪去的方法 Players learn the affordance rules via consistent color and shape and a trust contract is formed. 玩家通过相同的颜色和形状来学习可见性规则，同时信任该规则 Ensure affordances work consistently game-wide. 确保可见性规则在游戏内保持一致 Add to your blockmesh for playtests! 在游戏测试中添加到你的blockmesh中 Denying Affordance 拒绝式可见性 Communicates to the player where NOT to go. 告诉玩家不能去的地方 “Uninvites” the player from going there. 不允许玩家去哪 Contextualize why the player can’t use it/go there! 根据情境告诉玩家为什么不能使用某物或去某地 Add to your blockmesh for playtests! 在游戏测试中添加到你的blockmesh中 Visual Language - Shape 绿色圆形代表安全 黄色矩形代表稳定、实用 红色三角形代表危险 Landmarks (aka weenies) 地标 Orients Players. 引导玩家 Distant object seen from many vantage points in the level. 从关卡的许多视角都能看到 A goal to work toward. 一个努力前往的目标 Openings Attract 开放式吸引 Caves, doors, archways拱门, etc. Often leads to a REFUGE SPACE, which psychologically feels safe. 通常导向一个心理上感到安全的避难所 Mystery神秘感 - “What could be inside?!” Gates &amp; Valves Gates stop progress until conditions are met. 在满足条件以前，门不会打开 Valves prevent backtracking. Both reduce the possibility space and prevent aimless wandering瞎逛. Great for linear games, but can be sprinkled运用 into open worlds too! Leading Lines 引导线 Lines that draw your eye to the intended point of interest. Roads, pipes, cables, etc. Pinching 挤压视线 Angle shapes to funnel players to a specific spot.利用角度吸引玩家到特定地点 Good for redirection. 适合重新引导 Great for setting up a reveal. 非常适合设置展示 Depends on your mobility mechanics! 根据你的移动机制 Framing &amp; Composition 框架以及构成 Draws attention to point of interest by blocking other parts of the image, making it stand out. Google photography composition techniques - lots of good websites! Great when combined with Pinching! Breadcrumbs 面包屑 Attract/lead the player, a piece at a time, to a goal.一点点引导玩家到目的地，可以是任何能博眼球的东西 Can be almost anything that draws the eye: Stuff that breaks up the negative space of floor/walls. 打破地板的东西 Pickups 可以捡起的东西 Enemies 敌人 Lit areas 明亮的区域 Usually better to add after early playtests of blockmesh to see if they are even needed. 最好在早期的游戏测试之后，根据需要添加 Textures 材质 just point the way to go! Examples: Arrows pointing the way. Scrapes on the ground/walls. 地上或墙上的抓痕 Signs 标记 etc. Movement Use movement to grab the eye. Examples: Big scripted moments. 大型脚本 Birds Spark FX 火花特效 Enemies Something flapping in the breeze 微风中漂浮的东西 Directionality guides the eye to where you want players to go or what you want them to see. Light &amp; God Ray 光照以及光线 Players are attracted to the light. God rays draw attention and a line to the goal. Important in blockmesh phase阶段! Bonus Tips！——The Squint Test 眯眼测试 Step 1: Squint眯 your eyes and look at the game. Step 2: Everything wil be blurry模糊, but what stands out? Step 3: Adjust your layout布局 and lighting光源 to highlight强调 what you want players to focus on.","categories":[],"tags":[{"name":"Game Design","slug":"Game-Design","permalink":"https://weimingjuncn.github.io/tags/Game-Design/"}]},{"title":"UE4蓝图 第2课","slug":"UE4蓝图 第2课","date":"2020-01-08T02:27:44.000Z","updated":"2020-01-08T02:57:53.081Z","comments":true,"path":"2020/01/08/UE4蓝图 第2课/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/08/UE4%E8%93%9D%E5%9B%BE%20%E7%AC%AC2%E8%AF%BE/","excerpt":"","text":"主讲人：神经刀游戏工作室https://www.bilibili.com/video/av33992806 接上一堂课 接下来给角色赋予其他行动功能 进入【项目设置】的【引擎】【输入】，在Axis Mappings下自定义添加一个“MoveRight” 添加按键【键盘A】,Scale设置为-1.0 添加按键【键盘D】,Scale设置为1.0 在Axis Mappings下自定义添加一个“Turn” 添加【鼠标X】,Scale设置为1.0 在Axis Mappings下自定义添加一个“LookUp” 添加【鼠标Y】,Scale设置为-1.0 进入“APlayerController”，在事件图表下，添加坐标轴事件“MoveRight” 复制粘贴一个“Add Movement Input“ 添加一个Pawn操作“Get Control Rotation”、一个”Get Right Vectot” 添加坐标轴事件”Turn“和”LookUp“ 添加”Add Yaw Input”、”Add Pitch Input”、”Add Roll Input” Pawn控制角色的行动，PlayerController控制控制器的旋转功能 连线如图 进入APlayer，选中【SwingArm】，在【细节】【Camera Settings】把【Use Pawn Control Rotation】打勾，编译，保存 此时点【播放】，角色可以左右平移，角色正面紧随摄像机视角改变朝向 进入APlayer，选中【组件】下的【CharacterMovement】,在【细节】【Character Movement(Rotation Settings)】 【Rotation Rate】【Z】改成1000。(修改角色转身速率) 【Orient Rotation to Movement】打勾 选中【组件】下的【APlayer(自身)】，在【细节】【Pawn】下把【Use Controller Rotation Yaw】取消打勾，编译，保存。 此时点【播放】，角色正面不紧随摄像机视角改变朝向，只有在行动时转身改变朝向 怎么给蓝图写注释？ 选中/框选要注释的操作，按【C】产生注释框，注释框可以嵌套 选中注释框，在右边【细节】【Comment Color】改注释区域的颜色、透明度 在APlayer里选中【组件】【Mesh】，在【细节】【Mesh】里可以点击放大镜按钮，可以定位并选中当前使用的模型 双击”SK_Mannequin“打开模型 模型五大部分：骨架、网格体、动画、蓝图、物理 骨架上填满了”肉“就成了网格体，骨骼是根本，一个骨骼对应多个网格体多个动画多个物理多个蓝图（动画蓝图），一个动画仅对应唯一一个骨骼，动画跟着骨骼走。 点击【浏览】按钮可以定位选中具体的文件","categories":[{"name":"Game Develop","slug":"Game-Develop","permalink":"https://weimingjuncn.github.io/categories/Game-Develop/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://weimingjuncn.github.io/tags/UE4/"}]},{"title":"UE4蓝图 第1课","slug":"UE4蓝图 第1课","date":"2020-01-08T02:26:44.000Z","updated":"2020-01-08T02:57:10.767Z","comments":true,"path":"2020/01/08/UE4蓝图 第1课/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/08/UE4%E8%93%9D%E5%9B%BE%20%E7%AC%AC1%E8%AF%BE/","excerpt":"","text":"主讲人：神经刀游戏工作室https://www.bilibili.com/video/av33932971 创建项目（蓝图、第三人称模板） 下方【内容浏览器】右键新建 “Player”文件夹（存放角色） “Map”文件夹（存放关卡） “Gameplay”文件夹（存放玩法） Map文件夹下右键新建一个【关卡】 左边【模式】下，从【光照】拖拽出： 一个【定向光源】 一个【天空光源】 从【视觉效果】拖拽出一个【大气雾】 从【基本】拖拽出一个【立方体】 右边【细节】里把立方体的位置归零（点击“回车符号按钮”） 键盘上按【W】切换到调整位置坐标系 按【E】切换到调整旋转角度坐标系 【R】切换到调整大小坐标系 把立方体调成一个供角色落脚的平台 从左边【基本】里拖拽出一个【玩家起始】 “GamePlay”文件夹下右键新建一个【蓝图类】，选择【Game Mode Base】 Player文件夹下右键新建： 一个【蓝图类】的【Character】，取名“APlayer”， 一个【蓝图类】的【Player Controller】，取名“APlayerController” 双击进入“APlayer”， 选中左边【组件】里的【Mesh】， 右边【细节】中【Mesh】下Skeletal Mesh选择”SK_Mannequin”, 【细节】中【变换】下的【旋转Z轴】改成“-90°“，【位置Z轴】改成”-92” 选中左边【组件】里的【CapsuleCoponent】，点击上方【添加组件】按钮，选择【SwingArm】 在新添加的SwingArm组件下新建一个【Camera】 把SwingArm垂直调节到与角色肩差不多同高度的位置 编译，保存 点击工具栏的【编辑】，进入【项目设置】，进到左边【引擎】下的【输入】 在”Axis Mapping“下自定义添加一个“Moveforward”, 添加一个按键，选择【键盘W】，”Scale“设置为“1.0” 添加一个按键，选择【键盘S】，“Scale”设置为“-1.0” 进入“APlayerController”，在【事件图表】下，右键添加一个操作【坐标轴事件】“Moveforward” 【坐标轴事件】“Moveforward”这个操作是玩家的一种输入 右键添加一个操作【Pawn】“Get Controlled Pawn” Charactor是一种特殊的Pawn，所以用“Get Controlled Pawn”即可 APlayerController蓝图： 进入APlayerMode，选中【工具栏】面板下的【类默认值】，在【细节】里【Classes】下 把Player Controller Class改成自己建的“APlayerController” 把Default Pawn Class改成自己建的“APlayer” 编译，保存 回到自己建的关卡，把【细节】旁边的【世界设置】里把GameMode Override默认的“None”改成自己建的“APlayerMode” 如果【细节】旁边没有【世界设置】，可以编辑器最上方第二栏的【窗口】里调出 编译、保存 此时在自建的关卡里可以点击播放后用W/S操控角色前后平移。","categories":[{"name":"Game Develop","slug":"Game-Develop","permalink":"https://weimingjuncn.github.io/categories/Game-Develop/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://weimingjuncn.github.io/tags/UE4/"}]},{"title":"配置Git的SSH Key","slug":"配置Git的SSH Key","date":"2020-01-07T16:28:11.000Z","updated":"2020-01-07T16:33:50.381Z","comments":true,"path":"2020/01/08/配置Git的SSH Key/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/08/%E9%85%8D%E7%BD%AEGit%E7%9A%84SSH%20Key/","excerpt":"","text":"生成SSH并添加到GitHub回到你的git bash中， git config –global user.name “yourname”git config –global user.email “youremail” 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 可以用以下两条，检查一下是否输对 git config user.namegit config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C “youremail” 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去 作者：程序员黄小斜链接：https://www.jianshu.com/p/5efd8c6eb3e9来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://weimingjuncn.github.io/tags/Hexo/"},{"name":"git","slug":"git","permalink":"https://weimingjuncn.github.io/tags/git/"}]},{"title":"【GDC】Platinum Games：Action Without Borders","slug":"【GDC】Platinum Games：Action Without Borders","date":"2020-01-07T16:24:13.000Z","updated":"2020-01-07T16:31:43.631Z","comments":true,"path":"2020/01/08/【GDC】Platinum Games：Action Without Borders/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/08/%E3%80%90GDC%E3%80%91Platinum%20Games%EF%BC%9AAction%20Without%20Borders/","excerpt":"","text":"What is an Action Game? A set of actions responding to output 一系列针对输出的动作 Passive activity 被动行为 This sounds like the exact opposite of action Activity based on prior (active) input Adventure/Horror games This is opposite to the impression horror games give off What are “action skills”? The player’s ability to deal with a given situation Gameplay Systems What are gameplay systems? The selling point of a game The unique elements that define a game Expanding features Lateral expansion to prevent games from becoming too linear Depth If a game has selling points A/B/C, expanding features D/E, and depth elements F/G: Players complete the game having experienced A and B They’ve completed and enjoyed the game Players complete the game having experienced A,B, and C They’ve completed the game and feel like they got a lot of it Players complete the game having experienced A,B,C and D They’ve complete the game, and become good at it in a variety of ways Players complete the game having experienced A,B,C,D and E “Wow! I didn’t know you could do that! This game is awesome!!” Players complete the game having experienced A,B,C,D,E and F “I am a god among mortals!” How to approach the selling points of an action game It’s not about functional design The question “What abilities shall we give the player?” never comes first It’s about situational design The first thing to figure out is: “What kind of situations do we put the player in, and what are we going to make them do?” One more important things about the design of selling points: When creating a game in a series, you already have an existing ability set to work with ,so: It’s easy to fall into the trap of changing A to A’ or A+B, but this is a mistake Always give top priority to situational design Replay Value What is replay value? The point is not to force the player to keep playing Replay value has to be linked to fun activities It’s essential that the player get to imrove their skills This requires a structure that lets the player enjoy all of elements A,B,C,D,E, and F Make the game feel like it was tailor-made for the player 让游戏感觉像是为玩家量身定做的 Characters Action games let players enjoy a character’s superpowers Fulfilling the desire to transform This requires main characters with rich personalities Fight your way through any situation The order of designing unique characters with superpowers Imagine the situation Create an image board Design the game’s selling points Functional design Start designing the characters Character art design directly and strongly affects the user experience Story What purpose does story have in an action game? The most important purpose is “Motivation” Deep stories with lots of twists are not required 不需要有很多曲折的故事 The story should turn the designed situation into motivation in a natural way 故事应该以自然的方式将设计好的情境转化为动机 High-level Design Not the same as level design Considering the game flow in the largest possible unit 思考可能最大的游戏流程单位 Simply bombarding players with constant excitement become numbing after a while 仅仅持续性使玩家兴奋，会使玩家过一会儿就对兴奋点麻木 Create a tempo per stage 每个关卡制造一个节奏 Pacing is very important 节奏很重要 Stage “Strength” 关卡强度 关卡序号 设置强度（1-10） 玩家感受 St. 1: 6 7 St. 2: 4 4 St. 3: 6 5 St. 4: 7 8 制作成本：6+4+6+7=23 制作效果：7+4+5+8=24 Stage “Strength”(example of failed build-up) St. 1: 5 6 4 St. 2: 6 5 5 St. 3: 7 5 5 St. 4: 8 6 4 5+6+7+8=26 4+5+5+4=18 With Transformers we focused on density We didn’t want players to put down the controller Summary","categories":[],"tags":[{"name":"Game Design","slug":"Game-Design","permalink":"https://weimingjuncn.github.io/tags/Game-Design/"}]},{"title":"【知乎Live】欧美3A游戏公司的游戏设计与制作","slug":"【知乎Live】欧美3A游戏公司的游戏设计与制作","date":"2020-01-07T16:17:48.000Z","updated":"2020-01-07T16:22:55.180Z","comments":true,"path":"2020/01/08/【知乎Live】欧美3A游戏公司的游戏设计与制作/","link":"","permalink":"https://weimingjuncn.github.io/2020/01/08/%E3%80%90%E7%9F%A5%E4%B9%8ELive%E3%80%91%E6%AC%A7%E7%BE%8E3A%E6%B8%B8%E6%88%8F%E5%85%AC%E5%8F%B8%E7%9A%84%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%B6%E4%BD%9C/","excerpt":"","text":"主讲人：Clark 杨佳阳 https://www.zhihu.com/lives/787986309099560960 AAA项目的团队组成是什么样子？ 团队之间的职能细化如何？ AAA游戏的制作过程是什么样子？ 不同公司团队之间的开发流程，组别在哪里？ 行业前景如何？ 问答环节 一、关于设计的问题1. 立项前要进行很详细的市场调查什么样的游戏可以赚钱？什么样的游戏更容易打开市场？什么样新的IP可以立足于市场？总部、市场部、总部设计主管、团队设计主管进行大量的讨论、分析，然后做出一个详细的大框架（PPT一页纸概括）。比如说，我们要做一个游戏有40个小时的游戏时长，不希望这个游戏一个周末就可以打完。游戏的历史背景，我们要做第三人称，我们是否要做射击、格斗？必须要有RPG养成要素？ 2.做一个highlevel的宏观的设计方向（做target footage）用3DMax/Maya做一个假的游戏设想的视频，要透露出游戏的玩法、美术风格、整个游戏格调。视频要在5~10分钟把这个游戏讲得很明白。 回到总部，与市场部协调，看看这个假的游戏是否符合初衷。如果市场稳定，这个游戏有前景，基本可以协调通过且拿到后续的资金。如果这时候市场有变动就需要调整，即回炉重来。如果这一阶段有问题，说明初衷是错误的。 3. pre-production阶段进行大量的原型设计（prototype），占80%~90%的时间，最有趣，最困难的时期。每个人都有很多想法，比如说我想做成实时加载，每一个NPC都会有介绍等，完全天马行空，但由于时间问题技术问题，很多东西做不出来，因为需要大量的程序资源和大量的美术资源加进去。对于设计来说，这个阶段最自由，可以把很多想法比如5年前10年前的想法用最快的方法做出来。在这个阶段，每个项目的总监（创意总监、游戏性总监）需要承担很大的责任，因为不可能让所有人都去随便做自己想做的东西，这很浪费时间。因此，需要反复看原型，看是否会做成最终成品。原型阶段没有大量资源，这个雏形一定非常丑，达不到可以发售的质量。我们必须分析出哪些丑陋的“小孩”（原型）以后可以长成“大美女”（高质量成品）。这很关键，如果我们能选择出真正有潜力的feature（特征）、功能，这对后边的production有很大帮助。 花一年时间都不算长，因为很多尝试性的东西，不仅是设计上的尝试，还有技术上比如引擎需要完善，美术的一整套要完善，动画甚至最基本的面部表情技术也要达到很稳定阶段。否则后边production阶段会非常头疼。 在pre-production结束时把假的游戏做成真正可以玩的2示（demo），把演示拿给市场部、宣传部、给公司大佬们看，然后重新从方向上从底层设计上是否合格，最初的设计可能因为市场变化变成错误的，这个阶段需要决定什么需要改，什么可以继续往下做。如果演示大家都很认可，就可以进入Production。 这个演示可能只有20分钟到1个小时的gameplay。在进入Production阶段前，其他部门也要做好准备，比如：第一，在设计上在这一阶段最好的情况是所有的细节所有的功能至少在纸面上都已经设计好了；第二，引擎逐渐完善，如何动态加载，如何管理这些内存，一系列type上的东西都需要准备好。美术上，我们要做多大的地图，能够做多大的地图，团队应该如何分配，这一系列问题，都需要准备好。实际中很普遍地是，很多项目的准备都没来得及做好。很多东西在production开始之前没有答案，因此production时需要冒一些风险,在production中把一些东西完善掉。虽然这种情况经常出现，但因为我们知道游戏要往哪里走，知道要做些什么，风险可以控制。 4. Production（半年到一年之内全部完成）大军推进，美术设计、关卡设计、动画、人物等各部门全部开始大规模production，速度非常快，工作量非常大，非常无趣。游戏的feature（特征）、content（内容）全部做完以后进入alpha阶段。 5. alpha阶段（花3个月到半年）开始debug，QA（游戏测试、质量保证）大面积进入。很多时候还是要修改一些东西，发现当初设计的东西有些事不完善的，需要重新改。因为所有资源都已经存在，改起来更容易。游戏可能会在这个阶段发生翻天覆地的变化。 6. beta阶段大部分团队不再工作，他们可能去休假或者去新的项目。需要一个closing team，完完全全是在修bug，一个一个修。能够留下来去close这个项目的人都非常强 7. master阶段游戏做完，项目结束。 二、问答环节1. AAA团队有哪些人构成？市场部、运营部、创意总监、游戏总监、美术总监、技术总监 2. 团队协作方式，怎么管理创意？每个团队都有自己管理创意的方式，不能一概而论，大部分创意总监会倾向于独裁，只是看独裁到什么程度。 每一个人都有想法，AAA最头疼的问题是如何让很多人做同一款游戏。太民主永远达不到一个统一的风格，需要一个创意总监拿主意拍板。 设计上选择千万不要去猜！做决策，管理团队，必须需要有很强大的数据做背景来支持，知道什么样的游戏有前景什么样的游戏赚钱，不能靠拍脑袋决定。 美术细节需要多个工作组和总监协调出来。 做游戏，需要沟通，大部分时间都在说话，大部分坐着的都是美工。大方向以及细节需要总监决定。 3. 单机游戏中storytelling和gameplay如何结合？首先要根据游戏要做成什么样子，顽皮狗工作室的游戏gameplay为story服务，其他一些游戏gameplay比story更注重。在一个游戏在最开始确定方向以后，我们就会知道这个游戏是更注重故事还是游戏性，如果注重游戏性，故事会在开发中进驻很晚。一般在production进行到一半，游戏界面成型的时候，故事才进来把游戏串起来。如果完完全全是一个讲故事的游戏，在production之前没有一个完整的gameplay，但但故事流程从a到z全部都是完善的，然后根据故事需要去设计需要什么样的游戏性。 4. 策划需要的参考大部分来源？Google、YouTube。如果找不到参考，策划和设计、美术、动画在一个会议室里在一块黑板之前画简笔画，用简单的语句表达你想要的是什么。 原型快成型的时候撰写文档，把细节让其他部门去做。 5. 关卡设计细节问题关卡细节问题可大可小。关卡设计很大程度上需要去协调各个部门。把所有零件拼在一起的重要工作。 一定是先确定核心玩法，谜题机制，再确定关卡设计！ 原型设计阶段需要有一个惯性：每一个人有一个想法时，第一版一定是丑的，有没有动力有没有能力在很快的时间之内（一两天内）找到问题解决问题，把它做得更好，这个原型就有一个惯性，当惯性能够保持住时，这个原型到最后的结果就比其他原型好，要重复验证需要时间，第一版花一到两周，然后在一两天必须看到新的版本。如果在一个月之内看不到这个原型有很强的的生命力，或惯性的话，一般情况下这个原型是失败的。 6. 团队和周期：例子：育碧蒙特利尔随随便便一个项目上1000人，要在各个工作室的协调之中完成。 分工：从团队机构上：最上头：创意总监，游戏总监、美术总监、技术总监、关卡总监、动画总监 总监之下：游戏设计师、系统程序员（引擎）、gameplay程序员（gamplay逻辑）、音效程序员、网络程序员、关卡设计、任务设计、世界观设计、动画设计，动画美术、镜头师等 成本：很容易上5000W 国外制作人（producer）只管资金和工作进度，还有管理人员之间沟通问题，不管也不可以插手游戏设计。 所有的项目都会延期，游戏太庞大，火箭级别的项目。 周期：短的2年，长的4~5年（特别是新IP） 延期风险怎么解决？ 大的延期，制作人和总监能很早预测到，预测完不成就提前去和团队协调，砍掉一些内容。 每当遇到危机都需要方向上的调整，需要看制作人和总监的能力力挽狂澜。 其他： AAA项目非常难做，涉及大量资金大量人员，团队少则一两百人，多则上千人。 1亿美金的项目，需要卖到500万份才能回本，每份开发者只赚20美金，其他利润归物流，零售商、发行商。 没见过好的项目不加班的。 经常加班，每天工作14小时，项目完结有假期，一年三周。 进入production以后，文档的效率非常低，没有必要改文档，大家没有时间看，要改直接交流沟通。 设计者只是设计了规则，玩家在规则中达到自己想要的。","categories":[],"tags":[{"name":"Game Design","slug":"Game-Design","permalink":"https://weimingjuncn.github.io/tags/Game-Design/"}]},{"title":"刷《算法笔记》小结习题，写代码常犯的错误","slug":"刷《算法笔记》小结习题，写代码常犯的错误","date":"2019-08-23T14:00:01.000Z","updated":"2019-08-23T14:02:16.405Z","comments":true,"path":"2019/08/23/刷《算法笔记》小结习题，写代码常犯的错误/","link":"","permalink":"https://weimingjuncn.github.io/2019/08/23/%E5%88%B7%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E5%B0%8F%E7%BB%93%E4%B9%A0%E9%A2%98%EF%BC%8C%E5%86%99%E4%BB%A3%E7%A0%81%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"","text":"问题 E: 例题3-5 求一元二次方程的根题目描述求一元二次方程ax2+bx+c=0的根，三个系数a, b, c由键盘输入，且a不能为0，且保证b2-4ac&gt;0。 程序中所涉及的变量均为double类型。 输入以空格分隔的一元二次方程的三个系数，双精度double类型 输出分行输出两个根如下（注意末尾的换行）： 123r1&#x3D;第一个根r2&#x3D;第二个根 结果输出时，宽度占7位，其中小数部分2位。 样例输入11 3 2 样例输出12r1&#x3D; -1.00r2&#x3D; -2.00 自写答案：1234567891011121314#include&lt;cstdio&gt;#include&lt;cmath&gt;int main()&#123; double a, b, c, r1, r2; scanf(\"%lf %lf %lf\", &amp;a, &amp;b, &amp;c); if((a != 0) &amp;&amp; (pow(b,2.0)-4*a*c &gt; 0))&#123; r1 = ((-b)+sqrt(pow(b,2.0)-4*a*c))/(2*a); //注意sqrt()容易写错成sqrt() r2 = ((-b)-sqrt(pow(b,2.0)-4*a*c))/(2*a); printf(\"r1=%7.2f\\n\", r1); //打印的结果占7位，其中小数部分占2位 printf(\"r2=%7.2f\", r2); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://weimingjuncn.github.io/tags/C/"}]},{"title":"CodeBlocks的入门操作","slug":"CodeBlocks的入门操作","date":"2019-07-30T13:16:17.000Z","updated":"2020-01-07T16:11:08.223Z","comments":true,"path":"2019/07/30/CodeBlocks的入门操作/","link":"","permalink":"https://weimingjuncn.github.io/2019/07/30/CodeBlocks%E7%9A%84%E5%85%A5%E9%97%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"安装好CodeBlocks 16.0.1后打开软件，新建工程：File -&gt; New -&gt; Project… 选择“Console application”，一路“Next”来到如下界面： 手动选择工程的保存路径，注意第二行新建工程的路径和最后一行保存工程文件的路径要保持一致如下图，否则后续编译运行程序时容易报奇怪的错。 设置好以后点击“Next”，编译器设置默认，点击“Finish” 新建项目完成后，可以看到source文件夹下有一个自动建好的带主函数的源文件main.cpp。可以把它删掉后另建：单击选中main.cpp，右键调出菜单选择“R二move file from project” 新建一个.cpp(或.c)文件:File -&gt; New -&gt; File… 选择“C/C++ source”，一路“Next”，选择源文件保存路径（建好的工程文件夹）并添上文件名“test01.cpp”（看见刚才的“main.cpp”记得删掉）。 此时，新建的源文件还没有在工程里，需要手动添加进去。选中工程，右键调出菜单，选择“Add files…”。选择“test01.cpp”,点击“打开”源文件就添加好了。 在“test01.cpp”写好代码,编译无报错后运行即可。","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://weimingjuncn.github.io/tags/C/"},{"name":"CodeBlocks","slug":"CodeBlocks","permalink":"https://weimingjuncn.github.io/tags/CodeBlocks/"}]},{"title":"在Win 10中使用命令行界面编译、运行一个cpp文件","slug":"在Win 10中使用命令行界面编译、运行一个cpp文件","date":"2019-07-05T12:38:44.000Z","updated":"2019-07-05T12:42:53.575Z","comments":true,"path":"2019/07/05/在Win 10中使用命令行界面编译、运行一个cpp文件/","link":"","permalink":"https://weimingjuncn.github.io/2019/07/05/%E5%9C%A8Win%2010%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAcpp%E6%96%87%E4%BB%B6/","excerpt":"","text":"源文件准备新建一个文件取名hello.cpp，代码如下： 123int main()&#123; return 0;&#125; 编译器准备Visual C++组件包含一个C++命令编译器，这个编译器还可用于创建基本的控制台程序、通用Windows平台程序、桌面程序、设备驱动和.NET组建。 从微软的Visaul Studio官网下载Visual Studio Community 2017。 安装过程中注意勾选“Desktop development with C++” 打开开发者命令提示符点击“开始”菜单，在程序列表找到并点击Visual Studio 2017文件夹下的“VS 2017的开发人员命令提示符” 输入如下命令以验证VC++的开发者命令提示符已设置妥当： 1cl 窗口会反馈如下： C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community&gt;clMicrosoft (R) C/C++ Optimizing Compiler Version 19.15.26732.1 for x86Copyright (C) Microsoft Corporation. All rights reserved. usage: cl [ option… ] filename… [ /link linkoption… ] 编译cpp源文件安装完编译所需的工具后，在开发者命令提示符界面中输入命令，将当前目录切换到源代码文件所在的目录。 12d:cd d:\\ProgrammingLearning\\cpp 输入以下代码编译源文件： 1cl &#x2F;EHsc hello.cpp 窗口反馈如下，则表示编译成功： Microsoft (R) C/C++ Optimizing Compiler Version 19.15.26732.1 for x86Copyright (C) Microsoft Corporation. All rights reserved. hello.cppMicrosoft (R) Incremental Linker Version 14.15.26732.1Copyright (C) Microsoft Corporation. All rights reserved. /out:hello.exehello-world.obj 运行程序成功编译后在命令行界面执行命令： 1hello 程序顺利执行，通过echo命令获取main函数的返回值(0)。 1echo %ERRORLEVEL%","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://weimingjuncn.github.io/tags/C/"}]},{"title":"Hexo搭建个人博客注意事项记录","slug":"Hexo搭建个人博客注意事项记录","date":"2019-03-19T18:56:44.000Z","updated":"2019-01-14T08:19:00.000Z","comments":true,"path":"2019/03/20/Hexo搭建个人博客注意事项记录/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/20/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E8%AE%B0%E5%BD%95/","excerpt":"","text":"如何插入图片？安装hexo-asset-image插件 1npm install hexo-asset-image --save 确保Hexo博客总目录下的_config.yml中的post_asset_folder的值为true（默认是false）。 然后在要插入图片的文章的目录下新建一个同名文件夹，并在其中放入要插入的图片，例子： MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md 直接用语句![logo](logo.jpg)插入图片logo.jpg。 —2020-01-10 更新— 邮件链接格式1mailto:xxx@xxx.com —2020-01-14 更新— .md文件名如果包含特殊字符，需要转义例如，文件名“C#入坑与VS的使用.md”需要改成“C%23入坑与VS的使用.md”。否则点击文章标题进入页面时，发送一个get请求，参数包含“#”，结果无法成功进入文章页面。 原理：将特殊的字符转换成ASCII码，格式为：%加字符的ASCII码，即一个百分号%，后面跟对应字符的ASCII（16进制）码值。例如 空格的编码值是”%20”。 URL特殊符号及对应的十六进制值编码： 12345678+ URL中+号表示空格 %2B 空格 URL中的空格可以用+号或者编码 %20 &#x2F; 分隔目录和子目录 %2F ? 分隔实际的 URL 和参数 %3F % 指定特殊字符 %25 # 表示书签 %23 &amp; URL中指定的参数间的分隔符 %26 &#x3D; URL中指定参数的值 %3D 参考链接：https://segmentfault.com/a/1190000010854567 尽管这样做可以解决跳转的问题，但文章中的所有图片依旧无法显示，因此给md文件和存图片的文件夹取名应尽力避免夹带特殊符号。 tags包含特殊字符“#”需要转义例如，以“C#”为一个标签名，则应写成 1tags: C&amp;#35; 原理：对特殊符号进行转义，用对应的HTML字符实体进行替换 各种常用特殊字符对应的HTML字符实体： 123456789101112131415161718192021222324! &amp;#33; — 惊叹号 Exclamation mark&quot; &amp;#34; &quot; — 双引号 Quotation mark# &amp;#35; — 数字标志 Number sign$ &amp;#36; — 美元标志 Dollar sign% &amp;#37; — 百分号 Percent sign&amp; &amp;#38; &amp; — 与符号(&amp;) Ampersand&#39; &#39; — 单引号 Apostrophe( &amp;#40; — 小括号左边部分 Left parenthesis) &amp;#41; — 小括号右边部分 Right parenthesis* &amp;#42; — 星号 Asterisk+ &amp;#43; — 加号 Plus sign&lt; &amp;#60; &lt; 小于号 Less than&#x3D; &amp;#61; — 等于符号 Equals sign- &amp;#45; &amp;minus; — 减号&gt; &amp;#62; &gt; — 大于号 Greater than? &amp;#63; — 问号 Question mark@ &amp;#64; — Commercial at[ &amp;#91; — 中括号左边部分 Left square bracket\\ &amp;#92; — 反斜杠 Reverse solidus (backslash)] &amp;#93; — 中括号右边部分 Right square bracket&#123; &amp;#123; — 大括号左边部分 Left curly brace| &amp;#124; — 竖线Vertical bar&#125; &amp;#125; — 大括号右边部分 Right curly brace空格 &amp;nbsp; 参考链接：https://segmentfault.com/a/1190000020528571?utm_source=tag-newest","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://weimingjuncn.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://weimingjuncn.github.io/tags/Hexo/"}]},{"title":"模块调用","slug":"模块调用","date":"2019-03-19T18:47:36.000Z","updated":"2019-06-10T14:14:30.780Z","comments":true,"path":"2019/03/20/模块调用/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/20/%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/","excerpt":"模块调用例子","text":"模块调用例子 login.py： 123456789101112131415161718192021import getpass_username = \"Mingjun Wei\"_password = 123456count = 3while(count): usrname = input(\"Please enter your username :\") pwd = int(getpass.getpass(\"password:\")) if _username == usrname and _password ==pwd : print(\"Welcome home, &#123;0&#125; !\".format(usrname)) break; else: print(\"invalid username or password!\") count -= 1if count == 0: msg='''You have try 3 times.Please run the program again.''' print(msg) MyLoginDemo.py: 1234import login'''调用login模块时，先在当前目录查找login模块，找不到再去第三方库目录查找。''' MyLoginDemo.py运行后和单独运行login.py效果相同。 调用login.py后当前目录出现_pycache_文件夹，文件夹里产生一个login.cpython-36.pyc文件","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"}]},{"title":"需要注意的基本运算&操作","slug":"需要注意的基本运算-操作","date":"2019-03-19T18:34:27.000Z","updated":"2019-06-10T14:14:45.502Z","comments":true,"path":"2019/03/20/需要注意的基本运算-操作/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/20/%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97-%E6%93%8D%E4%BD%9C/","excerpt":"还记得幂运算怎么写吗？什么是三元运算符？","text":"还记得幂运算怎么写吗？什么是三元运算符？ 幂运算：1234&gt;&gt;&gt;2**416&gt;&gt;&gt;2**101024 三元运算符格式： result = 值1 if 条件 else 值2如果条件为真 -&gt; result = 值1如果条件为假 -&gt; result = 值2 例子： 123456789&gt;&gt;&gt; a =5&gt;&gt;&gt; b =6&gt;&gt;&gt; c =7&gt;&gt;&gt; d = a if b&gt;c else 8&gt;&gt;&gt; d8&gt;&gt;&gt; d = a if b&lt;c else 8&gt;&gt;&gt; d5","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"}]},{"title":"Python 3的byte和string","slug":"Python-3的byte和string","date":"2019-03-19T18:25:50.000Z","updated":"2019-06-10T14:13:42.541Z","comments":true,"path":"2019/03/20/Python-3的byte和string/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/20/Python-3%E7%9A%84byte%E5%92%8Cstring/","excerpt":"Python 3最大的新特性是对文本和二进制数据作了更为清晰的区分。文本总是Unicode,由string类型表示，二进制数据则由byte类型表示。Python 3不会以任意隐式方式混用string和byte。","text":"Python 3最大的新特性是对文本和二进制数据作了更为清晰的区分。文本总是Unicode,由string类型表示，二进制数据则由byte类型表示。Python 3不会以任意隐式方式混用string和byte。 字符串可以通过编码(encode)转成一串字节，一串字节通过解码(decode)转成字符串 例子： 123456789msg=\"华南理工大学\"encodeResult = msg.encode(encoding='utf-8')#python 3.x 默认编码器按utf-8编码decodeResult = encodeResult.decode(encoding=\"utf-8\")print(\"msg:\",msg)print(\"encode:\",encodeResult)print(\"type of encodeResult: \",type(encodeResult))print(\"decode:\",decodeResult)print(\"type of decodeResult: \",type(decodeResult)) 运行后： msg: 华南理工大学encode: b’\\xe5\\x8d\\x8e\\xe5\\x8d\\x97\\xe7\\x90\\x86\\xe5\\xb7\\xa5\\xe5\\xa4\\xa7\\xe5\\xad\\xa6’type of encodeResult: &lt;class ‘bytes’&gt;decode: 华南理工大学type of decodeResult: &lt;class ‘str’&gt;","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"}]},{"title":"sys模块和os模块","slug":"sys模块和os模块","date":"2019-03-19T17:04:16.000Z","updated":"2019-06-10T14:14:15.889Z","comments":true,"path":"2019/03/20/sys模块和os模块/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/20/sys%E6%A8%A1%E5%9D%97%E5%92%8Cos%E6%A8%A1%E5%9D%97/","excerpt":"初识sys模块和os模块","text":"初识sys模块和os模块 sys模块12345678910111213import sys\"\"\"先到当前目录下找sys模块，因此py文件起名最好不要和标准库名相同sys.path返回sys模块的所有目录(以Python3.6为例)Python的第三方库一般保存在Python36/Lib/site-packages下，标准库一般存放在Python36/Lib下\"\"\"print(sys.path)#打印环境变量print(sys.argv)#在pycharm中运行打印sys_mod.py的绝对路径#在命令提示符窗口中运行打印sys_mod.py的相对路径print(sys.argv[2])#在命令提示符窗口中运行打印sys_mod.py的相对路径以及第2个参数 os模块1234import oscmd_res = os.system(\"dir\") #执行命令，不保存结果print(\"---&gt;\",cmd_res) 运行后 左下角的代表os.system(“dir”)执行成功返回的状态码，“0”表示成功，非“0”表示失败。 12345678910import oscmd_res = os.popen(\"dir\").read()'''为什么加read()?因为执行完os.popen(\"dir\")后，结果存在内存的一个临时区域，需要用read()方法把结果取出来。'''print(\"---&gt;\",cmd_res) 运行后 12import osos.mkdir(\"new_dir\")#在当前目录创建一个文件夹 运行后","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"}]},{"title":"代码注释 & 终端输入 & if_else","slug":"代码注释-终端输入","date":"2019-03-19T12:17:48.000Z","updated":"2019-06-10T14:14:23.240Z","comments":true,"path":"2019/03/19/代码注释-终端输入/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/19/%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-%E7%BB%88%E7%AB%AF%E8%BE%93%E5%85%A5/","excerpt":"Python代码注释及其应用","text":"Python代码注释及其应用 当前行注释：1# print(\"hahaha\"); 多行注释：123456789\"\"\"name = \"maxwell\";print(\"maxwell\");\"\"\"或'''name = \"maxwell\";print(\"maxwell\");''' 终端输入例子:12345name = input(\"username：\")password = input(\"password:\")age = int(input(\"age:\"))job = input(\"job:\")salary = float(input(\"salary:\")) input()函数返回结果属于字符串类型！ 补充： Python 3.x里的input()函数功能与Python 2.x里的raw_input()功能相同 Python 2.x里的input()需要传入的是变量 打印动态多行注释：12345678info='''---------- info of %s -----------Name: %sAge: %dJob: %sSalary: %f''' % (name,name,age,job,salary) #记得加括号！#print(type(age),type(salary))print(info) 12345678910info2 = '''---------- info2 of &#123;_name&#125; -----------Name: &#123;_name&#125;Age: &#123;_age&#125;Job: &#123;_job&#125;Salary: &#123;_salary&#125;'''.format(_name=name, _age=age, _job=job, _salary=salary)print(info2) 1234567info3 = '''---------- info3 of &#123;0&#125; -----------Name: &#123;0&#125;Age: &#123;1&#125;Job: &#123;2&#125;Salary: &#123;3&#125;'''.format(name,age,job,salary)print(info3) 不到万不得已，不要用“+”拼接字符串，效率很低。 密码输入：12345678910111213141516171819202122232425262728import getpass#getpass模块可实现暗文输入密码功能name = input(\"usename:\")password = getpass.getpass(\"password:\")#pycharm下运行会卡在此句，建议在命令提示符窗口运行此脚本#getpass.getpass()返回的变量类型是字符串info = '''----- info -------username: %spassword: %s'''% (name,password)#记得加括号！print(info)info2 = '''----- info2 -------username: &#123;_name&#125;password: &#123;_password&#125;'''.format(_name=name,_password=password)print(info2)info3 = '''----- info3 -------username: &#123;0&#125;password: &#123;1&#125;'''.format(name,password)#注意在对应变量的位置大括号print(info3) if_else例子：12345678910_usrname = 'Mingjun Wei'_pwd = 123456 #int型变量usrname = input(\"name:\")pwd = int(input(\"password:\"))#注意转变量类型，input()返回字符串类型if _usrname == usrname and _pwd == pwd: print(\"Welcome &#123;usrname&#125; login ...\".format(usrname=_usrname))else: print(\"invalid username or password!\")","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"}]},{"title":"Python 3相比Python 2的变化","slug":"Python3相比Python2的变化","date":"2019-03-19T09:13:17.000Z","updated":"2019-06-10T14:13:55.199Z","comments":true,"path":"2019/03/19/Python3相比Python2的变化/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/19/Python3%E7%9B%B8%E6%AF%94Python2%E7%9A%84%E5%8F%98%E5%8C%96/","excerpt":"主要是编码方面的变化","text":"主要是编码方面的变化 编码方面Python 3默认按UTF-8处理，支持中文字符；Python 2默认按ASCII处理，不支持中文字符。 在Python 2中如需使用中文字符，比须首行声明字符集如下： 1# -*- coding:utf-8 -*-","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"}]},{"title":"Python编写规范","slug":"Python编写规范","date":"2019-03-19T08:48:24.000Z","updated":"2019-06-10T14:14:07.342Z","comments":true,"path":"2019/03/19/Python编写规范/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/19/Python%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83/","excerpt":"Python中变量的定义规则、定义规范以及其他注意事项。","text":"Python中变量的定义规则、定义规范以及其他注意事项。 一、变量定义规则： 变量名只能是字母、下划线、数字的任意组合； 变量名的第一个字符不能是数字； 变量名不能和关键字重名。 规范： 起变量名要见名知意； 驼峰形式命名； 变量名字母要小写，常量名子母要大写。 在shell中赋值变量，语句中不能加空格，如： 12name=\"Mingjun Wei\"（√）name = \"Mingjun Wei\"（×） 二、不是同级的语句要顶格写错误示范： 1234567891011121314_usrname = 'Mingjun Wei'_pwd = 123456usrname = input(\"name:\")pwd = int(input(\"password:\"))if _usrname == usrname and _pwd == pwd: print(\"Welcome &#123;usrname&#125; login ...\".format(usrname=_usrname))else: print(\"invalid username or password!\") print(\"sssss\")#此句前边要么和if语句同级顶格，要么#和print(\"invalid username or password!\")同级缩进(4个空格),#前边不能留一个空格，否则会报错。 编写前一定要画流程图。","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"}]},{"title":"设置您的PyCharm","slug":"设置您的PyCharm","date":"2019-03-19T08:33:26.000Z","updated":"2019-06-10T14:14:37.257Z","comments":true,"path":"2019/03/19/设置您的PyCharm/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/19/%E8%AE%BE%E7%BD%AE%E6%82%A8%E7%9A%84PyCharm/","excerpt":"使用PyCharm时常用的设置事项。","text":"使用PyCharm时常用的设置事项。 一、改变pycharm terminal的字体file-&gt;settings-&gt;Editor-&gt;General-&gt;Console里面的console commands history size 二、通过默认模板新建文件:File-&gt;settings-&gt;Editor-&gt;File and Code Templates-&gt;Python Script 三、修改pycharm默认编码器：File-&gt;Setting-&gt;Editor-&gt;File Encodeings 为减少出现乱码的可能性，最好把Global Encoding、Project Encoding、Default encoding for properties files全部改成UTF-8。 注意： 刚安装pycharm后，Project Encoding、Default encoding for properties files默认是GBK。","categories":[],"tags":[{"name":"PyCharm","slug":"PyCharm","permalink":"https://weimingjuncn.github.io/tags/PyCharm/"}]},{"title":"Python头部“#!/usr/bin/env python” 和“#!/usr/bin/python”的区别","slug":"Python头部-usr-bin-python-和-usr-bin-env-的区别","date":"2019-03-19T08:16:12.000Z","updated":"2020-06-13T07:51:30.034Z","comments":true,"path":"2019/03/19/Python头部-usr-bin-python-和-usr-bin-env-的区别/","link":"","permalink":"https://weimingjuncn.github.io/2019/03/19/Python%E5%A4%B4%E9%83%A8-usr-bin-python-%E5%92%8C-usr-bin-env-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"大部分Python文件的第一行写着#!/usr/bin/env python或者#!/usr/bin/python，这两条语句和运行模式有关。","text":"大部分Python文件的第一行写着#!/usr/bin/env python或者#!/usr/bin/python，这两条语句和运行模式有关。 如果我们用普通运行模式例如（在Linux下执行命令）： 1python *.py 那么这两条头部语句没什么卵用。但如果打算让Python程序像普通程序一样运行，例如执行命令（注：文件要有可执行权限chmod a+x *.py）： 1.&#x2F;*.py 这两条头部语句就起作用了，它们用来为脚本语言指定解释器，通常认为用#!/usr/bin/env python要比#!/usr/bin/python更好，因为Python解释器有时并不安装在默认路径，比如安装在虚拟环境中。 两条语句逐一解释如下： 1#!/usr/bin/env python 当机器上安装了多个版本的Python时这种写法才有意义。程序运行时机器会先去取环境变量的PATH中指定的第一个Python来执行您的脚本。如果您配置了虚拟环境，这条头部语句可以保证脚本由您的虚拟环境python中的Python来执行。 1#!/usr/bin/python 表示写死了就是要用目录/usr/bin/python下的Python来执行您的脚本。这样写程序的可移植性比较差，如果此路径下的Python不存在就会报错。 因此一般情况下采用第一种写法。","categories":[{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"}]},{"title":"Markdown小技巧（一）","slug":"Markdown小技巧","date":"2019-02-13T09:54:39.000Z","updated":"2019-06-10T14:13:28.279Z","comments":true,"path":"2019/02/13/Markdown小技巧/","link":"","permalink":"https://weimingjuncn.github.io/2019/02/13/Markdown%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"在Cmd Markdown编辑器中把一个引用块分成俩","text":"在Cmd Markdown编辑器中把一个引用块分成俩 我在使用作业部落出品CmdMarkdown编辑器编写.md文件时遇到的问题： 我希望连续出现两个引用块，而两个引用块中间隔着一个空行，两个引用快还是连在一起的。查阅网上的帖子后发现解决方法： 两个引用块之间需要间隔两个空行，其中第二个空行行首必须打出一个全角空格。 例子： 1234&gt; ＂I used to be an adventurer like you, then I took an arrow in the knee.＂（全角空格）&gt; ＂Never should you come here.＂ 效果： I used to be an adventurer like you, then I took an arrow in the knee. Never should you come here.","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://weimingjuncn.github.io/tags/markdown/"}]},{"title":"Markdown小技巧（一）","slug":"Markdown小技巧（一）","date":"2019-02-13T09:54:39.000Z","updated":"2020-01-08T07:56:19.519Z","comments":true,"path":"2019/02/13/Markdown小技巧（一）/","link":"","permalink":"https://weimingjuncn.github.io/2019/02/13/Markdown%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"我在使用作业部落出品CmdMarkdown编辑器编写.md文件时遇到的问题： 我希望连续出现两个引用块，而两个引用块中间隔着一个空行，两个引用快还是连在一起的。查阅网上的帖子后发现解决方法： 两个引用块之间需要间隔两个空行，其中第二个空行行首必须打出一个全角空格。 例子： 1234&gt; ＂I used to be an adventurer like you, then I took an arrow in the knee.＂（全角空格）&gt; ＂Never should you come here.＂ 效果： I used to be an adventurer like you, then I took an arrow in the knee. Never should you come here.","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://weimingjuncn.github.io/tags/markdown/"}]}],"categories":[{"name":"DarkSoulsDemo with Unity","slug":"DarkSoulsDemo-with-Unity","permalink":"https://weimingjuncn.github.io/categories/DarkSoulsDemo-with-Unity/"},{"name":"Game Develop","slug":"Game-Develop","permalink":"https://weimingjuncn.github.io/categories/Game-Develop/"},{"name":"编程","slug":"编程","permalink":"https://weimingjuncn.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"搭建博客","slug":"搭建博客","permalink":"https://weimingjuncn.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"C&#35","slug":"C-35","permalink":"https://weimingjuncn.github.io/tags/C-35/"},{"name":"Unity","slug":"Unity","permalink":"https://weimingjuncn.github.io/tags/Unity/"},{"name":"UGUI","slug":"UGUI","permalink":"https://weimingjuncn.github.io/tags/UGUI/"},{"name":"C++","slug":"C","permalink":"https://weimingjuncn.github.io/tags/C/"},{"name":"Game Design","slug":"Game-Design","permalink":"https://weimingjuncn.github.io/tags/Game-Design/"},{"name":"Lua","slug":"Lua","permalink":"https://weimingjuncn.github.io/tags/Lua/"},{"name":"markdown","slug":"markdown","permalink":"https://weimingjuncn.github.io/tags/markdown/"},{"name":"UE4","slug":"UE4","permalink":"https://weimingjuncn.github.io/tags/UE4/"},{"name":"Hexo","slug":"Hexo","permalink":"https://weimingjuncn.github.io/tags/Hexo/"},{"name":"git","slug":"git","permalink":"https://weimingjuncn.github.io/tags/git/"},{"name":"CodeBlocks","slug":"CodeBlocks","permalink":"https://weimingjuncn.github.io/tags/CodeBlocks/"},{"name":"Python","slug":"Python","permalink":"https://weimingjuncn.github.io/tags/Python/"},{"name":"PyCharm","slug":"PyCharm","permalink":"https://weimingjuncn.github.io/tags/PyCharm/"}]}